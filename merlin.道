// This is the second iteration of the drawing domain. The first sucked.
//
// This domain represents the visual aspect of a model.
use v2::merlin;
use v2::sarzak;

// An Anchor Point for Lines
//
// This represents a point on the periphery of a box to which a relationship attaches.
//
// It's really sort of clever. Once you figure out which edge, you use the `offset` attribute
//  (a float between 0.0 and 1.0) to calculate how far along that line to draw the line.
//
// ðŸš§ The offsets are meant to be for the relationship phrase maybe? Drat, I'll have to figure
//  that out.ðŸš§
//
struct Anchor {
    id: Uuid,
    offset: float,
    x_offset: int,
    y_offset: int,
    edge: &Edge,
    glyph: &Glyph,
    x_box: &XBox,
    line: &Line,
}
impl Anchor {
    fn new(
        offset: float,
        x_offset: int,
        y_offset: int,
        edge: &Edge,
        glyph: &Glyph,
        x_box: &XBox,
        line: &Line,
    ) -> Anchor {
        let id = Uuid::new();
        Anchor {
            id: id,
            offset: offset,
            x_offset: x_offset,
            y_offset: y_offset,
            edge: edge,
            glyph: glyph,
            x_box: x_box,
            line: line,
        }
    }

    fn help() -> () {
        print("An Anchor Point for Lines\n");
        print("\n");
        print(
            "This represents a point on the periphery of a box to which a relationship attaches.\n",
        );
        print("\n");
        print("It's really sort of clever. Once you figure out which edge, you use the `offset` attribute\n");
        print(" (a float between 0.0 and 1.0) to calculate how far along that line to draw the line.\n");
        print("\n");
        print("ðŸš§ The offsets are meant to be for the relationship phrase maybe? Drat, I'll have to figure\n");
        print(" that out.ðŸš§\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Anchor {\n");
        print("    id: Uuid,\n");
        print("    offset: float,\n");
        print("    x_offset: int,\n");
        print("    y_offset: int,\n");
        print("    edge: &Edge,\n");
        print("    glyph: &Glyph,\n");
        print("    x_box: &XBox,\n");
        print("    line: &Line,\n");
        print("}\n");
    }
}

struct Bisection {
    id: Uuid,
    offset: float,
    segment: &LineSegment,
}
impl Bisection {
    fn new(offset: float, segment: &LineSegment) -> Bisection {
        let id = Uuid::new();
        Bisection {
            id: id,
            offset: offset,
            segment: segment,
        }
    }

    fn help() -> () {}

    fn info() -> () {
        print("struct Bisection {\n");
        print("    id: Uuid,\n");
        print("    offset: float,\n");
        print("    segment: &LineSegment,\n");
        print("}\n");
    }
}

struct Bottom {
    id: Uuid,
}
impl Bottom {
    fn new() -> Bottom {
        let id = Uuid::new();
        Bottom { id: id }
    }

    fn help() -> () {}

    fn info() -> () {
        print("struct Bottom {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// More than a box
//
// This is the primary method of drawing an Object on the screen. I'm sure it'll be used for
//  State's as well.
//
// It's a rectangle with parameters.
//
struct XBox {
    height: int,
    id: Uuid,
    width: int,
    x: int,
    y: int,
    object: &Object,
}
impl XBox {
    fn new(height: int, width: int, x: int, y: int, object: &Object) -> XBox {
        let id = Uuid::new();
        XBox {
            height: height,
            id: id,
            width: width,
            x: x,
            y: y,
            object: object,
        }
    }

    fn help() -> () {
        print("More than a box\n");
        print("\n");
        print("This is the primary method of drawing an Object on the screen. I'm sure it'll be used for\n");
        print(" State's as well.\n");
        print("\n");
        print("It's a rectangle with parameters.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct XBox {\n");
        print("    height: int,\n");
        print("    id: Uuid,\n");
        print("    width: int,\n");
        print("    x: int,\n");
        print("    y: int,\n");
        print("    object: &Object,\n");
        print("}\n");
    }
}

struct Edge {
    id: Uuid,
}
impl Edge {
    fn new() -> Edge {
        let id = Uuid::new();
        Edge { id: id }
    }

    fn help() -> () {}

    fn info() -> () {
        print("struct Edge {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

struct Glyph {
    id: Uuid,
    line: &Line,
}
impl Glyph {
    fn new(line: &Line) -> Glyph {
        let id = Uuid::new();
        Glyph { id: id, line: line }
    }

    fn help() -> () {}

    fn info() -> () {
        print("struct Glyph {\n");
        print("    id: Uuid,\n");
        print("    line: &Line,\n");
        print("}\n");
    }
}

struct Inflection {
    id: Uuid,
}
impl Inflection {
    fn new() -> Inflection {
        //     let id = Uuid::new();
        //     Inflection {
        //         id: id,
        //     }
        INFLECTION::new()
    }

    fn help() -> () {}

    fn info() -> () {
        print("struct Inflection {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

struct Left {
    id: Uuid,
}
impl Left {
    fn new() -> Left {
        let id = Uuid::new();
        Left { id: id }
    }

    fn help() -> () {}

    fn info() -> () {
        print("struct Left {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// Relationship Line
//
// A line is how we represent a relationship. A line is composed of many [`Line Segment`]-
// s.
//
struct Line {
    id: Uuid,
    relationship: &Relationship,
}
impl Line {
    fn new(relationship: &Relationship) -> Line {
        let id = Uuid::new();
        Line {
            id: id,
            relationship: relationship,
        }
    }

    fn help() -> () {
        print("Relationship Line\n");
        print("\n");
        print("A line is how we represent a relationship. A line is composed of many [`Line Segment`]-\n");
        print("s.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Line {\n");
        print("    id: Uuid,\n");
        print("    relationship: &Relationship,\n");
        print("}\n");
    }
}

// Part of a Line
//
// A line segment is in fact a straight line. It is used to compose a (poly) [`Line`].
//
struct LineSegment {
    id: Uuid,
    line: &Line,
}
impl LineSegment {
    fn new(line: &Line) -> LineSegment {
        let id = Uuid::new();
        LineSegment { id: id, line: line }
    }

    fn help() -> () {
        print("Part of a Line\n");
        print("\n");
        print(
            "A line segment is in fact a straight line. It is used to compose a (poly) [`Line`].\n",
        );
        print("\n");
    }

    fn info() -> () {
        print("struct LineSegment {\n");
        print("    id: Uuid,\n");
        print("    line: &Line,\n");
        print("}\n");
    }
}

struct LineSegmentPoint {
    id: Uuid,
    segment: &LineSegment,
    point: &Point,
}
impl LineSegmentPoint {
    fn new(segment: &LineSegment, point: &Point) -> LineSegmentPoint {
        let id = Uuid::new();
        LineSegmentPoint {
            id: id,
            segment: segment,
            point: point,
        }
    }

    fn help() -> () {}

    fn info() -> () {
        print("struct LineSegmentPoint {\n");
        print("    id: Uuid,\n");
        print("    segment: &LineSegment,\n");
        print("    point: &Point,\n");
        print("}\n");
    }
}

struct Many {
    id: Uuid,
}
impl Many {
    fn new() -> Many {
        let id = Uuid::new();
        Many { id: id }
    }

    fn help() -> () {}

    fn info() -> () {
        print("struct Many {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

struct One {
    id: Uuid,
}
impl One {
    fn new() -> One {
        let id = Uuid::new();
        One { id: id }
    }

    fn help() -> () {}

    fn info() -> () {
        print("struct One {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

struct Point {
    id: Uuid,
    x: int,
    y: int,
    // #[hidden]
    proxy: PointProxy,
    // subtype: PointEnum, which is one of Anchor, Bisection, or Inflection, which
    // are separate structs here. I guess they are separate in the store too. The
    // issue is how to hold a point here, and see what it's subtype is. That sounds
    // like a method...
    // It's not so simple though, because we don't have a pointer back to the
    // reified struct, do we? They are together someplace...
}
impl Point {
    fn new(x: int, y: int) -> Point {
        let id = Uuid::new();
        Point {
            id: id,
            x: x,
            y: y,
            proxy: POINT::new(x, y),
        }
    }

    // #[pre_set(field=x)]
    // fn set_x(&self, x: int) -> () {
    //     let proxy = self.proxy;
    //     proxy.x = x;
    // }

    fn help() -> () {}

    fn info() -> () {
        print("struct Point {\n");
        print("    id: Uuid,\n");
        print("    x: int,\n");
        print("    y: int,\n");
        print("}\n");
    }
}

struct RelationshipName {
    id: Uuid,
    text: string,
    x: int,
    y: int,
    origin: &Bisection,
    line: &Line,
}
impl RelationshipName {
    fn new(text: string, x: int, y: int, origin: &Bisection, line: &Line) -> RelationshipName {
        let id = Uuid::new();
        RelationshipName {
            id: id,
            text: text,
            x: x,
            y: y,
            origin: origin,
            line: line,
        }
    }

    fn help() -> () {}

    fn info() -> () {
        print("struct RelationshipName {\n");
        print("    id: Uuid,\n");
        print("    text: string,\n");
        print("    x: int,\n");
        print("    y: int,\n");
        print("    origin: &Bisection,\n");
        print("    line: &Line,\n");
        print("}\n");
    }
}

struct RelationshipPhrase {
    id: Uuid,
    text: string,
    x: int,
    y: int,
    origin: &Anchor,
    line: &Line,
}
impl RelationshipPhrase {
    fn new(text: string, x: int, y: int, origin: &Anchor, line: &Line) -> RelationshipPhrase {
        let id = Uuid::new();
        RelationshipPhrase {
            id: id,
            text: text,
            x: x,
            y: y,
            origin: origin,
            line: line,
        }
    }

    fn help() -> () {}

    fn info() -> () {
        print("struct RelationshipPhrase {\n");
        print("    id: Uuid,\n");
        print("    text: string,\n");
        print("    x: int,\n");
        print("    y: int,\n");
        print("    origin: &Anchor,\n");
        print("    line: &Line,\n");
        print("}\n");
    }
}

struct Right {
    id: Uuid,
}
impl Right {
    fn new() -> Right {
        let id = Uuid::new();
        Right { id: id }
    }

    fn help() -> () {}

    fn info() -> () {
        print("struct Right {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

struct Sub {
    id: Uuid,
}
impl Sub {
    fn new() -> Sub {
        let id = Uuid::new();
        Sub { id: id }
    }

    fn help() -> () {}

    fn info() -> () {
        print("struct Sub {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

struct XSuper {
    id: Uuid,
}
impl XSuper {
    fn new() -> XSuper {
        let id = Uuid::new();
        XSuper { id: id }
    }

    fn help() -> () {}

    fn info() -> () {
        print("struct XSuper {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

struct Top {
    id: Uuid,
}
impl Top {
    fn new() -> Top {
        let id = Uuid::new();
        Top { id: id }
    }

    fn help() -> () {}

    fn info() -> () {
        print("struct Top {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}
