//! Macros for navigating the "Sarzak" domain
//!
//! # Generated Code -- edit _with care_.
//!
//! Don't mess with anything between `{"magic":"îž¨","kind":"CriticalBlockBegin"}`
//! and `{"magic":"îž¨","kind":"CriticalBlockEnd"}`. Otherwise, you should be free
//! to go wild. Happy hacking!
//!
//! Use the following invocation to reproduce:
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
//! ```shell
//!  sarzak gen
//! ```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
// {"magic":"îž¨","version":"0.5.0"}

/// Macro to traverse [`Referrer`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R17_
///
/// This macro expects a &[`Referrer`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referrer
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r17;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_dlj = Conditionality::test_default(&mut store);
/// let lumpy_comparison = "puny_rake".to_owned();
/// let weak_bottle = "ceaseless_rake".to_owned();
/// let eight_seat = "erratic_sense".to_owned();
/// let object_ujy = Object::new(&mut store, lumpy_comparison, weak_bottle, eight_seat);
/// let cardinality_tex = Cardinality::test_default(&mut store);
/// let marvelous_vessel = "scintillating_meeting".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_dlj, &object_ujy, &cardinality_tex, marvelous_vessel);
///
/// let object_fnk = sarzak_get_one_obj_across_r17!(referrer, store);
/// assert_eq!(&object_ujy, object_fnk);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r17 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r17;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Referrer`][ðŸ¦ž], via _R17(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Referrer`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Referrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak_maybe_get_one_r_from_across_r17;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_rxw = Conditionality::test_default(&mut store);
/// let smiling_stem = "gaping_respect".to_owned();
/// let satisfying_cannon = "drunk_women".to_owned();
/// let tense_riddle = "tart_home".to_owned();
/// let object_czz = Object::new(&mut store, smiling_stem, satisfying_cannon, tense_riddle);
/// let cardinality_faz = Cardinality::test_default(&mut store);
/// let billowy_apparatus = "squalid_organization".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_rxw, &object_czz, &cardinality_faz, billowy_apparatus);
/// let referrer_mao = sarzak_maybe_get_one_r_from_across_r17!(object_czz, store);
///
/// assert_eq!(Some(&referrer), referrer_mao);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_from_across_r17 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-referrer-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_referrer()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-referrer-emit_one_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_one_r_from_across_r17;

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`Cardinality`][ðŸ¦ž], via _R8_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`Cardinality`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referent
/// [ðŸ¦ž]: crate::sarzak::types::Cardinality
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak_get_one_card_across_r8;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_alh = Conditionality::test_default(&mut store);
/// let natural_feet = "loud_linen".to_owned();
/// let abashed_camera = "auspicious_idea".to_owned();
/// let conscious_number = "serious_grandmother".to_owned();
/// let object_zrm = Object::new(&mut store, natural_feet, abashed_camera, conscious_number);
/// let cardinality_lxm = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_alh, &object_zrm, &cardinality_lxm);
///
/// let cardinality_prc = sarzak_get_one_card_across_r8!(referent, store);
/// assert_eq!(&cardinality_lxm, cardinality_prc);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_card_across_r8 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_cardinality(&$input.cardinality).unwrap()
    }};
}
pub use sarzak_get_one_card_across_r8;

/// Macro to traverse [`Cardinality`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R8(c)_
///
/// This macro expects a &[`Cardinality`][ðŸ¦€], and returns an Option<&[`Referent`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Cardinality
/// [ðŸ¦ž]: crate::sarzak::types::Referent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak_maybe_get_many_r_tos_across_r8;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_hns = Conditionality::test_default(&mut store);
/// let teeny_tiny_crack = "clean_attempt".to_owned();
/// let tight_orange = "doubtful_picture".to_owned();
/// let common_account = "unable_temper".to_owned();
/// let object_xnf = Object::new(&mut store, teeny_tiny_crack, tight_orange, common_account);
/// let cardinality_aua = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_hns, &object_xnf, &cardinality_aua);
/// let referent_clu = sarzak_maybe_get_many_r_tos_across_r8!(cardinality_aua, store);
///
/// assert!(referent_clu.iter().find(|&x| **x == referent).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_r_tos_across_r8 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"cardinality-referent-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referent()
            .filter_map(|z| if z.1.cardinality == $input.get_id() { Some(z.1) } else { None })
            .collect::<Vec<&Referent>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"cardinality-referent-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_r_tos_across_r8;

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R16_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referent
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak_get_one_obj_across_r16;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_gfm = Conditionality::test_default(&mut store);
/// let hulking_coal = "ad_soap".to_owned();
/// let abandoned_lettuce = "wrathful_kite".to_owned();
/// let bashful_cellar = "incompetent_motion".to_owned();
/// let object_ldq = Object::new(&mut store, hulking_coal, abandoned_lettuce, bashful_cellar);
/// let cardinality_gim = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_gfm, &object_ldq, &cardinality_gim);
///
/// let object_fkq = sarzak_get_one_obj_across_r16!(referent, store);
/// assert_eq!(&object_ldq, object_fkq);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r16 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r16;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R16(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Referent`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Referent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak_maybe_get_one_r_to_across_r16;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_rjl = Conditionality::test_default(&mut store);
/// let old_fashioned_kite = "warlike_star".to_owned();
/// let brief_toothbrush = "belligerent_metal".to_owned();
/// let second_teeth = "fallacious_garden".to_owned();
/// let object_fia = Object::new(&mut store, old_fashioned_kite, brief_toothbrush, second_teeth);
/// let cardinality_yhm = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_rjl, &object_fia, &cardinality_yhm);
/// let referent_yis = sarzak_maybe_get_one_r_to_across_r16!(object_fia, store);
///
/// assert_eq!(Some(&referent), referent_yis);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_to_across_r16 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-referent-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_referent()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-referent-emit_one_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_one_r_to_across_r16;

/// Macro to traverse [`OneSide`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R24_
///
/// This macro expects a &[`OneSide`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::OneSide
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r24;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let spurious_year = "detailed_poison".to_owned();
/// let unbiased_meat = "flimsy_stage".to_owned();
/// let voracious_tank = "clean_bread".to_owned();
/// let object_xzk = Object::new(&mut store, spurious_year, unbiased_meat, voracious_tank);
///
/// let one_side = OneSide::new(&mut store, &object_xzk);
///
/// let object_mmv = sarzak_get_one_obj_across_r24!(one_side, store);
/// assert_eq!(&object_xzk, object_mmv);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r24 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r24;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`OneSide`][ðŸ¦ž], via _R24(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`OneSide`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::OneSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak_maybe_get_one_r_one_across_r24;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let caring_condition = "rigid_pipe".to_owned();
/// let jobless_field = "wistful_day".to_owned();
/// let cloudy_ocean = "obtainable_talk".to_owned();
/// let object_kcj = Object::new(&mut store, caring_condition, jobless_field, cloudy_ocean);
///
/// let one_side = OneSide::new(&mut store, &object_kcj);
/// let one_side_tbn = sarzak_maybe_get_one_r_one_across_r24!(object_kcj, store);
///
/// assert_eq!(Some(&one_side), one_side_tbn);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_one_across_r24 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-one_side-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_one_side()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-one_side-emit_one_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_one_r_one_across_r24;

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`Conditionality`][ðŸ¦ž], via _R12_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`Conditionality`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referent
/// [ðŸ¦ž]: crate::sarzak::types::Conditionality
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_cond_across_r12;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_nnu = Conditionality::test_default(&mut store);
/// let mighty_angle = "needless_stick".to_owned();
/// let nine_mom = "reflective_powder".to_owned();
/// let previous_governor = "superficial_geese".to_owned();
/// let object_ppj = Object::new(&mut store, mighty_angle, nine_mom, previous_governor);
/// let cardinality_dfb = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_nnu, &object_ppj, &cardinality_dfb);
///
/// let conditionality_qig = sarzak_get_one_cond_across_r12!(referent, store);
/// assert_eq!(&conditionality_nnu, conditionality_qig);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_cond_across_r12 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store
            .exhume_conditionality(&$input.conditionality)
            .unwrap()
    }};
}
pub use sarzak_get_one_cond_across_r12;

/// Macro to traverse [`Conditionality`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R12(c)_
///
/// This macro expects a &[`Conditionality`][ðŸ¦€], and returns an Option<&[`Referent`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Conditionality
/// [ðŸ¦ž]: crate::sarzak::types::Referent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak_maybe_get_many_r_tos_across_r12;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_scm = Conditionality::test_default(&mut store);
/// let woebegone_daughter = "ahead_spy".to_owned();
/// let next_government = "rainy_opinion".to_owned();
/// let shy_mask = "able_theory".to_owned();
/// let object_dta = Object::new(&mut store, woebegone_daughter, next_government, shy_mask);
/// let cardinality_ons = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_scm, &object_dta, &cardinality_ons);
/// let referent_lvk = sarzak_maybe_get_many_r_tos_across_r12!(conditionality_scm, store);
///
/// assert!(referent_lvk.iter().find(|&x| **x == referent).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_r_tos_across_r12 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"conditionality-referent-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referent()
            .filter_map(|z| if z.1.conditionality == $input.get_id() { Some(z.1) } else { None })
            .collect::<Vec<&Referent>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"conditionality-referent-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_r_tos_across_r12;

/// Macro to traverse [`AssociativeSide`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R26_
///
/// This macro expects a &[`AssociativeSide`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::AssociativeSide
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r26;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let scattered_woman = "frightening_band".to_owned();
/// let bright_ducks = "numberless_powder".to_owned();
/// let splendid_letters = "zonked_zinc".to_owned();
/// let object_zfl = Object::new(&mut store, scattered_woman, bright_ducks, splendid_letters);
///
/// let associative_side = AssociativeSide::new(&mut store, &object_zfl);
///
/// let object_ntb = sarzak_get_one_obj_across_r26!(associative_side, store);
/// assert_eq!(&object_zfl, object_ntb);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r26 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r26;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`AssociativeSide`][ðŸ¦ž], via _R26(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`AssociativeSide`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::AssociativeSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak_maybe_get_one_r_ass_across_r26;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let slimy_calculator = "measly_lizards".to_owned();
/// let nimble_lawyer = "testy_brass".to_owned();
/// let foamy_table = "afraid_foot".to_owned();
/// let object_bxe = Object::new(&mut store, slimy_calculator, nimble_lawyer, foamy_table);
///
/// let associative_side = AssociativeSide::new(&mut store, &object_bxe);
/// let associative_side_mnl = sarzak_maybe_get_one_r_ass_across_r26!(object_bxe, store);
///
/// assert_eq!(Some(&associative_side), associative_side_mnl);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_ass_across_r26 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-associative_side-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_side()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-associative_side-emit_one_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_one_r_ass_across_r26;

/// Macro to traverse [`Referrer`][ðŸ¦€] âž¡ [`Conditionality`][ðŸ¦ž], via _R11_
///
/// This macro expects a &[`Referrer`][ðŸ¦€], and returns a &[`Conditionality`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referrer
/// [ðŸ¦ž]: crate::sarzak::types::Conditionality
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_cond_across_r11;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_aow = Conditionality::test_default(&mut store);
/// let prickly_snakes = "rare_porter".to_owned();
/// let abaft_winter = "ordinary_drawer".to_owned();
/// let gorgeous_bottle = "unruly_quilt".to_owned();
/// let object_gfp = Object::new(&mut store, prickly_snakes, abaft_winter, gorgeous_bottle);
/// let cardinality_cyf = Cardinality::test_default(&mut store);
/// let like_sugar = "bawdy_plane".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_aow, &object_gfp, &cardinality_cyf, like_sugar);
///
/// let conditionality_gmt = sarzak_get_one_cond_across_r11!(referrer, store);
/// assert_eq!(&conditionality_aow, conditionality_gmt);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_cond_across_r11 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store
            .exhume_conditionality(&$input.conditionality)
            .unwrap()
    }};
}
pub use sarzak_get_one_cond_across_r11;

/// Macro to traverse [`Conditionality`][ðŸ¦€] âž¡ [`Referrer`][ðŸ¦ž], via _R11(c)_
///
/// This macro expects a &[`Conditionality`][ðŸ¦€], and returns an Option<&[`Referrer`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Conditionality
/// [ðŸ¦ž]: crate::sarzak::types::Referrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak_maybe_get_many_r_froms_across_r11;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_jvf = Conditionality::test_default(&mut store);
/// let steady_crate = "nonchalant_bean".to_owned();
/// let sparkling_cry = "heartbreaking_driving".to_owned();
/// let innate_branch = "boundless_zipper".to_owned();
/// let object_xrx = Object::new(&mut store, steady_crate, sparkling_cry, innate_branch);
/// let cardinality_qcs = Cardinality::test_default(&mut store);
/// let polite_boundary = "wholesale_voice".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_jvf, &object_xrx, &cardinality_qcs, polite_boundary);
/// let referrer_emv = sarzak_maybe_get_many_r_froms_across_r11!(conditionality_jvf, store);
///
/// assert!(referrer_emv.iter().find(|&x| **x == referrer).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_r_froms_across_r11 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"conditionality-referrer-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referrer()
            .filter_map(|z| if z.1.conditionality == $input.get_id() { Some(z.1) } else { None })
            .collect::<Vec<&Referrer>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"conditionality-referrer-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_r_froms_across_r11;

/// Macro to traverse [`Subtype`][ðŸ¦€] âž¡ [`Isa`][ðŸ¦ž], via _R27_
///
/// This macro expects a &[`Subtype`][ðŸ¦€], and returns a &[`Isa`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Subtype
/// [ðŸ¦ž]: crate::sarzak::types::Isa
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak::Subtype;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::sarzak_get_one_r_isa_across_r27;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let luxuriant_hobbies = "vulgar_plate".to_owned();
/// let glossy_tree = "juvenile_development".to_owned();
/// let mushy_horses = "chilly_ray".to_owned();
/// let object_ntv = Object::new(&mut store, luxuriant_hobbies, glossy_tree, mushy_horses);
/// let supertype_zbb = Supertype::new(&mut store, &object_ntv);
/// let isa_fqi = Isa::new(&mut store, &supertype_zbb, 42);
/// let wary_dad = "stimulating_comb".to_owned();
/// let illegal_foot = "clumsy_news".to_owned();
/// let able_apple = "same_kick".to_owned();
/// let object_ukq = Object::new(&mut store, wary_dad, illegal_foot, able_apple);
///
/// let subtype = Subtype::new(&mut store, &isa_fqi, &object_ukq);
///
/// let isa_vti = sarzak_get_one_r_isa_across_r27!(subtype, store);
/// assert_eq!(&isa_fqi, isa_vti);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_isa_across_r27 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_isa(&$input.isa).unwrap()
    }};
}
pub use sarzak_get_one_r_isa_across_r27;

/// Macro to traverse [`Isa`][ðŸ¦€] âž¡ [`Subtype`][ðŸ¦ž], via _R27_
///
/// This macro expects a &[`Isa`][ðŸ¦€], and returns a &[`Subtype`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Isa
/// [ðŸ¦ž]: crate::sarzak::types::Subtype
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Isa;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak::Subtype;
/// # use sarzak::sarzak_get_many_r_subs_across_r27;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let certain_skin = "watery_oil".to_owned();
/// let adjoining_mitten = "one_bat".to_owned();
/// let ancient_canvas = "tasty_zipper".to_owned();
/// let object_mkd = Object::new(&mut store, certain_skin, adjoining_mitten, ancient_canvas);
/// let supertype_cqj = Supertype::new(&mut store, &object_mkd);
/// let isa_iyc = Isa::new(&mut store, &supertype_cqj, 42);
/// let quickest_cherries = "wistful_bone".to_owned();
/// let scintillating_digestion = "defiant_rail".to_owned();
/// let macho_skin = "vulgar_work".to_owned();
/// let object_tfg = Object::new(&mut store, quickest_cherries, scintillating_digestion, macho_skin);
///
/// let subtype = Subtype::new(&mut store, &isa_iyc, &object_tfg);
/// let subtype_qvk = sarzak_get_many_r_subs_across_r27!(isa_iyc, store);
///
/// assert!(subtype_qvk.iter().find(|&x| **x == subtype).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_many_r_subs_across_r27 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"isa-subtype-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_subtype()
            .filter_map(|z| if z.1.isa == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&Subtype>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"isa-subtype-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_get_many_r_subs_across_r27;

/// Macro to traverse [`Isa`][ðŸ¦€] âž¡ [`Supertype`][ðŸ¦ž], via _R13_
///
/// This macro expects a &[`Isa`][ðŸ¦€], and returns a &[`Supertype`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Isa
/// [ðŸ¦ž]: crate::sarzak::types::Supertype
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::sarzak_get_one_r_sup_across_r13;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let necessary_powder = "luxuriant_hate".to_owned();
/// let adhesive_note = "melted_part".to_owned();
/// let angry_income = "hot_relation".to_owned();
/// let object_rur = Object::new(&mut store, necessary_powder, adhesive_note, angry_income);
/// let supertype_akw = Supertype::new(&mut store, &object_rur);
///
/// let isa = Isa::new(&mut store, &supertype_akw, 42);
///
/// let supertype_ury = sarzak_get_one_r_sup_across_r13!(isa, store);
/// assert_eq!(&supertype_akw, supertype_ury);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_sup_across_r13 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_supertype(&$input.supertype).unwrap()
    }};
}
pub use sarzak_get_one_r_sup_across_r13;

/// Macro to traverse [`Supertype`][ðŸ¦€] âž¡ [`Isa`][ðŸ¦ž], via _R13_
///
/// This macro expects a &[`Supertype`][ðŸ¦€], and returns a &[`Isa`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Supertype
/// [ðŸ¦ž]: crate::sarzak::types::Isa
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_r_isa_across_r13;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let near_berry = "voracious_cow".to_owned();
/// let raspy_cows = "deeply_chalk".to_owned();
/// let typical_legs = "icy_doll".to_owned();
/// let object_ydn = Object::new(&mut store, near_berry, raspy_cows, typical_legs);
/// let supertype_tpl = Supertype::new(&mut store, &object_ydn);
///
/// let isa = Isa::new(&mut store, &supertype_tpl, 42);
/// let isa_jxd = sarzak_get_one_r_isa_across_r13!(supertype_tpl, store);
///
/// assert_eq!(&isa, isa_jxd);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_isa_across_r13 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"supertype-isa-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_isa()
//             .find(|z| z.1.uber == $input.id) //âš¡ï¸
            .find(|z| z.1.supertype == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"supertype-isa-emit_one_unconditional_lookup"}}}
    }};
}
pub use sarzak_get_one_r_isa_across_r13;

/// Macro to traverse [`State`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R18_
///
/// This macro expects a &[`State`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::State
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::State;
/// # use sarzak::sarzak_get_one_obj_across_r18;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let lumpy_price = "utopian_manager".to_owned();
/// let acceptable_profit = "chief_purpose".to_owned();
/// let abnormal_meeting = "public_vase".to_owned();
/// let object_uqw = Object::new(&mut store, lumpy_price, acceptable_profit, abnormal_meeting);
/// let cold_fish = "malicious_oil".to_owned();
///
/// let state = State::new(&mut store, &object_uqw, cold_fish);
///
/// let object_wjs = sarzak_get_one_obj_across_r18!(state, store);
/// assert_eq!(&object_uqw, object_wjs);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r18 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r18;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`State`][ðŸ¦ž], via _R18(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`State`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::State
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::State;
/// # use sarzak::sarzak_maybe_get_many_ss_across_r18;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let magical_patch = "hysterical_hearing".to_owned();
/// let frail_knot = "gleaming_stretch".to_owned();
/// let common_quince = "breezy_coat".to_owned();
/// let object_rwt = Object::new(&mut store, magical_patch, frail_knot, common_quince);
/// let phobic_sidewalk = "billowy_mine".to_owned();
///
/// let state = State::new(&mut store, &object_rwt, phobic_sidewalk);
/// let state_uev = sarzak_maybe_get_many_ss_across_r18!(object_rwt, store);
///
/// assert!(state_uev.iter().find(|&x| **x == state).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_ss_across_r18 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-state-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_state()
            .filter_map(|z| if z.1.obj_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&State>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-state-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_ss_across_r18;

/// Macro to traverse [`State`][ðŸ¦€] âž¡ [`Event`][ðŸ¦ž], across [`AcknowledgedEvent`][ðŸ¦‘] via _R20_
///
/// This macro expects a &[`State`][ðŸ¦€], and returns a &[`Event`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ðŸ¦€]: crate::sarzak::types::State
/// [ðŸ¦ž]: crate::sarzak::types::Event
/// [ðŸ¦‘]: crate::sarzak::types::AcknowledgedEvent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::State;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Event;
/// # use sarzak::sarzak::AcknowledgedEvent;
/// # use sarzak::sarzak_get_many_e_across_r20;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let public_feather = "spiteful_mist".to_owned();
/// let careless_twist = "clean_stop".to_owned();
/// let boorish_friction = "legal_competition".to_owned();
/// let object_tyu = Object::new(&mut store, public_feather, careless_twist, boorish_friction);
/// let weary_death = "ubiquitous_popcorn".to_owned();
/// let state_gxs = State::new(&mut store, &object_tyu, weary_death);
/// let pathetic_love = "grateful_smoke".to_owned();
/// let excellent_mind = "lovely_laugh".to_owned();
/// let illegal_cherries = "maddening_detail".to_owned();
/// let object_qsz = Object::new(&mut store, pathetic_love, excellent_mind, illegal_cherries);
/// let dead_zinc = "cut_acoustics".to_owned();
/// let event_gwe = Event::new(&mut store, &object_qsz, dead_zinc);
/// let acknowledged_event = AcknowledgedEvent::new(&mut store, &state_gxs, &event_gwe);
///
/// let event_dbi = sarzak_get_many_e_across_r20!(state_gxs, store);
/// assert!(event_dbi.iter().find(|&x| **x == event_gwe).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_many_e_across_r20 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_many
        $store
            .iter_acknowledged_event()
            .filter(|a| a.1.state_id == $input.id)
            .map(|a| $store.exhume_event(&a.1.event_id).unwrap())
            .collect::<Vec<&Event>>()
    }};
}
pub use sarzak_get_many_e_across_r20;

/// Macro to traverse [`Event`][ðŸ¦€] âž¡ [`State`][ðŸ¦ž], across [`AcknowledgedEvent`][ðŸ¦‘] via _R20_
///
/// This macro expects a &[`Event`][ðŸ¦€], and returns a &[`State`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ðŸ¦€]: crate::sarzak::types::Event
/// [ðŸ¦ž]: crate::sarzak::types::State
/// [ðŸ¦‘]: crate::sarzak::types::AcknowledgedEvent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Event;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::State;
/// # use sarzak::sarzak::AcknowledgedEvent;
/// # use sarzak::sarzak_get_many_s_across_r20;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let royal_range = "forgetful_boats".to_owned();
/// let plain_fruit = "loving_icicle".to_owned();
/// let quirky_loss = "complex_back".to_owned();
/// let object_drp = Object::new(&mut store, royal_range, plain_fruit, quirky_loss);
/// let beneficial_desk = "noiseless_manager".to_owned();
/// let state_uwj = State::new(&mut store, &object_drp, beneficial_desk);
/// let unsightly_shop = "tiresome_gold".to_owned();
/// let unnatural_polish = "charming_quarter".to_owned();
/// let hospitable_twig = "capricious_lock".to_owned();
/// let object_psn = Object::new(&mut store, unsightly_shop, unnatural_polish, hospitable_twig);
/// let splendid_price = "confused_winter".to_owned();
/// let event_ejm = Event::new(&mut store, &object_psn, splendid_price);
/// let acknowledged_event = AcknowledgedEvent::new(&mut store, &state_uwj, &event_ejm);
///
/// let state_yen = sarzak_get_many_s_across_r20!(event_ejm, store);
/// assert!(state_yen.iter().find(|&x| **x == state_uwj).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_many_s_across_r20 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_many
        $store
            .iter_acknowledged_event()
            .filter(|a| a.1.event_id == $input.id)
            .map(|a| $store.exhume_state(&a.1.state_id).unwrap())
            .collect::<Vec<&State>>()
    }};
}
pub use sarzak_get_many_s_across_r20;

/// Macro to traverse [`Associative`][ðŸ¦€] âž¡ [`OtherSide`][ðŸ¦ž], via _R22_
///
/// This macro expects a &[`Associative`][ðŸ¦€], and returns a &[`OtherSide`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Associative
/// [ðŸ¦ž]: crate::sarzak::types::OtherSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_r_oth_across_r22;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let wholesale_writer = "cultured_field".to_owned();
/// let obsolete_meal = "rhetorical_snail".to_owned();
/// let alert_wealth = "flagrant_answer".to_owned();
/// let object_tsf = Object::new(&mut store, wholesale_writer, obsolete_meal, alert_wealth);
/// let one_side_uzl = OneSide::new(&mut store, &object_tsf);
/// let obscene_ant = "scarce_bun".to_owned();
/// let rustic_cellar = "soggy_trail".to_owned();
/// let hellish_lace = "garrulous_waste".to_owned();
/// let object_emm = Object::new(&mut store, obscene_ant, rustic_cellar, hellish_lace);
/// let other_side_toq = OtherSide::new(&mut store, &object_emm);
/// let auspicious_prose = "imminent_change".to_owned();
/// let third_snail = "squeamish_ornament".to_owned();
/// let hurt_shame = "jumpy_slip".to_owned();
/// let object_hhw = Object::new(&mut store, auspicious_prose, third_snail, hurt_shame);
/// let associative_side_lwu = AssociativeSide::new(&mut store, &object_hhw);
///
/// let associative = Associative::new(&mut store, &one_side_uzl, &other_side_toq, &associative_side_lwu, 42);
///
/// let other_side_vzi = sarzak_get_one_r_oth_across_r22!(associative, store);
/// assert_eq!(&other_side_toq, other_side_vzi);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_oth_across_r22 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_other_side(&$input.other).unwrap()
    }};
}
pub use sarzak_get_one_r_oth_across_r22;

/// Macro to traverse [`OtherSide`][ðŸ¦€] âž¡ [`Associative`][ðŸ¦ž], via _R22_
///
/// This macro expects a &[`OtherSide`][ðŸ¦€], and returns a &[`Associative`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::OtherSide
/// [ðŸ¦ž]: crate::sarzak::types::Associative
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_r_assoc_across_r22;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let utopian_smile = "smooth_line".to_owned();
/// let shut_transport = "abashed_move".to_owned();
/// let rough_camp = "womanly_cattle".to_owned();
/// let object_pey = Object::new(&mut store, utopian_smile, shut_transport, rough_camp);
/// let one_side_psa = OneSide::new(&mut store, &object_pey);
/// let previous_cracker = "spotted_attraction".to_owned();
/// let poised_income = "unkempt_drop".to_owned();
/// let scared_map = "hysterical_judge".to_owned();
/// let object_qoh = Object::new(&mut store, previous_cracker, poised_income, scared_map);
/// let other_side_jwf = OtherSide::new(&mut store, &object_qoh);
/// let abrasive_lift = "jaded_act".to_owned();
/// let barbarous_frame = "ubiquitous_note".to_owned();
/// let animated_zoo = "violet_mitten".to_owned();
/// let object_bmj = Object::new(&mut store, abrasive_lift, barbarous_frame, animated_zoo);
/// let associative_side_vjq = AssociativeSide::new(&mut store, &object_bmj);
///
/// let associative = Associative::new(&mut store, &one_side_psa, &other_side_jwf, &associative_side_vjq, 42);
/// let associative_jiy = sarzak_get_one_r_assoc_across_r22!(other_side_jwf, store);
///
/// assert_eq!(&associative, associative_jiy);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_assoc_across_r22 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"other_side-associative-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_associative()
            .find(|z| z.1.other == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"other_side-associative-emit_one_unconditional_lookup"}}}
    }};
}
pub use sarzak_get_one_r_assoc_across_r22;

/// Macro to traverse [`Associative`][ðŸ¦€] âž¡ [`OneSide`][ðŸ¦ž], via _R23_
///
/// This macro expects a &[`Associative`][ðŸ¦€], and returns a &[`OneSide`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Associative
/// [ðŸ¦ž]: crate::sarzak::types::OneSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak_get_one_r_one_across_r23;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let berserk_place = "aboard_boat".to_owned();
/// let handsome_sack = "scared_ocean".to_owned();
/// let clever_hair = "rhetorical_stocking".to_owned();
/// let object_iuj = Object::new(&mut store, berserk_place, handsome_sack, clever_hair);
/// let one_side_gwi = OneSide::new(&mut store, &object_iuj);
/// let slow_bridge = "noxious_seat".to_owned();
/// let public_trick = "happy_lace".to_owned();
/// let separate_horn = "disturbed_need".to_owned();
/// let object_qzi = Object::new(&mut store, slow_bridge, public_trick, separate_horn);
/// let other_side_peq = OtherSide::new(&mut store, &object_qzi);
/// let empty_stranger = "marked_zoo".to_owned();
/// let jaded_machine = "snotty_church".to_owned();
/// let uptight_soup = "thankful_pen".to_owned();
/// let object_tqm = Object::new(&mut store, empty_stranger, jaded_machine, uptight_soup);
/// let associative_side_dcy = AssociativeSide::new(&mut store, &object_tqm);
///
/// let associative = Associative::new(&mut store, &one_side_gwi, &other_side_peq, &associative_side_dcy, 42);
///
/// let one_side_pru = sarzak_get_one_r_one_across_r23!(associative, store);
/// assert_eq!(&one_side_gwi, one_side_pru);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_one_across_r23 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_one_side(&$input.one).unwrap()
    }};
}
pub use sarzak_get_one_r_one_across_r23;

/// Macro to traverse [`OneSide`][ðŸ¦€] âž¡ [`Associative`][ðŸ¦ž], via _R23_
///
/// This macro expects a &[`OneSide`][ðŸ¦€], and returns a &[`Associative`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::OneSide
/// [ðŸ¦ž]: crate::sarzak::types::Associative
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak_get_one_r_assoc_across_r23;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let modern_plastic = "efficient_rock".to_owned();
/// let laughable_note = "juvenile_power".to_owned();
/// let feigned_quince = "elastic_amusement".to_owned();
/// let object_wnh = Object::new(&mut store, modern_plastic, laughable_note, feigned_quince);
/// let one_side_vqv = OneSide::new(&mut store, &object_wnh);
/// let staking_snow = "repulsive_volleyball".to_owned();
/// let feeble_answer = "physical_eggnog".to_owned();
/// let talented_bun = "dazzling_orange".to_owned();
/// let object_mxd = Object::new(&mut store, staking_snow, feeble_answer, talented_bun);
/// let other_side_gsi = OtherSide::new(&mut store, &object_mxd);
/// let economic_cheese = "lavish_judge".to_owned();
/// let thin_crow = "spicy_discovery".to_owned();
/// let right_maid = "exciting_kitten".to_owned();
/// let object_bxi = Object::new(&mut store, economic_cheese, thin_crow, right_maid);
/// let associative_side_hso = AssociativeSide::new(&mut store, &object_bxi);
///
/// let associative = Associative::new(&mut store, &one_side_vqv, &other_side_gsi, &associative_side_hso, 42);
/// let associative_org = sarzak_get_one_r_assoc_across_r23!(one_side_vqv, store);
///
/// assert_eq!(&associative, associative_org);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_assoc_across_r23 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"one_side-associative-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_associative()
            .find(|z| z.1.one == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"one_side-associative-emit_one_unconditional_lookup"}}}
    }};
}
pub use sarzak_get_one_r_assoc_across_r23;

/// Macro to traverse [`Supertype`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R14_
///
/// This macro expects a &[`Supertype`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Supertype
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak_get_one_obj_across_r14;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let enormous_flowers = "prickly_soap".to_owned();
/// let magical_cake = "remarkable_brain".to_owned();
/// let merciful_babies = "determined_religion".to_owned();
/// let object_ruu = Object::new(&mut store, enormous_flowers, magical_cake, merciful_babies);
///
/// let supertype = Supertype::new(&mut store, &object_ruu);
///
/// let object_gqq = sarzak_get_one_obj_across_r14!(supertype, store);
/// assert_eq!(&object_ruu, object_gqq);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r14 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r14;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Supertype`][ðŸ¦ž], via _R14(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Supertype`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Supertype
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak_maybe_get_one_r_sup_across_r14;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let aback_comfort = "screeching_clocks".to_owned();
/// let organic_dolls = "tiny_needle".to_owned();
/// let befitting_cloth = "ripe_suit".to_owned();
/// let object_aiq = Object::new(&mut store, aback_comfort, organic_dolls, befitting_cloth);
///
/// let supertype = Supertype::new(&mut store, &object_aiq);
/// let supertype_hko = sarzak_maybe_get_one_r_sup_across_r14!(object_aiq, store);
///
/// assert_eq!(Some(&supertype), supertype_hko);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_sup_across_r14 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-supertype-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_supertype()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-supertype-emit_one_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_one_r_sup_across_r14;

/// Macro to traverse [`Associative`][ðŸ¦€] âž¡ [`AssociativeSide`][ðŸ¦ž], via _R21_
///
/// This macro expects a &[`Associative`][ðŸ¦€], and returns a &[`AssociativeSide`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Associative
/// [ðŸ¦ž]: crate::sarzak::types::AssociativeSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_r_ass_across_r21;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let holistic_cemetery = "light_trade".to_owned();
/// let heartbreaking_pull = "elfin_able".to_owned();
/// let miscreant_net = "vacuous_skate".to_owned();
/// let object_aka = Object::new(&mut store, holistic_cemetery, heartbreaking_pull, miscreant_net);
/// let one_side_ozg = OneSide::new(&mut store, &object_aka);
/// let wistful_father = "cheap_gate".to_owned();
/// let aware_plastic = "illustrious_kitty".to_owned();
/// let mute_balloon = "overrated_cup".to_owned();
/// let object_zdl = Object::new(&mut store, wistful_father, aware_plastic, mute_balloon);
/// let other_side_bfx = OtherSide::new(&mut store, &object_zdl);
/// let frequent_snakes = "magenta_cushion".to_owned();
/// let useless_pin = "repulsive_division".to_owned();
/// let fascinated_cabbage = "vulgar_airport".to_owned();
/// let object_dcz = Object::new(&mut store, frequent_snakes, useless_pin, fascinated_cabbage);
/// let associative_side_dgs = AssociativeSide::new(&mut store, &object_dcz);
///
/// let associative = Associative::new(&mut store, &one_side_ozg, &other_side_bfx, &associative_side_dgs, 42);
///
/// let associative_side_qsf = sarzak_get_one_r_ass_across_r21!(associative, store);
/// assert_eq!(&associative_side_dgs, associative_side_qsf);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_ass_across_r21 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_associative_side(&$input.from).unwrap()
    }};
}
pub use sarzak_get_one_r_ass_across_r21;

/// Macro to traverse [`AssociativeSide`][ðŸ¦€] âž¡ [`Associative`][ðŸ¦ž], via _R21_
///
/// This macro expects a &[`AssociativeSide`][ðŸ¦€], and returns a &[`Associative`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::AssociativeSide
/// [ðŸ¦ž]: crate::sarzak::types::Associative
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak_get_one_r_assoc_across_r21;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let ruthless_throat = "whole_apples".to_owned();
/// let jolly_direction = "historical_calendar".to_owned();
/// let three_swim = "pink_window".to_owned();
/// let object_jvq = Object::new(&mut store, ruthless_throat, jolly_direction, three_swim);
/// let one_side_jcg = OneSide::new(&mut store, &object_jvq);
/// let aboard_creator = "soft_meeting".to_owned();
/// let incredible_point = "literate_ice".to_owned();
/// let ten_cattle = "knotty_country".to_owned();
/// let object_yly = Object::new(&mut store, aboard_creator, incredible_point, ten_cattle);
/// let other_side_ceo = OtherSide::new(&mut store, &object_yly);
/// let obeisant_base = "three_moon".to_owned();
/// let ill_fated_dress = "detailed_hobbies".to_owned();
/// let drab_bedroom = "aback_heart".to_owned();
/// let object_oat = Object::new(&mut store, obeisant_base, ill_fated_dress, drab_bedroom);
/// let associative_side_ctn = AssociativeSide::new(&mut store, &object_oat);
///
/// let associative = Associative::new(&mut store, &one_side_jcg, &other_side_ceo, &associative_side_ctn, 42);
/// let associative_cpp = sarzak_get_one_r_assoc_across_r21!(associative_side_ctn, store);
///
/// assert_eq!(&associative, associative_cpp);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_assoc_across_r21 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"associative_side-associative-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_associative()
            .find(|z| z.1.from == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"associative_side-associative-emit_one_unconditional_lookup"}}}
    }};
}
pub use sarzak_get_one_r_assoc_across_r21;

/// Macro to traverse [`Referrer`][ðŸ¦€] âž¡ [`Cardinality`][ðŸ¦ž], via _R9_
///
/// This macro expects a &[`Referrer`][ðŸ¦€], and returns a &[`Cardinality`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referrer
/// [ðŸ¦ž]: crate::sarzak::types::Cardinality
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak_get_one_card_across_r9;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_bcy = Conditionality::test_default(&mut store);
/// let materialistic_song = "righteous_battle".to_owned();
/// let awful_doctor = "luxuriant_nail".to_owned();
/// let well_off_love = "boorish_regret".to_owned();
/// let object_tjt = Object::new(&mut store, materialistic_song, awful_doctor, well_off_love);
/// let cardinality_yna = Cardinality::test_default(&mut store);
/// let deserted_house = "scandalous_scarecrow".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_bcy, &object_tjt, &cardinality_yna, deserted_house);
///
/// let cardinality_mfj = sarzak_get_one_card_across_r9!(referrer, store);
/// assert_eq!(&cardinality_yna, cardinality_mfj);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_card_across_r9 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_cardinality(&$input.cardinality).unwrap()
    }};
}
pub use sarzak_get_one_card_across_r9;

/// Macro to traverse [`Cardinality`][ðŸ¦€] âž¡ [`Referrer`][ðŸ¦ž], via _R9(c)_
///
/// This macro expects a &[`Cardinality`][ðŸ¦€], and returns an Option<&[`Referrer`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Cardinality
/// [ðŸ¦ž]: crate::sarzak::types::Referrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_many_r_froms_across_r9;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_sor = Conditionality::test_default(&mut store);
/// let temporary_seashore = "daffy_basketball".to_owned();
/// let zany_picture = "brief_tail".to_owned();
/// let wonderful_plant = "noxious_swim".to_owned();
/// let object_mus = Object::new(&mut store, temporary_seashore, zany_picture, wonderful_plant);
/// let cardinality_usg = Cardinality::test_default(&mut store);
/// let wise_space = "angry_twist".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_sor, &object_mus, &cardinality_usg, wise_space);
/// let referrer_fse = sarzak_maybe_get_many_r_froms_across_r9!(cardinality_usg, store);
///
/// assert!(referrer_fse.iter().find(|&x| **x == referrer).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_r_froms_across_r9 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"cardinality-referrer-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referrer()
            .filter_map(|z| if z.1.cardinality == $input.get_id() { Some(z.1) } else { None })
            .collect::<Vec<&Referrer>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"cardinality-referrer-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_r_froms_across_r9;

/// Macro to traverse [`Attribute`][ðŸ¦€] âž¡ [`Type`][ðŸ¦ž], via _R2_
///
/// This macro expects a &[`Attribute`][ðŸ¦€], and returns a &[`Type`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Attribute
/// [ðŸ¦ž]: crate::sarzak::types::Type
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Attribute;
/// # use sarzak::sarzak::Type;
/// # use sarzak::sarzak_get_one_t_across_r2;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let magnificent_name = "lavish_rabbits".to_owned();
/// let statuesque_eyes = "omniscient_thought".to_owned();
/// let light_hose = "addicted_crayon".to_owned();
/// let object = Object::new(&mut store, magnificent_name, statuesque_eyes, light_hose);
/// let type_lkp = Type::test_default(&mut store);
/// let piquant_minister = "guiltless_kettle".to_owned();
///
/// let attribute = Attribute::new(&mut store, Some(&object), &type_lkp, piquant_minister);
///
/// let type_fyy = sarzak_get_one_t_across_r2!(attribute, store);
/// assert_eq!(&type_lkp, type_fyy);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_t_across_r2 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_ty(&$input.ty).unwrap()
    }};
}
pub use sarzak_get_one_t_across_r2;

/// Macro to traverse [`Type`][ðŸ¦€] âž¡ [`Attribute`][ðŸ¦ž], via _R2_
///
/// This macro expects a &[`Type`][ðŸ¦€], and returns a &[`Attribute`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Type
/// [ðŸ¦ž]: crate::sarzak::types::Attribute
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Attribute;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Type;
/// # use sarzak::sarzak_get_one_a_across_r2;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let pumped_plants = "tacit_lizards".to_owned();
/// let psychotic_camp = "stiff_cars".to_owned();
/// let thinkable_bath = "motionless_cord".to_owned();
/// let object = Object::new(&mut store, pumped_plants, psychotic_camp, thinkable_bath);
/// let type_ecl = Type::test_default(&mut store);
/// let symptomatic_guide = "frightened_baby".to_owned();
///
/// let attribute = Attribute::new(&mut store, Some(&object), &type_ecl, symptomatic_guide);
/// let attribute_prz = sarzak_get_one_a_across_r2!(type_ecl, store);
///
/// assert_eq!(&attribute, attribute_prz);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_a_across_r2 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"ty-attribute-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_attribute()
            .find(|z| z.1.ty == $input.get_id())
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"ty-attribute-emit_one_unconditional_lookup"}}}
    }};
}
pub use sarzak_get_one_a_across_r2;

/// Macro to traverse [`Binary`][ðŸ¦€] âž¡ [`Referrer`][ðŸ¦ž], via _R6_
///
/// This macro expects a &[`Binary`][ðŸ¦€], and returns a &[`Referrer`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Binary
/// [ðŸ¦ž]: crate::sarzak::types::Referrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::sarzak_get_one_r_from_across_r6;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_hjv = Conditionality::test_default(&mut store);
/// let gratis_bells = "roomy_grandfather".to_owned();
/// let shaky_grade = "dear_protest".to_owned();
/// let numberless_ray = "dashing_mine".to_owned();
/// let object_znm = Object::new(&mut store, gratis_bells, shaky_grade, numberless_ray);
/// let cardinality_ksb = Cardinality::test_default(&mut store);
/// let referent_aeg = Referent::new(&mut store, &conditionality_hjv, &object_znm, &cardinality_ksb);
/// let conditionality_zzq = Conditionality::test_default(&mut store);
/// let innocent_income = "quack_cook".to_owned();
/// let tidy_ice = "frightened_relation".to_owned();
/// let untidy_arm = "dark_sea".to_owned();
/// let object_jkb = Object::new(&mut store, innocent_income, tidy_ice, untidy_arm);
/// let cardinality_kjz = Cardinality::test_default(&mut store);
/// let brainy_agreement = "aboriginal_farmer".to_owned();
/// let referrer_jlk = Referrer::new(&mut store, &conditionality_zzq, &object_jkb, &cardinality_kjz, brainy_agreement);
///
/// let binary = Binary::new(&mut store, &referent_aeg, &referrer_jlk, 42);
///
/// let referrer_for = sarzak_get_one_r_from_across_r6!(binary, store);
/// assert_eq!(&referrer_jlk, referrer_for);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_from_across_r6 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_referrer(&$input.from).unwrap()
    }};
}
pub use sarzak_get_one_r_from_across_r6;

/// Macro to traverse [`Referrer`][ðŸ¦€] âž¡ [`Binary`][ðŸ¦ž], via _R6_
///
/// This macro expects a &[`Referrer`][ðŸ¦€], and returns a &[`Binary`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referrer
/// [ðŸ¦ž]: crate::sarzak::types::Binary
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Binary;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak_get_one_r_bin_across_r6;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_dmx = Conditionality::test_default(&mut store);
/// let round_range = "curly_frogs".to_owned();
/// let neat_airport = "lackadaisical_game".to_owned();
/// let ill_fated_river = "violent_pig".to_owned();
/// let object_vea = Object::new(&mut store, round_range, neat_airport, ill_fated_river);
/// let cardinality_cbi = Cardinality::test_default(&mut store);
/// let referent_bbp = Referent::new(&mut store, &conditionality_dmx, &object_vea, &cardinality_cbi);
/// let conditionality_mmr = Conditionality::test_default(&mut store);
/// let brainy_adjustment = "billowy_riddle".to_owned();
/// let ruddy_texture = "flippant_desk".to_owned();
/// let wrathful_boat = "bitter_animal".to_owned();
/// let object_rzi = Object::new(&mut store, brainy_adjustment, ruddy_texture, wrathful_boat);
/// let cardinality_rcl = Cardinality::test_default(&mut store);
/// let lumpy_recess = "gabby_street".to_owned();
/// let referrer_rbv = Referrer::new(&mut store, &conditionality_mmr, &object_rzi, &cardinality_rcl, lumpy_recess);
///
/// let binary = Binary::new(&mut store, &referent_bbp, &referrer_rbv, 42);
/// let binary_ykg = sarzak_get_one_r_bin_across_r6!(referrer_rbv, store);
///
/// assert_eq!(&binary, binary_ykg);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_bin_across_r6 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"referrer-binary-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_binary()
            .find(|z| z.1.from == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"referrer-binary-emit_one_unconditional_lookup"}}}
    }};
}
pub use sarzak_get_one_r_bin_across_r6;

/// Macro to traverse [`Event`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R19_
///
/// This macro expects a &[`Event`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Event
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Event;
/// # use sarzak::sarzak_get_one_obj_across_r19;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let light_amount = "evanescent_fire".to_owned();
/// let sharp_cloud = "private_horse".to_owned();
/// let psychotic_tongue = "caring_robin".to_owned();
/// let object_kji = Object::new(&mut store, light_amount, sharp_cloud, psychotic_tongue);
/// let bawdy_office = "glossy_clocks".to_owned();
///
/// let event = Event::new(&mut store, &object_kji, bawdy_office);
///
/// let object_oqf = sarzak_get_one_obj_across_r19!(event, store);
/// assert_eq!(&object_kji, object_oqf);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r19 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r19;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Event`][ðŸ¦ž], via _R19(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Event`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Event
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Event;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_many_es_across_r19;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let abstracted_rail = "hilarious_riddle".to_owned();
/// let medical_zebra = "ritzy_prose".to_owned();
/// let abhorrent_dime = "brown_nation".to_owned();
/// let object_zjm = Object::new(&mut store, abstracted_rail, medical_zebra, abhorrent_dime);
/// let itchy_pleasure = "greasy_meal".to_owned();
///
/// let event = Event::new(&mut store, &object_zjm, itchy_pleasure);
/// let event_dwe = sarzak_maybe_get_many_es_across_r19!(object_zjm, store);
///
/// assert!(event_dwe.iter().find(|&x| **x == event).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_es_across_r19 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-event-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_event()
            .filter_map(|z| if z.1.obj_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&Event>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-event-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_es_across_r19;

/// Macro to traverse [`Attribute`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R1(c)_
///
/// This macro expects a &[`Attribute`][ðŸ¦€], and returns an Option<&[`Object`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Attribute
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Type;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Attribute;
/// # use sarzak::sarzak_maybe_get_one_obj_across_r1;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let heavenly_body = "pricey_crush".to_owned();
/// let ritzy_boat = "sordid_eyes".to_owned();
/// let wasteful_help = "drunk_can".to_owned();
/// let object = Object::new(&mut store, heavenly_body, ritzy_boat, wasteful_help);
/// let type_ffq = Type::test_default(&mut store);
/// let sturdy_creator = "determined_attack".to_owned();
/// let momentous_babies = "handy_interest".to_owned();
/// let colorful_bun = "agonizing_money".to_owned();
/// let lopsided_start = "utter_bedroom".to_owned();
///
/// let attribute = Attribute::new(&mut store, Some(&object), &type_ffq, sturdy_creator);
///
/// let object_rxg = sarzak_maybe_get_one_obj_across_r1!(attribute, store);
/// assert_eq!(Some(&object), object_rxg);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_obj_across_r1 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_conditional
        match &$input.obj_id {
            Some(i) => $store.exhume_object(i),
            None => None,
        }
    }};
}
pub use sarzak_maybe_get_one_obj_across_r1;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Attribute`][ðŸ¦ž], via _R1_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns a &[`Attribute`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Attribute
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Attribute;
/// # use sarzak::sarzak::Type;
/// # use sarzak::sarzak_get_many_as_across_r1;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let hard_rate = "quiet_fire".to_owned();
/// let majestic_hall = "wealthy_thunder".to_owned();
/// let equal_chairs = "freezing_apple".to_owned();
/// let gaudy_building = "muddled_smash".to_owned();
/// let jazzy_cause = "scary_ring".to_owned();
/// let verdant_ladybug = "teeny_plants".to_owned();
/// let object = Object::new(&mut store, gaudy_building, jazzy_cause, verdant_ladybug);
/// let type_ygo = Type::test_default(&mut store);
/// let abortive_nation = "redundant_cushion".to_owned();
///
/// let attribute = Attribute::new(&mut store, Some(&object), &type_ygo, abortive_nation);
///
/// let attribute_xoo = sarzak_get_many_as_across_r1!(object, store);
/// assert!(attribute_xoo.iter().find(|&x| **x == attribute).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_many_as_across_r1 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-attribute-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_attribute()
            .filter_map(|z| if z.1.obj_id == Some($input.id) { Some(z.1) } else { None })
            .collect::<Vec<&Attribute>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-attribute-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_get_many_as_across_r1;

/// Macro to traverse [`Subtype`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R15_
///
/// This macro expects a &[`Subtype`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Subtype
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Subtype;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak_get_one_obj_across_r15;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let disgusted_shoes = "delirious_suggestion".to_owned();
/// let quizzical_knee = "noiseless_root".to_owned();
/// let alike_flag = "imported_arm".to_owned();
/// let object_btf = Object::new(&mut store, disgusted_shoes, quizzical_knee, alike_flag);
/// let supertype_zkz = Supertype::new(&mut store, &object_btf);
/// let isa_mfd = Isa::new(&mut store, &supertype_zkz, 42);
/// let mindless_sister = "fragile_hospital".to_owned();
/// let illustrious_drug = "jazzy_underwear".to_owned();
/// let heavy_earth = "hissing_sneeze".to_owned();
/// let object_ute = Object::new(&mut store, mindless_sister, illustrious_drug, heavy_earth);
///
/// let subtype = Subtype::new(&mut store, &isa_mfd, &object_ute);
///
/// let object_oyy = sarzak_get_one_obj_across_r15!(subtype, store);
/// assert_eq!(&object_ute, object_oyy);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r15 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r15;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Subtype`][ðŸ¦ž], via _R15(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Subtype`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Subtype
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Subtype;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak_maybe_get_one_r_sub_across_r15;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let tricky_letter = "handsomely_cake".to_owned();
/// let absurd_card = "arrogant_friends".to_owned();
/// let tough_drawer = "familiar_beam".to_owned();
/// let object_qga = Object::new(&mut store, tricky_letter, absurd_card, tough_drawer);
/// let supertype_qwl = Supertype::new(&mut store, &object_qga);
/// let isa_paa = Isa::new(&mut store, &supertype_qwl, 42);
/// let milky_drop = "rebel_approval".to_owned();
/// let sturdy_cows = "decisive_event".to_owned();
/// let nauseating_friends = "inquisitive_spring".to_owned();
/// let object_cnx = Object::new(&mut store, milky_drop, sturdy_cows, nauseating_friends);
///
/// let subtype = Subtype::new(&mut store, &isa_paa, &object_cnx);
/// let subtype_uai = sarzak_maybe_get_one_r_sub_across_r15!(object_cnx, store);
///
/// assert_eq!(Some(&subtype), subtype_uai);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_sub_across_r15 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-subtype-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_subtype()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-subtype-emit_one_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_one_r_sub_across_r15;

/// Macro to traverse [`OtherSide`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R25_
///
/// This macro expects a &[`OtherSide`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::OtherSide
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak_get_one_obj_across_r25;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let thoughtless_attempt = "goofy_light".to_owned();
/// let disagreeable_thought = "adhesive_competition".to_owned();
/// let stiff_print = "ancient_increase".to_owned();
/// let object_vdz = Object::new(&mut store, thoughtless_attempt, disagreeable_thought, stiff_print);
///
/// let other_side = OtherSide::new(&mut store, &object_vdz);
///
/// let object_deo = sarzak_get_one_obj_across_r25!(other_side, store);
/// assert_eq!(&object_vdz, object_deo);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r25 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r25;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`OtherSide`][ðŸ¦ž], via _R25(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`OtherSide`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::OtherSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_one_r_oth_across_r25;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let parsimonious_able = "tremendous_winter".to_owned();
/// let ill_riddle = "sweet_apples".to_owned();
/// let perfect_wrench = "slow_value".to_owned();
/// let object_igb = Object::new(&mut store, parsimonious_able, ill_riddle, perfect_wrench);
///
/// let other_side = OtherSide::new(&mut store, &object_igb);
/// let other_side_bvs = sarzak_maybe_get_one_r_oth_across_r25!(object_igb, store);
///
/// assert_eq!(Some(&other_side), other_side_bvs);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_oth_across_r25 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-other_side-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_other_side()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-other_side-emit_one_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_one_r_oth_across_r25;

/// Macro to traverse [`Binary`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R5_
///
/// This macro expects a &[`Binary`][ðŸ¦€], and returns a &[`Referent`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Binary
/// [ðŸ¦ž]: crate::sarzak::types::Referent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak_get_one_r_to_across_r5;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_tqk = Conditionality::test_default(&mut store);
/// let tricky_plantation = "icy_taste".to_owned();
/// let broad_camera = "loutish_range".to_owned();
/// let diligent_snow = "optimal_sense".to_owned();
/// let object_xve = Object::new(&mut store, tricky_plantation, broad_camera, diligent_snow);
/// let cardinality_ifg = Cardinality::test_default(&mut store);
/// let referent_buz = Referent::new(&mut store, &conditionality_tqk, &object_xve, &cardinality_ifg);
/// let conditionality_wga = Conditionality::test_default(&mut store);
/// let dapper_letters = "chivalrous_celery".to_owned();
/// let animated_limit = "thin_direction".to_owned();
/// let pleasant_attempt = "aboard_touch".to_owned();
/// let object_qbw = Object::new(&mut store, dapper_letters, animated_limit, pleasant_attempt);
/// let cardinality_eim = Cardinality::test_default(&mut store);
/// let thoughtful_pain = "immense_mark".to_owned();
/// let referrer_bbt = Referrer::new(&mut store, &conditionality_wga, &object_qbw, &cardinality_eim, thoughtful_pain);
///
/// let binary = Binary::new(&mut store, &referent_buz, &referrer_bbt, 42);
///
/// let referent_uke = sarzak_get_one_r_to_across_r5!(binary, store);
/// assert_eq!(&referent_buz, referent_uke);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_to_across_r5 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_referent(&$input.to).unwrap()
    }};
}
pub use sarzak_get_one_r_to_across_r5;

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`Binary`][ðŸ¦ž], via _R5_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`Binary`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referent
/// [ðŸ¦ž]: crate::sarzak::types::Binary
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak_get_one_r_bin_across_r5;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_uwi = Conditionality::test_default(&mut store);
/// let ten_fuel = "picayune_river".to_owned();
/// let habitual_board = "fascinated_bubble".to_owned();
/// let young_hour = "teeny_tiny_fowl".to_owned();
/// let object_pds = Object::new(&mut store, ten_fuel, habitual_board, young_hour);
/// let cardinality_yok = Cardinality::test_default(&mut store);
/// let referent_sdj = Referent::new(&mut store, &conditionality_uwi, &object_pds, &cardinality_yok);
/// let conditionality_lqa = Conditionality::test_default(&mut store);
/// let clumsy_bikes = "naive_stove".to_owned();
/// let satisfying_space = "selective_creature".to_owned();
/// let precious_trick = "amuck_sand".to_owned();
/// let object_bzl = Object::new(&mut store, clumsy_bikes, satisfying_space, precious_trick);
/// let cardinality_mxt = Cardinality::test_default(&mut store);
/// let uninterested_river = "descriptive_trousers".to_owned();
/// let referrer_ipx = Referrer::new(&mut store, &conditionality_lqa, &object_bzl, &cardinality_mxt, uninterested_river);
///
/// let binary = Binary::new(&mut store, &referent_sdj, &referrer_ipx, 42);
/// let binary_ecp = sarzak_get_one_r_bin_across_r5!(referent_sdj, store);
///
/// assert_eq!(&binary, binary_ecp);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_bin_across_r5 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"referent-binary-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_binary()
            .find(|z| z.1.to == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"referent-binary-emit_one_unconditional_lookup"}}}
    }};
}
pub use sarzak_get_one_r_bin_across_r5;
