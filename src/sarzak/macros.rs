//! Macros for navigating the "Sarzak" domain
//!
//! # Generated Code -- edit _with care_.
//!
//! Don't mess with anything between `{"magic":"îž¨","kind":"CriticalBlockBegin"}`
//! and `{"magic":"îž¨","kind":"CriticalBlockEnd"}`. Otherwise, you should be free
//! to go wild. Happy hacking!
//!
//! Use the following invocation to reproduce:
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
//! ```shell
//!  sarzak gen sarzak -i true -m true -d true -e true
//! ```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
// {"magic":"îž¨","version":"0.5.0"}

/// Macro to traverse [`Referrer`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R17_
///
/// This macro expects a &[`Referrer`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referrer
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak_get_one_obj_across_r17;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_nvq = Conditionality::test_default(&mut store);
/// let neat_trouble = "scarce_feast".to_owned();
/// let exciting_hydrant = "gusty_trees".to_owned();
/// let object_zbe = Object::new(&mut store, neat_trouble, exciting_hydrant);
/// let cardinality_jeg = Cardinality::test_default(&mut store);
/// let juvenile_weight = "striped_ice".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_nvq, &object_zbe, &cardinality_jeg, juvenile_weight);
///
/// let object_nom = sarzak_get_one_obj_across_r17!(referrer, store);
/// assert_eq!(&object_zbe, object_nom);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r17 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r17;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Referrer`][ðŸ¦ž], via _R17(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Referrer`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Referrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak_maybe_get_one_r_from_across_r17;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_jxn = Conditionality::test_default(&mut store);
/// let black_nation = "exultant_airport".to_owned();
/// let abortive_look = "adhesive_word".to_owned();
/// let object_vwr = Object::new(&mut store, black_nation, abortive_look);
/// let cardinality_pot = Cardinality::test_default(&mut store);
/// let damaged_route = "grieving_picture".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_jxn, &object_vwr, &cardinality_pot, damaged_route);
/// let referrer_akr = sarzak_maybe_get_one_r_from_across_r17!(object_vwr, store);
///
/// assert_eq!(Some(&referrer), referrer_akr);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_from_across_r17 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-referrer-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_referrer()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-referrer-emit_one_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_one_r_from_across_r17;

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`Cardinality`][ðŸ¦ž], via _R8_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`Cardinality`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referent
/// [ðŸ¦ž]: crate::sarzak::types::Cardinality
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak_get_one_card_across_r8;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_xnh = Conditionality::test_default(&mut store);
/// let nonstop_tank = "psychedelic_galley".to_owned();
/// let milky_shock = "boorish_reading".to_owned();
/// let object_vrh = Object::new(&mut store, nonstop_tank, milky_shock);
/// let cardinality_bvl = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_xnh, &object_vrh, &cardinality_bvl);
///
/// let cardinality_jio = sarzak_get_one_card_across_r8!(referent, store);
/// assert_eq!(&cardinality_bvl, cardinality_jio);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_card_across_r8 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_cardinality(&$input.cardinality).unwrap()
    }};
}
pub use sarzak_get_one_card_across_r8;

/// Macro to traverse [`Cardinality`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R8(c)_
///
/// This macro expects a &[`Cardinality`][ðŸ¦€], and returns an Option<&[`Referent`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Cardinality
/// [ðŸ¦ž]: crate::sarzak::types::Referent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak_maybe_get_many_r_tos_across_r8;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_vyf = Conditionality::test_default(&mut store);
/// let uttermost_hose = "marvelous_maid".to_owned();
/// let poised_birth = "heady_teeth".to_owned();
/// let object_efz = Object::new(&mut store, uttermost_hose, poised_birth);
/// let cardinality_bmu = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_vyf, &object_efz, &cardinality_bmu);
/// let referent_szl = sarzak_maybe_get_many_r_tos_across_r8!(cardinality_bmu, store);
///
/// assert!(referent_szl.iter().find(|&x| **x == referent).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_r_tos_across_r8 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"cardinality-referent-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referent()
            .filter_map(|z| if z.1.cardinality == $input.get_id() { Some(z.1) } else { None })
            .collect::<Vec<&Referent>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"cardinality-referent-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_r_tos_across_r8;

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R16_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referent
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r16;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_twp = Conditionality::test_default(&mut store);
/// let temporary_clam = "stupendous_quilt".to_owned();
/// let dazzling_society = "pretty_carpenter".to_owned();
/// let object_fyy = Object::new(&mut store, temporary_clam, dazzling_society);
/// let cardinality_avq = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_twp, &object_fyy, &cardinality_avq);
///
/// let object_kwk = sarzak_get_one_obj_across_r16!(referent, store);
/// assert_eq!(&object_fyy, object_kwk);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r16 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r16;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R16(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Referent`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Referent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak_maybe_get_one_r_to_across_r16;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_hky = Conditionality::test_default(&mut store);
/// let obedient_skate = "late_cry".to_owned();
/// let amazing_behavior = "milky_attention".to_owned();
/// let object_mzk = Object::new(&mut store, obedient_skate, amazing_behavior);
/// let cardinality_dsu = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_hky, &object_mzk, &cardinality_dsu);
/// let referent_eav = sarzak_maybe_get_one_r_to_across_r16!(object_mzk, store);
///
/// assert_eq!(Some(&referent), referent_eav);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_to_across_r16 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-referent-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_referent()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-referent-emit_one_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_one_r_to_across_r16;

/// Macro to traverse [`OneSide`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R24_
///
/// This macro expects a &[`OneSide`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::OneSide
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak_get_one_obj_across_r24;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let alleged_pear = "barbarous_toothpaste".to_owned();
/// let maniacal_song = "decisive_leaf".to_owned();
/// let object_zma = Object::new(&mut store, alleged_pear, maniacal_song);
///
/// let one_side = OneSide::new(&mut store, &object_zma);
///
/// let object_qwc = sarzak_get_one_obj_across_r24!(one_side, store);
/// assert_eq!(&object_zma, object_qwc);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r24 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r24;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`OneSide`][ðŸ¦ž], via _R24(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`OneSide`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::OneSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_one_r_one_across_r24;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let boorish_band = "drab_garden".to_owned();
/// let brash_cushion = "deadpan_school".to_owned();
/// let object_enh = Object::new(&mut store, boorish_band, brash_cushion);
///
/// let one_side = OneSide::new(&mut store, &object_enh);
/// let one_side_uep = sarzak_maybe_get_one_r_one_across_r24!(object_enh, store);
///
/// assert_eq!(Some(&one_side), one_side_uep);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_one_across_r24 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-one_side-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_one_side()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-one_side-emit_one_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_one_r_one_across_r24;

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`Conditionality`][ðŸ¦ž], via _R12_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`Conditionality`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referent
/// [ðŸ¦ž]: crate::sarzak::types::Conditionality
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_cond_across_r12;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_wxw = Conditionality::test_default(&mut store);
/// let spiteful_cook = "fancy_iron".to_owned();
/// let honorable_scene = "puffy_distance".to_owned();
/// let object_ang = Object::new(&mut store, spiteful_cook, honorable_scene);
/// let cardinality_dwa = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_wxw, &object_ang, &cardinality_dwa);
///
/// let conditionality_mrj = sarzak_get_one_cond_across_r12!(referent, store);
/// assert_eq!(&conditionality_wxw, conditionality_mrj);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_cond_across_r12 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store
            .exhume_conditionality(&$input.conditionality)
            .unwrap()
    }};
}
pub use sarzak_get_one_cond_across_r12;

/// Macro to traverse [`Conditionality`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R12(c)_
///
/// This macro expects a &[`Conditionality`][ðŸ¦€], and returns an Option<&[`Referent`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Conditionality
/// [ðŸ¦ž]: crate::sarzak::types::Referent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_many_r_tos_across_r12;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_xdk = Conditionality::test_default(&mut store);
/// let inexpensive_flame = "purring_earth".to_owned();
/// let tranquil_notebook = "majestic_position".to_owned();
/// let object_dcr = Object::new(&mut store, inexpensive_flame, tranquil_notebook);
/// let cardinality_ceq = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_xdk, &object_dcr, &cardinality_ceq);
/// let referent_gcx = sarzak_maybe_get_many_r_tos_across_r12!(conditionality_xdk, store);
///
/// assert!(referent_gcx.iter().find(|&x| **x == referent).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_r_tos_across_r12 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"conditionality-referent-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referent()
            .filter_map(|z| if z.1.conditionality == $input.get_id() { Some(z.1) } else { None })
            .collect::<Vec<&Referent>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"conditionality-referent-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_r_tos_across_r12;

/// Macro to traverse [`AssociativeSide`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R26_
///
/// This macro expects a &[`AssociativeSide`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::AssociativeSide
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r26;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let graceful_powder = "mighty_passenger".to_owned();
/// let handsomely_riddle = "imaginary_twist".to_owned();
/// let object_npf = Object::new(&mut store, graceful_powder, handsomely_riddle);
///
/// let associative_side = AssociativeSide::new(&mut store, &object_npf);
///
/// let object_zze = sarzak_get_one_obj_across_r26!(associative_side, store);
/// assert_eq!(&object_npf, object_zze);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r26 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r26;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`AssociativeSide`][ðŸ¦ž], via _R26(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`AssociativeSide`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::AssociativeSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak_maybe_get_one_r_ass_across_r26;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let brainy_pull = "windy_heart".to_owned();
/// let abstracted_sister = "acidic_father".to_owned();
/// let object_cnv = Object::new(&mut store, brainy_pull, abstracted_sister);
///
/// let associative_side = AssociativeSide::new(&mut store, &object_cnv);
/// let associative_side_utf = sarzak_maybe_get_one_r_ass_across_r26!(object_cnv, store);
///
/// assert_eq!(Some(&associative_side), associative_side_utf);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_ass_across_r26 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-associative_side-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_side()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-associative_side-emit_one_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_one_r_ass_across_r26;

/// Macro to traverse [`Referrer`][ðŸ¦€] âž¡ [`Conditionality`][ðŸ¦ž], via _R11_
///
/// This macro expects a &[`Referrer`][ðŸ¦€], and returns a &[`Conditionality`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referrer
/// [ðŸ¦ž]: crate::sarzak::types::Conditionality
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak_get_one_cond_across_r11;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_tco = Conditionality::test_default(&mut store);
/// let plain_father = "warm_suggestion".to_owned();
/// let present_teeth = "willing_color".to_owned();
/// let object_wvh = Object::new(&mut store, plain_father, present_teeth);
/// let cardinality_jlp = Cardinality::test_default(&mut store);
/// let harmonious_sea = "craven_lunch".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_tco, &object_wvh, &cardinality_jlp, harmonious_sea);
///
/// let conditionality_qya = sarzak_get_one_cond_across_r11!(referrer, store);
/// assert_eq!(&conditionality_tco, conditionality_qya);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_cond_across_r11 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store
            .exhume_conditionality(&$input.conditionality)
            .unwrap()
    }};
}
pub use sarzak_get_one_cond_across_r11;

/// Macro to traverse [`Conditionality`][ðŸ¦€] âž¡ [`Referrer`][ðŸ¦ž], via _R11(c)_
///
/// This macro expects a &[`Conditionality`][ðŸ¦€], and returns an Option<&[`Referrer`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Conditionality
/// [ðŸ¦ž]: crate::sarzak::types::Referrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak_maybe_get_many_r_froms_across_r11;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_few = Conditionality::test_default(&mut store);
/// let homeless_wish = "hellish_flight".to_owned();
/// let erect_oven = "excellent_stew".to_owned();
/// let object_vla = Object::new(&mut store, homeless_wish, erect_oven);
/// let cardinality_ajh = Cardinality::test_default(&mut store);
/// let three_cows = "spiky_carriage".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_few, &object_vla, &cardinality_ajh, three_cows);
/// let referrer_mmn = sarzak_maybe_get_many_r_froms_across_r11!(conditionality_few, store);
///
/// assert!(referrer_mmn.iter().find(|&x| **x == referrer).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_r_froms_across_r11 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"conditionality-referrer-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referrer()
            .filter_map(|z| if z.1.conditionality == $input.get_id() { Some(z.1) } else { None })
            .collect::<Vec<&Referrer>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"conditionality-referrer-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_r_froms_across_r11;

/// Macro to traverse [`State`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R18_
///
/// This macro expects a &[`State`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::State
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::State;
/// # use sarzak::sarzak_get_one_obj_across_r18;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let chubby_wealth = "zesty_crack".to_owned();
/// let parsimonious_ants = "dirty_peace".to_owned();
/// let object_ths = Object::new(&mut store, chubby_wealth, parsimonious_ants);
/// let stale_nest = "burly_oatmeal".to_owned();
///
/// let state = State::new(&mut store, &object_ths, stale_nest);
///
/// let object_zyr = sarzak_get_one_obj_across_r18!(state, store);
/// assert_eq!(&object_ths, object_zyr);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r18 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r18;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`State`][ðŸ¦ž], via _R18(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`State`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::State
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::State;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_many_ss_across_r18;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let amuck_zinc = "married_mother".to_owned();
/// let auspicious_stone = "racial_tin".to_owned();
/// let object_mts = Object::new(&mut store, amuck_zinc, auspicious_stone);
/// let trashy_paper = "mammoth_trail".to_owned();
///
/// let state = State::new(&mut store, &object_mts, trashy_paper);
/// let state_ivd = sarzak_maybe_get_many_ss_across_r18!(object_mts, store);
///
/// assert!(state_ivd.iter().find(|&x| **x == state).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_ss_across_r18 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-state-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_state()
            .filter_map(|z| if z.1.obj_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&State>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-state-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_ss_across_r18;

/// Macro to traverse [`State`][ðŸ¦€] âž¡ [`Event`][ðŸ¦ž], across [`AcknowledgedEvent`][ðŸ¦‘] via _R20_
///
/// This macro expects a &[`State`][ðŸ¦€], and returns a &[`Event`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ðŸ¦€]: crate::sarzak::types::State
/// [ðŸ¦ž]: crate::sarzak::types::Event
/// [ðŸ¦‘]: crate::sarzak::types::AcknowledgedEvent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Event;
/// # use sarzak::sarzak::AcknowledgedEvent;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::State;
/// # use sarzak::sarzak_get_many_e_across_r20;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let equal_moon = "unequal_church".to_owned();
/// let husky_apple = "perfect_milk".to_owned();
/// let object_vdr = Object::new(&mut store, equal_moon, husky_apple);
/// let cooing_rock = "cagey_form".to_owned();
/// let state_qxl = State::new(&mut store, &object_vdr, cooing_rock);
/// let messy_hydrant = "actually_group".to_owned();
/// let violet_curtain = "overt_trip".to_owned();
/// let object_iqq = Object::new(&mut store, messy_hydrant, violet_curtain);
/// let threatening_daughter = "broad_theory".to_owned();
/// let event_qee = Event::new(&mut store, &object_iqq, threatening_daughter);
/// let acknowledged_event = AcknowledgedEvent::new(&mut store, &state_qxl, &event_qee);
///
/// let event_iwo = sarzak_get_many_e_across_r20!(state_qxl, store);
/// assert!(event_iwo.iter().find(|&x| **x == event_qee).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_many_e_across_r20 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_many
        $store
            .iter_acknowledged_event()
            .filter(|a| a.1.state_id == $input.id)
            .map(|a| $store.exhume_event(&a.1.event_id).unwrap())
            .collect::<Vec<&Event>>()
    }};
}
pub use sarzak_get_many_e_across_r20;

/// Macro to traverse [`Event`][ðŸ¦€] âž¡ [`State`][ðŸ¦ž], across [`AcknowledgedEvent`][ðŸ¦‘] via _R20_
///
/// This macro expects a &[`Event`][ðŸ¦€], and returns a &[`State`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ðŸ¦€]: crate::sarzak::types::Event
/// [ðŸ¦ž]: crate::sarzak::types::State
/// [ðŸ¦‘]: crate::sarzak::types::AcknowledgedEvent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::AcknowledgedEvent;
/// # use sarzak::sarzak::Event;
/// # use sarzak::sarzak::State;
/// # use sarzak::sarzak_get_many_s_across_r20;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let striped_children = "unhealthy_engine".to_owned();
/// let daily_beggar = "dispensable_trousers".to_owned();
/// let object_psm = Object::new(&mut store, striped_children, daily_beggar);
/// let robust_grape = "polite_orange".to_owned();
/// let state_lpz = State::new(&mut store, &object_psm, robust_grape);
/// let abundant_idea = "finicky_gun".to_owned();
/// let willing_approval = "omniscient_pocket".to_owned();
/// let object_ctj = Object::new(&mut store, abundant_idea, willing_approval);
/// let therapeutic_match = "infamous_body".to_owned();
/// let event_jzf = Event::new(&mut store, &object_ctj, therapeutic_match);
/// let acknowledged_event = AcknowledgedEvent::new(&mut store, &state_lpz, &event_jzf);
///
/// let state_zct = sarzak_get_many_s_across_r20!(event_jzf, store);
/// assert!(state_zct.iter().find(|&x| **x == state_lpz).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_many_s_across_r20 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_many
        $store
            .iter_acknowledged_event()
            .filter(|a| a.1.event_id == $input.id)
            .map(|a| $store.exhume_state(&a.1.state_id).unwrap())
            .collect::<Vec<&State>>()
    }};
}
pub use sarzak_get_many_s_across_r20;

/// Macro to traverse [`Associative`][ðŸ¦€] âž¡ [`OtherSide`][ðŸ¦ž], via _R22_
///
/// This macro expects a &[`Associative`][ðŸ¦€], and returns a &[`OtherSide`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Associative
/// [ðŸ¦ž]: crate::sarzak::types::OtherSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak_get_one_r_oth_across_r22;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let large_ornament = "heavy_way".to_owned();
/// let snobbish_detail = "flagrant_basin".to_owned();
/// let object_ldm = Object::new(&mut store, large_ornament, snobbish_detail);
/// let one_side_dzc = OneSide::new(&mut store, &object_ldm);
/// let loutish_instrument = "nebulous_music".to_owned();
/// let befitting_hope = "spotty_page".to_owned();
/// let object_nmh = Object::new(&mut store, loutish_instrument, befitting_hope);
/// let other_side_tie = OtherSide::new(&mut store, &object_nmh);
/// let macabre_dinosaurs = "humdrum_help".to_owned();
/// let giddy_bite = "diligent_whistle".to_owned();
/// let object_ttv = Object::new(&mut store, macabre_dinosaurs, giddy_bite);
/// let associative_side_tvi = AssociativeSide::new(&mut store, &object_ttv);
///
/// let associative = Associative::new(&mut store, &one_side_dzc, &other_side_tie, &associative_side_tvi, 42);
///
/// let other_side_rai = sarzak_get_one_r_oth_across_r22!(associative, store);
/// assert_eq!(&other_side_tie, other_side_rai);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_oth_across_r22 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_other_side(&$input.other).unwrap()
    }};
}
pub use sarzak_get_one_r_oth_across_r22;

/// Macro to traverse [`OtherSide`][ðŸ¦€] âž¡ [`Associative`][ðŸ¦ž], via _R22_
///
/// This macro expects a &[`OtherSide`][ðŸ¦€], and returns a &[`Associative`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::OtherSide
/// [ðŸ¦ž]: crate::sarzak::types::Associative
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak_get_one_r_assoc_across_r22;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let ragged_team = "subdued_rings".to_owned();
/// let adorable_steel = "overconfident_jump".to_owned();
/// let object_ppz = Object::new(&mut store, ragged_team, adorable_steel);
/// let one_side_isr = OneSide::new(&mut store, &object_ppz);
/// let tasteful_flight = "quack_appliance".to_owned();
/// let cooperative_prison = "broad_pies".to_owned();
/// let object_rnn = Object::new(&mut store, tasteful_flight, cooperative_prison);
/// let other_side_mgx = OtherSide::new(&mut store, &object_rnn);
/// let eight_lizards = "normal_cannon".to_owned();
/// let lamentable_bun = "high_pitched_geese".to_owned();
/// let object_jey = Object::new(&mut store, eight_lizards, lamentable_bun);
/// let associative_side_sfx = AssociativeSide::new(&mut store, &object_jey);
///
/// let associative = Associative::new(&mut store, &one_side_isr, &other_side_mgx, &associative_side_sfx, 42);
/// let associative_bzb = sarzak_get_one_r_assoc_across_r22!(other_side_mgx, store);
///
/// assert_eq!(&associative, associative_bzb);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_assoc_across_r22 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"other_side-associative-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_associative()
            .find(|z| z.1.other == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"other_side-associative-emit_one_unconditional_lookup"}}}
    }};
}
pub use sarzak_get_one_r_assoc_across_r22;

/// Macro to traverse [`Associative`][ðŸ¦€] âž¡ [`OneSide`][ðŸ¦ž], via _R23_
///
/// This macro expects a &[`Associative`][ðŸ¦€], and returns a &[`OneSide`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Associative
/// [ðŸ¦ž]: crate::sarzak::types::OneSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_r_one_across_r23;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let drunk_lamp = "dreary_structure".to_owned();
/// let colossal_mother = "nutty_volcano".to_owned();
/// let object_kjj = Object::new(&mut store, drunk_lamp, colossal_mother);
/// let one_side_lkv = OneSide::new(&mut store, &object_kjj);
/// let magenta_camp = "average_wish".to_owned();
/// let parsimonious_attempt = "cloistered_minute".to_owned();
/// let object_hdo = Object::new(&mut store, magenta_camp, parsimonious_attempt);
/// let other_side_ocz = OtherSide::new(&mut store, &object_hdo);
/// let real_angle = "broken_attack".to_owned();
/// let tough_lizards = "zippy_note".to_owned();
/// let object_exv = Object::new(&mut store, real_angle, tough_lizards);
/// let associative_side_lft = AssociativeSide::new(&mut store, &object_exv);
///
/// let associative = Associative::new(&mut store, &one_side_lkv, &other_side_ocz, &associative_side_lft, 42);
///
/// let one_side_wiv = sarzak_get_one_r_one_across_r23!(associative, store);
/// assert_eq!(&one_side_lkv, one_side_wiv);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_one_across_r23 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_one_side(&$input.one).unwrap()
    }};
}
pub use sarzak_get_one_r_one_across_r23;

/// Macro to traverse [`OneSide`][ðŸ¦€] âž¡ [`Associative`][ðŸ¦ž], via _R23_
///
/// This macro expects a &[`OneSide`][ðŸ¦€], and returns a &[`Associative`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::OneSide
/// [ðŸ¦ž]: crate::sarzak::types::Associative
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_r_assoc_across_r23;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let irate_boat = "direful_spiders".to_owned();
/// let brash_pickle = "obedient_quartz".to_owned();
/// let object_zhw = Object::new(&mut store, irate_boat, brash_pickle);
/// let one_side_hrf = OneSide::new(&mut store, &object_zhw);
/// let ignorant_son = "itchy_texture".to_owned();
/// let cowardly_tramp = "obsequious_jail".to_owned();
/// let object_xti = Object::new(&mut store, ignorant_son, cowardly_tramp);
/// let other_side_spw = OtherSide::new(&mut store, &object_xti);
/// let spiffy_trees = "ill_bubble".to_owned();
/// let periodic_cherries = "abundant_trousers".to_owned();
/// let object_acb = Object::new(&mut store, spiffy_trees, periodic_cherries);
/// let associative_side_ucp = AssociativeSide::new(&mut store, &object_acb);
///
/// let associative = Associative::new(&mut store, &one_side_hrf, &other_side_spw, &associative_side_ucp, 42);
/// let associative_xoy = sarzak_get_one_r_assoc_across_r23!(one_side_hrf, store);
///
/// assert_eq!(&associative, associative_xoy);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_assoc_across_r23 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"one_side-associative-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_associative()
            .find(|z| z.1.one == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"one_side-associative-emit_one_unconditional_lookup"}}}
    }};
}
pub use sarzak_get_one_r_assoc_across_r23;

/// Macro to traverse [`Supertype`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R14_
///
/// This macro expects a &[`Supertype`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Supertype
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak_get_one_obj_across_r14;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let silent_hand = "bewildered_approval".to_owned();
/// let pink_heart = "staking_brick".to_owned();
/// let object_ecn = Object::new(&mut store, silent_hand, pink_heart);
///
/// let supertype = Supertype::new(&mut store, &object_ecn);
///
/// let object_opb = sarzak_get_one_obj_across_r14!(supertype, store);
/// assert_eq!(&object_ecn, object_opb);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r14 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r14;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Supertype`][ðŸ¦ž], via _R14(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Supertype`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Supertype
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak_maybe_get_one_r_sup_across_r14;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let ajar_hobbies = "tearful_division".to_owned();
/// let succinct_competition = "open_whip".to_owned();
/// let object_tee = Object::new(&mut store, ajar_hobbies, succinct_competition);
///
/// let supertype = Supertype::new(&mut store, &object_tee);
/// let supertype_fzc = sarzak_maybe_get_one_r_sup_across_r14!(object_tee, store);
///
/// assert_eq!(Some(&supertype), supertype_fzc);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_sup_across_r14 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-supertype-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_supertype()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-supertype-emit_one_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_one_r_sup_across_r14;

/// Macro to traverse [`Associative`][ðŸ¦€] âž¡ [`AssociativeSide`][ðŸ¦ž], via _R21_
///
/// This macro expects a &[`Associative`][ðŸ¦€], and returns a &[`AssociativeSide`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Associative
/// [ðŸ¦ž]: crate::sarzak::types::AssociativeSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_r_ass_across_r21;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let better_guitar = "illustrious_rainstorm".to_owned();
/// let unwritten_shake = "panoramic_weather".to_owned();
/// let object_vge = Object::new(&mut store, better_guitar, unwritten_shake);
/// let one_side_wqv = OneSide::new(&mut store, &object_vge);
/// let hot_error = "imaginary_brush".to_owned();
/// let stupendous_guide = "phobic_stew".to_owned();
/// let object_iwx = Object::new(&mut store, hot_error, stupendous_guide);
/// let other_side_imq = OtherSide::new(&mut store, &object_iwx);
/// let threatening_desire = "domineering_governor".to_owned();
/// let public_breath = "expensive_action".to_owned();
/// let object_ddm = Object::new(&mut store, threatening_desire, public_breath);
/// let associative_side_zuf = AssociativeSide::new(&mut store, &object_ddm);
///
/// let associative = Associative::new(&mut store, &one_side_wqv, &other_side_imq, &associative_side_zuf, 42);
///
/// let associative_side_qdu = sarzak_get_one_r_ass_across_r21!(associative, store);
/// assert_eq!(&associative_side_zuf, associative_side_qdu);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_ass_across_r21 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_associative_side(&$input.from).unwrap()
    }};
}
pub use sarzak_get_one_r_ass_across_r21;

/// Macro to traverse [`AssociativeSide`][ðŸ¦€] âž¡ [`Associative`][ðŸ¦ž], via _R21_
///
/// This macro expects a &[`AssociativeSide`][ðŸ¦€], and returns a &[`Associative`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::AssociativeSide
/// [ðŸ¦ž]: crate::sarzak::types::Associative
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak_get_one_r_assoc_across_r21;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let few_fire = "nosy_mountain".to_owned();
/// let unnatural_skate = "ragged_laugh".to_owned();
/// let object_rzv = Object::new(&mut store, few_fire, unnatural_skate);
/// let one_side_rcg = OneSide::new(&mut store, &object_rzv);
/// let neat_bear = "helpful_beggar".to_owned();
/// let receptive_bird = "frantic_stone".to_owned();
/// let object_qbc = Object::new(&mut store, neat_bear, receptive_bird);
/// let other_side_fos = OtherSide::new(&mut store, &object_qbc);
/// let greedy_kettle = "heady_event".to_owned();
/// let damaged_observation = "thoughtless_fight".to_owned();
/// let object_fho = Object::new(&mut store, greedy_kettle, damaged_observation);
/// let associative_side_dsl = AssociativeSide::new(&mut store, &object_fho);
///
/// let associative = Associative::new(&mut store, &one_side_rcg, &other_side_fos, &associative_side_dsl, 42);
/// let associative_xrt = sarzak_get_one_r_assoc_across_r21!(associative_side_dsl, store);
///
/// assert_eq!(&associative, associative_xrt);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_assoc_across_r21 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"associative_side-associative-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_associative()
            .find(|z| z.1.from == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"associative_side-associative-emit_one_unconditional_lookup"}}}
    }};
}
pub use sarzak_get_one_r_assoc_across_r21;

/// Macro to traverse [`Referrer`][ðŸ¦€] âž¡ [`Cardinality`][ðŸ¦ž], via _R9_
///
/// This macro expects a &[`Referrer`][ðŸ¦€], and returns a &[`Cardinality`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referrer
/// [ðŸ¦ž]: crate::sarzak::types::Cardinality
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak_get_one_card_across_r9;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_kwt = Conditionality::test_default(&mut store);
/// let puffy_ant = "debonair_comb".to_owned();
/// let demonic_cream = "terrible_things".to_owned();
/// let object_atr = Object::new(&mut store, puffy_ant, demonic_cream);
/// let cardinality_vsn = Cardinality::test_default(&mut store);
/// let cuddly_airport = "spotty_spoon".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_kwt, &object_atr, &cardinality_vsn, cuddly_airport);
///
/// let cardinality_bxt = sarzak_get_one_card_across_r9!(referrer, store);
/// assert_eq!(&cardinality_vsn, cardinality_bxt);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_card_across_r9 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_cardinality(&$input.cardinality).unwrap()
    }};
}
pub use sarzak_get_one_card_across_r9;

/// Macro to traverse [`Cardinality`][ðŸ¦€] âž¡ [`Referrer`][ðŸ¦ž], via _R9(c)_
///
/// This macro expects a &[`Cardinality`][ðŸ¦€], and returns an Option<&[`Referrer`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Cardinality
/// [ðŸ¦ž]: crate::sarzak::types::Referrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_many_r_froms_across_r9;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_bwu = Conditionality::test_default(&mut store);
/// let quaint_death = "dead_believe".to_owned();
/// let bashful_payment = "spiteful_man".to_owned();
/// let object_wnw = Object::new(&mut store, quaint_death, bashful_payment);
/// let cardinality_qvw = Cardinality::test_default(&mut store);
/// let whimsical_skin = "elated_boundary".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_bwu, &object_wnw, &cardinality_qvw, whimsical_skin);
/// let referrer_dwf = sarzak_maybe_get_many_r_froms_across_r9!(cardinality_qvw, store);
///
/// assert!(referrer_dwf.iter().find(|&x| **x == referrer).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_r_froms_across_r9 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"cardinality-referrer-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referrer()
            .filter_map(|z| if z.1.cardinality == $input.get_id() { Some(z.1) } else { None })
            .collect::<Vec<&Referrer>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"cardinality-referrer-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_r_froms_across_r9;

/// Macro to traverse [`Attribute`][ðŸ¦€] âž¡ [`Type`][ðŸ¦ž], via _R2_
///
/// This macro expects a &[`Attribute`][ðŸ¦€], and returns a &[`Type`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Attribute
/// [ðŸ¦ž]: crate::sarzak::types::Type
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Type;
/// # use sarzak::sarzak::Attribute;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_t_across_r2;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let phobic_actor = "foamy_zipper".to_owned();
/// let fertile_arm = "wanting_rod".to_owned();
/// let object = Object::new(&mut store, phobic_actor, fertile_arm);
/// let type_yyc = Type::test_default(&mut store);
/// let horrible_garden = "interesting_reading".to_owned();
///
/// let attribute = Attribute::new(&mut store, Some(&object), &type_yyc, horrible_garden);
///
/// let type_xnj = sarzak_get_one_t_across_r2!(attribute, store);
/// assert_eq!(&type_yyc, type_xnj);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_t_across_r2 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_ty(&$input.ty).unwrap()
    }};
}
pub use sarzak_get_one_t_across_r2;

/// Macro to traverse [`Type`][ðŸ¦€] âž¡ [`Attribute`][ðŸ¦ž], via _R2_
///
/// This macro expects a &[`Type`][ðŸ¦€], and returns a &[`Attribute`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Type
/// [ðŸ¦ž]: crate::sarzak::types::Attribute
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Type;
/// # use sarzak::sarzak::Attribute;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_a_across_r2;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let naughty_science = "extra_small_tramp".to_owned();
/// let instinctive_attack = "uptight_boy".to_owned();
/// let object = Object::new(&mut store, naughty_science, instinctive_attack);
/// let type_csq = Type::test_default(&mut store);
/// let ambitious_addition = "pleasant_balance".to_owned();
///
/// let attribute = Attribute::new(&mut store, Some(&object), &type_csq, ambitious_addition);
/// let attribute_zsc = sarzak_get_one_a_across_r2!(type_csq, store);
///
/// assert_eq!(&attribute, attribute_zsc);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_a_across_r2 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"ty-attribute-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_attribute()
            .find(|z| z.1.ty == $input.get_id())
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"ty-attribute-emit_one_unconditional_lookup"}}}
    }};
}
pub use sarzak_get_one_a_across_r2;

/// Macro to traverse [`Binary`][ðŸ¦€] âž¡ [`Referrer`][ðŸ¦ž], via _R6_
///
/// This macro expects a &[`Binary`][ðŸ¦€], and returns a &[`Referrer`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Binary
/// [ðŸ¦ž]: crate::sarzak::types::Referrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Binary;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak_get_one_r_from_across_r6;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_plk = Conditionality::test_default(&mut store);
/// let weary_locket = "undesirable_eggs".to_owned();
/// let five_zebra = "selective_soup".to_owned();
/// let object_nbg = Object::new(&mut store, weary_locket, five_zebra);
/// let cardinality_kcp = Cardinality::test_default(&mut store);
/// let referent_xsc = Referent::new(&mut store, &conditionality_plk, &object_nbg, &cardinality_kcp);
/// let conditionality_xff = Conditionality::test_default(&mut store);
/// let lewd_chickens = "addicted_hot".to_owned();
/// let lacking_snail = "jagged_oil".to_owned();
/// let object_enf = Object::new(&mut store, lewd_chickens, lacking_snail);
/// let cardinality_ihs = Cardinality::test_default(&mut store);
/// let upset_marble = "bustling_thought".to_owned();
/// let referrer_hiy = Referrer::new(&mut store, &conditionality_xff, &object_enf, &cardinality_ihs, upset_marble);
///
/// let binary = Binary::new(&mut store, &referent_xsc, &referrer_hiy, 42);
///
/// let referrer_mec = sarzak_get_one_r_from_across_r6!(binary, store);
/// assert_eq!(&referrer_hiy, referrer_mec);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_from_across_r6 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_referrer(&$input.from).unwrap()
    }};
}
pub use sarzak_get_one_r_from_across_r6;

/// Macro to traverse [`Referrer`][ðŸ¦€] âž¡ [`Binary`][ðŸ¦ž], via _R6_
///
/// This macro expects a &[`Referrer`][ðŸ¦€], and returns a &[`Binary`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referrer
/// [ðŸ¦ž]: crate::sarzak::types::Binary
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_r_bin_across_r6;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_kgg = Conditionality::test_default(&mut store);
/// let natural_vein = "ugliest_zebra".to_owned();
/// let frightening_actor = "illegal_hand".to_owned();
/// let object_yhi = Object::new(&mut store, natural_vein, frightening_actor);
/// let cardinality_bev = Cardinality::test_default(&mut store);
/// let referent_ixf = Referent::new(&mut store, &conditionality_kgg, &object_yhi, &cardinality_bev);
/// let conditionality_whk = Conditionality::test_default(&mut store);
/// let angry_house = "imaginary_adjustment".to_owned();
/// let embarrassed_ant = "curved_angle".to_owned();
/// let object_nre = Object::new(&mut store, angry_house, embarrassed_ant);
/// let cardinality_mld = Cardinality::test_default(&mut store);
/// let aquatic_suit = "giant_waste".to_owned();
/// let referrer_ptv = Referrer::new(&mut store, &conditionality_whk, &object_nre, &cardinality_mld, aquatic_suit);
///
/// let binary = Binary::new(&mut store, &referent_ixf, &referrer_ptv, 42);
/// let binary_tzs = sarzak_get_one_r_bin_across_r6!(referrer_ptv, store);
///
/// assert_eq!(&binary, binary_tzs);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_bin_across_r6 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"referrer-binary-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_binary()
            .find(|z| z.1.from == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"referrer-binary-emit_one_unconditional_lookup"}}}
    }};
}
pub use sarzak_get_one_r_bin_across_r6;

/// Macro to traverse [`Event`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R19_
///
/// This macro expects a &[`Event`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Event
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Event;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r19;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let aberrant_spy = "general_account".to_owned();
/// let ragged_summer = "fluffy_run".to_owned();
/// let object_wic = Object::new(&mut store, aberrant_spy, ragged_summer);
/// let rebel_laugh = "troubled_pump".to_owned();
///
/// let event = Event::new(&mut store, &object_wic, rebel_laugh);
///
/// let object_dil = sarzak_get_one_obj_across_r19!(event, store);
/// assert_eq!(&object_wic, object_dil);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r19 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r19;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Event`][ðŸ¦ž], via _R19(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Event`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Event
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Event;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_many_es_across_r19;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let careful_cub = "helpless_zephyr".to_owned();
/// let workable_orange = "fallacious_paper".to_owned();
/// let object_nhb = Object::new(&mut store, careful_cub, workable_orange);
/// let earthy_wire = "industrious_mass".to_owned();
///
/// let event = Event::new(&mut store, &object_nhb, earthy_wire);
/// let event_erd = sarzak_maybe_get_many_es_across_r19!(object_nhb, store);
///
/// assert!(event_erd.iter().find(|&x| **x == event).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_es_across_r19 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-event-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_event()
            .filter_map(|z| if z.1.obj_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&Event>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-event-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_es_across_r19;

/// Macro to traverse [`Attribute`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R1(c)_
///
/// This macro expects a &[`Attribute`][ðŸ¦€], and returns an Option<&[`Object`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Attribute
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Type;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Attribute;
/// # use sarzak::sarzak_maybe_get_one_obj_across_r1;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let spiteful_jelly = "delirious_spoon".to_owned();
/// let interesting_news = "impartial_governor".to_owned();
/// let object = Object::new(&mut store, spiteful_jelly, interesting_news);
/// let type_pte = Type::test_default(&mut store);
/// let wary_lizards = "adamant_volcano".to_owned();
/// let thundering_plate = "colorful_plane".to_owned();
/// let erect_queen = "cuddly_moon".to_owned();
///
/// let attribute = Attribute::new(&mut store, Some(&object), &type_pte, wary_lizards);
///
/// let object_hht = sarzak_maybe_get_one_obj_across_r1!(attribute, store);
/// assert_eq!(Some(&object), object_hht);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_obj_across_r1 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_conditional
        match &$input.obj_id {
            Some(i) => $store.exhume_object(i),
            None => None,
        }
    }};
}
pub use sarzak_maybe_get_one_obj_across_r1;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Attribute`][ðŸ¦ž], via _R1_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns a &[`Attribute`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Attribute
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Attribute;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Type;
/// # use sarzak::sarzak_get_many_as_across_r1;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let anxious_dress = "flat_sun".to_owned();
/// let discreet_stream = "murky_cloud".to_owned();
/// let sedate_field = "loud_crowd".to_owned();
/// let odd_advertisement = "glorious_comparison".to_owned();
/// let object = Object::new(&mut store, sedate_field, odd_advertisement);
/// let type_ksw = Type::test_default(&mut store);
/// let spotless_linen = "questionable_increase".to_owned();
///
/// let attribute = Attribute::new(&mut store, Some(&object), &type_ksw, spotless_linen);
///
/// let attribute_tuk = sarzak_get_many_as_across_r1!(object, store);
/// assert!(attribute_tuk.iter().find(|&x| **x == attribute).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_many_as_across_r1 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-attribute-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_attribute()
            .filter_map(|z| if z.1.obj_id == Some($input.id) { Some(z.1) } else { None })
            .collect::<Vec<&Attribute>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-attribute-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_get_many_as_across_r1;

/// Macro to traverse [`Subtype`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R15_
///
/// This macro expects a &[`Subtype`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Subtype
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Subtype;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r15;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let juvenile_jar = "shivering_whistle".to_owned();
/// let fretful_horn = "loud_glue".to_owned();
/// let object_one = Object::new(&mut store, juvenile_jar, fretful_horn);
///
/// let subtype = Subtype::new(&mut store, &object_one);
///
/// let object_upa = sarzak_get_one_obj_across_r15!(subtype, store);
/// assert_eq!(&object_one, object_upa);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r15 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r15;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Subtype`][ðŸ¦ž], via _R15(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Subtype`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Subtype
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Subtype;
/// # use sarzak::sarzak_maybe_get_one_r_sub_across_r15;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let tightfisted_car = "rustic_grass".to_owned();
/// let shaky_impulse = "real_mine".to_owned();
/// let object_gia = Object::new(&mut store, tightfisted_car, shaky_impulse);
///
/// let subtype = Subtype::new(&mut store, &object_gia);
/// let subtype_sox = sarzak_maybe_get_one_r_sub_across_r15!(object_gia, store);
///
/// assert_eq!(Some(&subtype), subtype_sox);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_sub_across_r15 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-subtype-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_subtype()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-subtype-emit_one_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_one_r_sub_across_r15;

/// Macro to traverse [`OtherSide`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R25_
///
/// This macro expects a &[`OtherSide`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::OtherSide
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r25;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let adjoining_surprise = "warlike_power".to_owned();
/// let literate_kittens = "acceptable_front".to_owned();
/// let object_zim = Object::new(&mut store, adjoining_surprise, literate_kittens);
///
/// let other_side = OtherSide::new(&mut store, &object_zim);
///
/// let object_gfu = sarzak_get_one_obj_across_r25!(other_side, store);
/// assert_eq!(&object_zim, object_gfu);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r25 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r25;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`OtherSide`][ðŸ¦ž], via _R25(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`OtherSide`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::OtherSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_one_r_oth_across_r25;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let tremendous_jail = "lame_tendency".to_owned();
/// let unwritten_fuel = "tense_square".to_owned();
/// let object_kme = Object::new(&mut store, tremendous_jail, unwritten_fuel);
///
/// let other_side = OtherSide::new(&mut store, &object_kme);
/// let other_side_llg = sarzak_maybe_get_one_r_oth_across_r25!(object_kme, store);
///
/// assert_eq!(Some(&other_side), other_side_llg);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_oth_across_r25 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-other_side-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_other_side()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-other_side-emit_one_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_one_r_oth_across_r25;

/// Macro to traverse [`Binary`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R5_
///
/// This macro expects a &[`Binary`][ðŸ¦€], and returns a &[`Referent`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Binary
/// [ðŸ¦ž]: crate::sarzak::types::Referent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::sarzak_get_one_r_to_across_r5;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_ste = Conditionality::test_default(&mut store);
/// let classy_suggestion = "quirky_kite".to_owned();
/// let clever_pancake = "naughty_desire".to_owned();
/// let object_elk = Object::new(&mut store, classy_suggestion, clever_pancake);
/// let cardinality_acf = Cardinality::test_default(&mut store);
/// let referent_man = Referent::new(&mut store, &conditionality_ste, &object_elk, &cardinality_acf);
/// let conditionality_lsz = Conditionality::test_default(&mut store);
/// let handsome_marble = "boorish_sack".to_owned();
/// let medical_hole = "massive_children".to_owned();
/// let object_wkc = Object::new(&mut store, handsome_marble, medical_hole);
/// let cardinality_ces = Cardinality::test_default(&mut store);
/// let tacit_good_bye = "aberrant_dinner".to_owned();
/// let referrer_jni = Referrer::new(&mut store, &conditionality_lsz, &object_wkc, &cardinality_ces, tacit_good_bye);
///
/// let binary = Binary::new(&mut store, &referent_man, &referrer_jni, 42);
///
/// let referent_qtf = sarzak_get_one_r_to_across_r5!(binary, store);
/// assert_eq!(&referent_man, referent_qtf);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_to_across_r5 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_referent(&$input.to).unwrap()
    }};
}
pub use sarzak_get_one_r_to_across_r5;

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`Binary`][ðŸ¦ž], via _R5_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`Binary`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referent
/// [ðŸ¦ž]: crate::sarzak::types::Binary
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak_get_one_r_bin_across_r5;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_uma = Conditionality::test_default(&mut store);
/// let damp_earthquake = "fast_organization".to_owned();
/// let keen_meeting = "silent_game".to_owned();
/// let object_isw = Object::new(&mut store, damp_earthquake, keen_meeting);
/// let cardinality_myq = Cardinality::test_default(&mut store);
/// let referent_yir = Referent::new(&mut store, &conditionality_uma, &object_isw, &cardinality_myq);
/// let conditionality_xke = Conditionality::test_default(&mut store);
/// let savory_butter = "wiggly_jail".to_owned();
/// let defiant_judge = "silky_quicksand".to_owned();
/// let object_jdm = Object::new(&mut store, savory_butter, defiant_judge);
/// let cardinality_soo = Cardinality::test_default(&mut store);
/// let mysterious_brothers = "robust_purpose".to_owned();
/// let referrer_pjr = Referrer::new(&mut store, &conditionality_xke, &object_jdm, &cardinality_soo, mysterious_brothers);
///
/// let binary = Binary::new(&mut store, &referent_yir, &referrer_pjr, 42);
/// let binary_mmo = sarzak_get_one_r_bin_across_r5!(referent_yir, store);
///
/// assert_eq!(&binary, binary_mmo);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_bin_across_r5 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"referent-binary-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_binary()
            .find(|z| z.1.to == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"referent-binary-emit_one_unconditional_lookup"}}}
    }};
}
pub use sarzak_get_one_r_bin_across_r5;
