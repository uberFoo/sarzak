//! Macros for navigating the "Sarzak" domain
//!
//! # Generated Code -- edit _with care_.
//!
//! Don't mess with anything between `{"magic":"îž¨","kind":"CriticalBlockBegin"}`
//! and `{"magic":"îž¨","kind":"CriticalBlockEnd"}`. Otherwise, you should be free
//! to go wild. Happy hacking!
//!
//! Use the following invocation to reproduce:
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
//! ```shell
//!  sarzak gen
//! ```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
// {"magic":"îž¨","version":"0.5.0"}
// {"magic":"îž¨","version":"1.0.0"}

/// Macro to traverse [`Referrer`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R17_
///
/// This macro expects a &[`Referrer`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referrer
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak_get_one_obj_across_r17;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_arh = Conditionality::test_default(&mut store);
/// let young_mountain = "questionable_rabbits".to_owned();
/// let scrawny_steam = "wretched_blow".to_owned();
/// let uttermost_lead = "meek_peace".to_owned();
/// let object_hfp = Object::new(&mut store, young_mountain, scrawny_steam, uttermost_lead);
/// let cardinality_zyv = Cardinality::test_default(&mut store);
/// let chilly_sponge = "damp_current".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_arh, &object_hfp, &cardinality_zyv, chilly_sponge);
///
/// let object_zkb = sarzak_get_one_obj_across_r17!(referrer, store);
/// assert_eq!(&object_hfp, object_zkb);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_obj_across_r17-emit_binary_main"}}}
macro_rules! sarzak_get_one_obj_across_r17 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-emit_one_unconditional"}}}
    }};
}
pub use sarzak_get_one_obj_across_r17;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_obj_across_r17-emit_binary_main"}}}

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Referrer`][ðŸ¦ž], via _R17(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Referrer`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Referrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_many_r_froms_across_r17;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_osm = Conditionality::test_default(&mut store);
/// let savory_school = "maniacal_manager".to_owned();
/// let psychedelic_station = "elfin_lake".to_owned();
/// let silly_talk = "enchanted_dogs".to_owned();
/// let object_jqb = Object::new(&mut store, savory_school, psychedelic_station, silly_talk);
/// let cardinality_tdz = Cardinality::test_default(&mut store);
/// let bent_marble = "eminent_cover".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_osm, &object_jqb, &cardinality_tdz, bent_marble);
/// let referrer_edr = sarzak_maybe_get_many_r_froms_across_r17!(object_jqb, store);
///
/// assert!(referrer_edr.iter().find(|&x| **x == referrer).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_maybe_get_many_r_froms_across_r17-emit_binary_main"}}}
macro_rules! sarzak_maybe_get_many_r_froms_across_r17 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-referrer-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referrer()
            .filter_map(|z| if z.1.obj_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&Referrer>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-referrer-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_r_froms_across_r17;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_maybe_get_many_r_froms_across_r17-emit_binary_main"}}}

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`Cardinality`][ðŸ¦ž], via _R8_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`Cardinality`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referent
/// [ðŸ¦ž]: crate::sarzak::types::Cardinality
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak_get_one_card_across_r8;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_vaa = Conditionality::test_default(&mut store);
/// let abashed_snakes = "bloody_cats".to_owned();
/// let boring_chin = "truthful_bed".to_owned();
/// let graceful_support = "ultra_time".to_owned();
/// let object_vvp = Object::new(&mut store, abashed_snakes, boring_chin, graceful_support);
/// let cardinality_fxi = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_vaa, &object_vvp, &cardinality_fxi);
///
/// let cardinality_gmk = sarzak_get_one_card_across_r8!(referent, store);
/// assert_eq!(&cardinality_fxi, cardinality_gmk);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_card_across_r8-emit_binary_main"}}}
macro_rules! sarzak_get_one_card_across_r8 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"cardinality-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_cardinality(&$input.cardinality).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"cardinality-emit_one_unconditional"}}}
    }};
}
pub use sarzak_get_one_card_across_r8;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_card_across_r8-emit_binary_main"}}}

/// Macro to traverse [`Cardinality`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R8(c)_
///
/// This macro expects a &[`Cardinality`][ðŸ¦€], and returns an Option<&[`Referent`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Cardinality
/// [ðŸ¦ž]: crate::sarzak::types::Referent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak_maybe_get_many_r_tos_across_r8;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_ryn = Conditionality::test_default(&mut store);
/// let opposite_smoke = "fluttering_exchange".to_owned();
/// let feigned_measure = "true_insect".to_owned();
/// let ashamed_walk = "fuzzy_knee".to_owned();
/// let object_jyu = Object::new(&mut store, opposite_smoke, feigned_measure, ashamed_walk);
/// let cardinality_lxz = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_ryn, &object_jyu, &cardinality_lxz);
/// let referent_xuz = sarzak_maybe_get_many_r_tos_across_r8!(cardinality_lxz, store);
///
/// assert!(referent_xuz.iter().find(|&x| **x == referent).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_maybe_get_many_r_tos_across_r8-emit_binary_main"}}}
macro_rules! sarzak_maybe_get_many_r_tos_across_r8 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"cardinality-referent-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referent()
            .filter_map(|z| if z.1.cardinality == $input.get_id() { Some(z.1) } else { None })
            .collect::<Vec<&Referent>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"cardinality-referent-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_r_tos_across_r8;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_maybe_get_many_r_tos_across_r8-emit_binary_main"}}}

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R16_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referent
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r16;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_vop = Conditionality::test_default(&mut store);
/// let boiling_cream = "wholesale_airplane".to_owned();
/// let subdued_spot = "lean_reading".to_owned();
/// let cooing_stream = "attractive_swing".to_owned();
/// let object_ezo = Object::new(&mut store, boiling_cream, subdued_spot, cooing_stream);
/// let cardinality_qel = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_vop, &object_ezo, &cardinality_qel);
///
/// let object_zhd = sarzak_get_one_obj_across_r16!(referent, store);
/// assert_eq!(&object_ezo, object_zhd);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_obj_across_r16-emit_binary_main"}}}
macro_rules! sarzak_get_one_obj_across_r16 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-emit_one_unconditional"}}}
    }};
}
pub use sarzak_get_one_obj_across_r16;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_obj_across_r16-emit_binary_main"}}}

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R16(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Referent`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Referent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_many_r_tos_across_r16;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_awe = Conditionality::test_default(&mut store);
/// let questionable_pig = "fantastic_tramp".to_owned();
/// let royal_wealth = "sudden_curtain".to_owned();
/// let moaning_fog = "superb_rod".to_owned();
/// let object_raj = Object::new(&mut store, questionable_pig, royal_wealth, moaning_fog);
/// let cardinality_vxx = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_awe, &object_raj, &cardinality_vxx);
/// let referent_rot = sarzak_maybe_get_many_r_tos_across_r16!(object_raj, store);
///
/// assert!(referent_rot.iter().find(|&x| **x == referent).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_maybe_get_many_r_tos_across_r16-emit_binary_main"}}}
macro_rules! sarzak_maybe_get_many_r_tos_across_r16 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-referent-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referent()
            .filter_map(|z| if z.1.obj_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&Referent>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-referent-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_r_tos_across_r16;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_maybe_get_many_r_tos_across_r16-emit_binary_main"}}}

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`Conditionality`][ðŸ¦ž], via _R12_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`Conditionality`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referent
/// [ðŸ¦ž]: crate::sarzak::types::Conditionality
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_cond_across_r12;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_dmj = Conditionality::test_default(&mut store);
/// let kindhearted_nerve = "outrageous_year".to_owned();
/// let successful_representative = "domineering_spiders".to_owned();
/// let savory_disgust = "ratty_smash".to_owned();
/// let object_wso = Object::new(&mut store, kindhearted_nerve, successful_representative, savory_disgust);
/// let cardinality_vgc = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_dmj, &object_wso, &cardinality_vgc);
///
/// let conditionality_kaq = sarzak_get_one_cond_across_r12!(referent, store);
/// assert_eq!(&conditionality_dmj, conditionality_kaq);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_cond_across_r12-emit_binary_main"}}}
macro_rules! sarzak_get_one_cond_across_r12 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"conditionality-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_conditionality(&$input.conditionality).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"conditionality-emit_one_unconditional"}}}
    }};
}
pub use sarzak_get_one_cond_across_r12;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_cond_across_r12-emit_binary_main"}}}

/// Macro to traverse [`Conditionality`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R12(c)_
///
/// This macro expects a &[`Conditionality`][ðŸ¦€], and returns an Option<&[`Referent`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Conditionality
/// [ðŸ¦ž]: crate::sarzak::types::Referent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak_maybe_get_many_r_tos_across_r12;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_ave = Conditionality::test_default(&mut store);
/// let foolish_home = "clumsy_rat".to_owned();
/// let entertaining_leather = "old_fashioned_wine".to_owned();
/// let conscious_view = "right_trip".to_owned();
/// let object_nxr = Object::new(&mut store, foolish_home, entertaining_leather, conscious_view);
/// let cardinality_hca = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_ave, &object_nxr, &cardinality_hca);
/// let referent_zwd = sarzak_maybe_get_many_r_tos_across_r12!(conditionality_ave, store);
///
/// assert!(referent_zwd.iter().find(|&x| **x == referent).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_maybe_get_many_r_tos_across_r12-emit_binary_main"}}}
macro_rules! sarzak_maybe_get_many_r_tos_across_r12 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"conditionality-referent-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referent()
            .filter_map(|z| if z.1.conditionality == $input.get_id() { Some(z.1) } else { None })
            .collect::<Vec<&Referent>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"conditionality-referent-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_r_tos_across_r12;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_maybe_get_many_r_tos_across_r12-emit_binary_main"}}}

/// Macro to traverse [`AssociativeReferrer`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R26_
///
/// This macro expects a &[`AssociativeReferrer`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::AssociativeReferrer
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::AssociativeReferrer;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r26;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let tremendous_cloud = "stale_bulb".to_owned();
/// let staking_harbor = "flat_bear".to_owned();
/// let open_playground = "sincere_earth".to_owned();
/// let object_cun = Object::new(&mut store, tremendous_cloud, staking_harbor, open_playground);
///
/// let associative_referrer = AssociativeReferrer::new(&mut store, &object_cun);
///
/// let object_sun = sarzak_get_one_obj_across_r26!(associative_referrer, store);
/// assert_eq!(&object_cun, object_sun);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_obj_across_r26-emit_binary_main"}}}
macro_rules! sarzak_get_one_obj_across_r26 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-emit_one_unconditional"}}}
    }};
}
pub use sarzak_get_one_obj_across_r26;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_obj_across_r26-emit_binary_main"}}}

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`AssociativeReferrer`][ðŸ¦ž], via _R26(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`AssociativeReferrer`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::AssociativeReferrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::AssociativeReferrer;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_many_ass_froms_across_r26;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let scintillating_error = "incompetent_ship".to_owned();
/// let steadfast_popcorn = "boiling_road".to_owned();
/// let mindless_cent = "astonishing_disgust".to_owned();
/// let object_ind = Object::new(&mut store, scintillating_error, steadfast_popcorn, mindless_cent);
///
/// let associative_referrer = AssociativeReferrer::new(&mut store, &object_ind);
/// let associative_referrer_cfq = sarzak_maybe_get_many_ass_froms_across_r26!(object_ind, store);
///
/// assert!(associative_referrer_cfq.iter().find(|&x| **x == associative_referrer).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_maybe_get_many_ass_froms_across_r26-emit_binary_main"}}}
macro_rules! sarzak_maybe_get_many_ass_froms_across_r26 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-associative_referrer-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_associative_referrer()
            .filter_map(|z| if z.1.obj_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&AssociativeReferrer>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-associative_referrer-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_ass_froms_across_r26;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_maybe_get_many_ass_froms_across_r26-emit_binary_main"}}}

/// Macro to traverse [`Referrer`][ðŸ¦€] âž¡ [`Conditionality`][ðŸ¦ž], via _R11_
///
/// This macro expects a &[`Referrer`][ðŸ¦€], and returns a &[`Conditionality`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referrer
/// [ðŸ¦ž]: crate::sarzak::types::Conditionality
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak_get_one_cond_across_r11;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_dac = Conditionality::test_default(&mut store);
/// let thoughtless_snakes = "fearful_chance".to_owned();
/// let squeamish_houses = "abrasive_elbow".to_owned();
/// let puny_meal = "thinkable_news".to_owned();
/// let object_wuw = Object::new(&mut store, thoughtless_snakes, squeamish_houses, puny_meal);
/// let cardinality_grx = Cardinality::test_default(&mut store);
/// let well_to_do_table = "apathetic_friend".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_dac, &object_wuw, &cardinality_grx, well_to_do_table);
///
/// let conditionality_mln = sarzak_get_one_cond_across_r11!(referrer, store);
/// assert_eq!(&conditionality_dac, conditionality_mln);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_cond_across_r11-emit_binary_main"}}}
macro_rules! sarzak_get_one_cond_across_r11 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"conditionality-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_conditionality(&$input.conditionality).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"conditionality-emit_one_unconditional"}}}
    }};
}
pub use sarzak_get_one_cond_across_r11;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_cond_across_r11-emit_binary_main"}}}

/// Macro to traverse [`Conditionality`][ðŸ¦€] âž¡ [`Referrer`][ðŸ¦ž], via _R11(c)_
///
/// This macro expects a &[`Conditionality`][ðŸ¦€], and returns an Option<&[`Referrer`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Conditionality
/// [ðŸ¦ž]: crate::sarzak::types::Referrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_many_r_froms_across_r11;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_vxx = Conditionality::test_default(&mut store);
/// let steady_way = "thick_camera".to_owned();
/// let shiny_sidewalk = "animated_bite".to_owned();
/// let nine_screw = "hospitable_turkey".to_owned();
/// let object_uav = Object::new(&mut store, steady_way, shiny_sidewalk, nine_screw);
/// let cardinality_lcx = Cardinality::test_default(&mut store);
/// let cooperative_toothbrush = "filthy_trade".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_vxx, &object_uav, &cardinality_lcx, cooperative_toothbrush);
/// let referrer_uod = sarzak_maybe_get_many_r_froms_across_r11!(conditionality_vxx, store);
///
/// assert!(referrer_uod.iter().find(|&x| **x == referrer).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_maybe_get_many_r_froms_across_r11-emit_binary_main"}}}
macro_rules! sarzak_maybe_get_many_r_froms_across_r11 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"conditionality-referrer-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referrer()
            .filter_map(|z| if z.1.conditionality == $input.get_id() { Some(z.1) } else { None })
            .collect::<Vec<&Referrer>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"conditionality-referrer-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_r_froms_across_r11;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_maybe_get_many_r_froms_across_r11-emit_binary_main"}}}

/// Macro to traverse [`Subtype`][ðŸ¦€] âž¡ [`Isa`][ðŸ¦ž], via _R27_
///
/// This macro expects a &[`Subtype`][ðŸ¦€], and returns a &[`Isa`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Subtype
/// [ðŸ¦ž]: crate::sarzak::types::Isa
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Subtype;
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_r_isa_across_r27;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let offbeat_mom = "damaged_trees".to_owned();
/// let fragile_verse = "physical_doctor".to_owned();
/// let awesome_lawyer = "educated_oranges".to_owned();
/// let object_erz = Object::new(&mut store, offbeat_mom, fragile_verse, awesome_lawyer);
/// let supertype_suv = Supertype::new(&mut store, &object_erz);
/// let isa_oph = Isa::new(&mut store, &supertype_suv, 42);
/// let offbeat_minister = "receptive_ocean".to_owned();
/// let ahead_tub = "magenta_knee".to_owned();
/// let frequent_dirt = "deserted_hammer".to_owned();
/// let object_wvm = Object::new(&mut store, offbeat_minister, ahead_tub, frequent_dirt);
///
/// let subtype = Subtype::new(&mut store, &isa_oph, &object_wvm);
///
/// let isa_pxf = sarzak_get_one_r_isa_across_r27!(subtype, store);
/// assert_eq!(&isa_oph, isa_pxf);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_r_isa_across_r27-emit_binary_main"}}}
macro_rules! sarzak_get_one_r_isa_across_r27 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"isa-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_isa(&$input.isa).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"isa-emit_one_unconditional"}}}
    }};
}
pub use sarzak_get_one_r_isa_across_r27;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_r_isa_across_r27-emit_binary_main"}}}

/// Macro to traverse [`Isa`][ðŸ¦€] âž¡ [`Subtype`][ðŸ¦ž], via _R27_
///
/// This macro expects a &[`Isa`][ðŸ¦€], and returns a &[`Subtype`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Isa
/// [ðŸ¦ž]: crate::sarzak::types::Subtype
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Subtype;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_many_r_subs_across_r27;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let political_minister = "alluring_father".to_owned();
/// let innocent_grass = "befitting_interest".to_owned();
/// let ugliest_bag = "hypnotic_paper".to_owned();
/// let object_awi = Object::new(&mut store, political_minister, innocent_grass, ugliest_bag);
/// let supertype_nxg = Supertype::new(&mut store, &object_awi);
/// let isa_bte = Isa::new(&mut store, &supertype_nxg, 42);
/// let parched_stop = "hissing_scale".to_owned();
/// let lush_achiever = "utopian_grandmother".to_owned();
/// let stingy_powder = "romantic_soda".to_owned();
/// let object_tis = Object::new(&mut store, parched_stop, lush_achiever, stingy_powder);
///
/// let subtype = Subtype::new(&mut store, &isa_bte, &object_tis);
/// let subtype_rnd = sarzak_get_many_r_subs_across_r27!(isa_bte, store);
///
/// assert!(subtype_rnd.iter().find(|&x| **x == subtype).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_many_r_subs_across_r27-emit_binary_main"}}}
macro_rules! sarzak_get_many_r_subs_across_r27 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"isa-subtype-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_subtype()
            .filter_map(|z| if z.1.isa == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&Subtype>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"isa-subtype-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_get_many_r_subs_across_r27;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_many_r_subs_across_r27-emit_binary_main"}}}

/// Macro to traverse [`Isa`][ðŸ¦€] âž¡ [`Supertype`][ðŸ¦ž], via _R13_
///
/// This macro expects a &[`Isa`][ðŸ¦€], and returns a &[`Supertype`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Isa
/// [ðŸ¦ž]: crate::sarzak::types::Supertype
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::sarzak_get_one_r_sup_across_r13;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let exultant_kiss = "obedient_harbor".to_owned();
/// let flagrant_behavior = "disgusted_arch".to_owned();
/// let colorful_yak = "fallacious_governor".to_owned();
/// let object_tik = Object::new(&mut store, exultant_kiss, flagrant_behavior, colorful_yak);
/// let supertype_jsb = Supertype::new(&mut store, &object_tik);
///
/// let isa = Isa::new(&mut store, &supertype_jsb, 42);
///
/// let supertype_kti = sarzak_get_one_r_sup_across_r13!(isa, store);
/// assert_eq!(&supertype_jsb, supertype_kti);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_r_sup_across_r13-emit_binary_main"}}}
macro_rules! sarzak_get_one_r_sup_across_r13 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"supertype-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_supertype(&$input.supertype).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"supertype-emit_one_unconditional"}}}
    }};
}
pub use sarzak_get_one_r_sup_across_r13;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_r_sup_across_r13-emit_binary_main"}}}

/// Macro to traverse [`Supertype`][ðŸ¦€] âž¡ [`Isa`][ðŸ¦ž], via _R13_
///
/// This macro expects a &[`Supertype`][ðŸ¦€], and returns a &[`Isa`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Supertype
/// [ðŸ¦ž]: crate::sarzak::types::Isa
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::sarzak_get_one_r_isa_across_r13;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let crowded_cemetery = "absorbed_governor".to_owned();
/// let glistening_friend = "mellow_government".to_owned();
/// let second_approval = "troubled_snails".to_owned();
/// let object_wtr = Object::new(&mut store, crowded_cemetery, glistening_friend, second_approval);
/// let supertype_myn = Supertype::new(&mut store, &object_wtr);
///
/// let isa = Isa::new(&mut store, &supertype_myn, 42);
/// let isa_oke = sarzak_get_one_r_isa_across_r13!(supertype_myn, store);
///
/// assert_eq!(&isa, isa_oke);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_r_isa_across_r13-emit_binary_main"}}}
macro_rules! sarzak_get_one_r_isa_across_r13 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"supertype-isa-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_isa()
            .find(|z| z.1.supertype == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"supertype-isa-emit_one_unconditional_lookup"}}}
    }};
}
pub use sarzak_get_one_r_isa_across_r13;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_r_isa_across_r13-emit_binary_main"}}}

/// Macro to traverse [`State`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R18_
///
/// This macro expects a &[`State`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::State
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::State;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r18;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let foregoing_profit = "garrulous_ladybug".to_owned();
/// let slippery_faucet = "stingy_belief".to_owned();
/// let cynical_quicksand = "untidy_lawyer".to_owned();
/// let object_wmw = Object::new(&mut store, foregoing_profit, slippery_faucet, cynical_quicksand);
/// let certain_harbor = "near_flag".to_owned();
///
/// let state = State::new(&mut store, &object_wmw, certain_harbor);
///
/// let object_jmb = sarzak_get_one_obj_across_r18!(state, store);
/// assert_eq!(&object_wmw, object_jmb);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_obj_across_r18-emit_binary_main"}}}
macro_rules! sarzak_get_one_obj_across_r18 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-emit_one_unconditional"}}}
    }};
}
pub use sarzak_get_one_obj_across_r18;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_obj_across_r18-emit_binary_main"}}}

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`State`][ðŸ¦ž], via _R18(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`State`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::State
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::State;
/// # use sarzak::sarzak_maybe_get_many_ss_across_r18;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let pathetic_waves = "chemical_trouble".to_owned();
/// let special_drop = "thankful_apparatus".to_owned();
/// let loutish_shirt = "disgusted_blood".to_owned();
/// let object_djc = Object::new(&mut store, pathetic_waves, special_drop, loutish_shirt);
/// let worthless_squirrel = "dear_zoo".to_owned();
///
/// let state = State::new(&mut store, &object_djc, worthless_squirrel);
/// let state_vku = sarzak_maybe_get_many_ss_across_r18!(object_djc, store);
///
/// assert!(state_vku.iter().find(|&x| **x == state).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_maybe_get_many_ss_across_r18-emit_binary_main"}}}
macro_rules! sarzak_maybe_get_many_ss_across_r18 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-state-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_state()
            .filter_map(|z| if z.1.obj_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&State>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-state-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_ss_across_r18;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_maybe_get_many_ss_across_r18-emit_binary_main"}}}

/// Macro to traverse [`State`][ðŸ¦€] âž¡ [`Event`][ðŸ¦ž], across [`AcknowledgedEvent`][ðŸ¦‘] via _R20_
///
/// This macro expects a &[`State`][ðŸ¦€], and returns a &[`Event`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ðŸ¦€]: crate::sarzak::types::State
/// [ðŸ¦ž]: crate::sarzak::types::Event
/// [ðŸ¦‘]: crate::sarzak::types::AcknowledgedEvent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Event;
/// # use sarzak::sarzak::State;
/// # use sarzak::sarzak::AcknowledgedEvent;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_many_e_across_r20;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let medical_zoo = "broad_driving".to_owned();
/// let third_process = "lyrical_van".to_owned();
/// let hapless_scarecrow = "bouncy_corn".to_owned();
/// let object_zfb = Object::new(&mut store, medical_zoo, third_process, hapless_scarecrow);
/// let selective_playground = "fascinated_anger".to_owned();
/// let state_wku = State::new(&mut store, &object_zfb, selective_playground);
/// let hollow_potato = "mighty_arch".to_owned();
/// let psychotic_guide = "scrawny_chain".to_owned();
/// let repulsive_minister = "trashy_camp".to_owned();
/// let object_zya = Object::new(&mut store, hollow_potato, psychotic_guide, repulsive_minister);
/// let glorious_observation = "grotesque_beetle".to_owned();
/// let event_uuj = Event::new(&mut store, &object_zya, glorious_observation);
/// let acknowledged_event = AcknowledgedEvent::new(&mut store, &state_wku, &event_uuj);
///
/// let event_uul = sarzak_get_many_e_across_r20!(state_wku, store);
/// assert!(event_uul.iter().find(|&x| **x == event_uuj).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_many_e_across_r20-emit_associative_main"}}}
macro_rules! sarzak_get_many_e_across_r20 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_many
        $store
            .iter_acknowledged_event()
            .filter(|a| a.1.state_id == $input.id)
            .map(|a| $store.exhume_event(&a.1.event_id).unwrap())
            .collect::<Vec<&Event>>()
    }};
}
pub use sarzak_get_many_e_across_r20;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_many_e_across_r20-emit_associative_main"}}}

/// Macro to traverse [`Event`][ðŸ¦€] âž¡ [`State`][ðŸ¦ž], across [`AcknowledgedEvent`][ðŸ¦‘] via _R20_
///
/// This macro expects a &[`Event`][ðŸ¦€], and returns a &[`State`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ðŸ¦€]: crate::sarzak::types::Event
/// [ðŸ¦ž]: crate::sarzak::types::State
/// [ðŸ¦‘]: crate::sarzak::types::AcknowledgedEvent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::AcknowledgedEvent;
/// # use sarzak::sarzak::Event;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::State;
/// # use sarzak::sarzak_get_many_s_across_r20;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let abrupt_field = "deranged_cloud".to_owned();
/// let square_drug = "limping_sound".to_owned();
/// let simplistic_rings = "squealing_society".to_owned();
/// let object_dwq = Object::new(&mut store, abrupt_field, square_drug, simplistic_rings);
/// let violet_nut = "vigorous_sense".to_owned();
/// let state_oby = State::new(&mut store, &object_dwq, violet_nut);
/// let helpful_middle = "entertaining_sail".to_owned();
/// let obnoxious_dinosaurs = "familiar_pen".to_owned();
/// let equable_spiders = "funny_attraction".to_owned();
/// let object_xqb = Object::new(&mut store, helpful_middle, obnoxious_dinosaurs, equable_spiders);
/// let tiny_branch = "alert_regret".to_owned();
/// let event_ksp = Event::new(&mut store, &object_xqb, tiny_branch);
/// let acknowledged_event = AcknowledgedEvent::new(&mut store, &state_oby, &event_ksp);
///
/// let state_fke = sarzak_get_many_s_across_r20!(event_ksp, store);
/// assert!(state_fke.iter().find(|&x| **x == state_oby).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_many_s_across_r20-emit_associative_main"}}}
macro_rules! sarzak_get_many_s_across_r20 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_many
        $store
            .iter_acknowledged_event()
            .filter(|a| a.1.event_id == $input.id)
            .map(|a| $store.exhume_state(&a.1.state_id).unwrap())
            .collect::<Vec<&State>>()
    }};
}
pub use sarzak_get_many_s_across_r20;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_many_s_across_r20-emit_associative_main"}}}

/// Macro to traverse [`Associative`][ðŸ¦€] âž¡ [`AssociativeReferent`][ðŸ¦ž], via _R22_
///
/// This macro expects a &[`Associative`][ðŸ¦€], and returns a &[`AssociativeReferent`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Associative
/// [ðŸ¦ž]: crate::sarzak::types::AssociativeReferent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::AssociativeReferrer;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::AssociativeReferent;
/// # use sarzak::sarzak_get_one_ass_to_across_r22;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let pretty_comb = "futuristic_cloth".to_owned();
/// let momentous_trouble = "hurt_ray".to_owned();
/// let profuse_metal = "painstaking_cattle".to_owned();
/// let object_oec = Object::new(&mut store, pretty_comb, momentous_trouble, profuse_metal);
/// let associative_referent_nqm = AssociativeReferent::new(&mut store, &object_oec);
/// let scary_kiss = "useless_doll".to_owned();
/// let solid_lake = "pathetic_approval".to_owned();
/// let striped_grandmother = "freezing_coil".to_owned();
/// let object_pfh = Object::new(&mut store, scary_kiss, solid_lake, striped_grandmother);
/// let associative_referent_edl = AssociativeReferent::new(&mut store, &object_pfh);
/// let acrid_bat = "cold_key".to_owned();
/// let future_lunchroom = "imperfect_egg".to_owned();
/// let condemned_part = "greedy_action".to_owned();
/// let object_lgg = Object::new(&mut store, acrid_bat, future_lunchroom, condemned_part);
/// let associative_referrer_agd = AssociativeReferrer::new(&mut store, &object_lgg);
///
/// let associative = Associative::new(&mut store, &associative_referent_nqm, &associative_referent_edl, &associative_referrer_agd, 42);
///
/// let associative_referent_zss = sarzak_get_one_ass_to_across_r22!(associative, store);
/// assert_eq!(&associative_referent_edl, associative_referent_zss);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_ass_to_across_r22-emit_binary_main"}}}
macro_rules! sarzak_get_one_ass_to_across_r22 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"associative_referent-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_associative_referent(&$input.other).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"associative_referent-emit_one_unconditional"}}}
    }};
}
pub use sarzak_get_one_ass_to_across_r22;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_ass_to_across_r22-emit_binary_main"}}}

/// Macro to traverse [`AssociativeReferent`][ðŸ¦€] âž¡ [`Associative`][ðŸ¦ž], via _R22_
///
/// This macro expects a &[`AssociativeReferent`][ðŸ¦€], and returns a &[`Associative`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::AssociativeReferent
/// [ðŸ¦ž]: crate::sarzak::types::Associative
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::AssociativeReferrer;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::AssociativeReferent;
/// # use sarzak::sarzak_get_one_r_assoc_across_r22;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let funny_desire = "wicked_pocket".to_owned();
/// let deadpan_position = "superb_expansion".to_owned();
/// let hateful_brain = "disastrous_paste".to_owned();
/// let object_mzi = Object::new(&mut store, funny_desire, deadpan_position, hateful_brain);
/// let associative_referent_vjj = AssociativeReferent::new(&mut store, &object_mzi);
/// let jolly_price = "victorious_bead".to_owned();
/// let colorful_pets = "deeply_mother".to_owned();
/// let modern_turkey = "large_jellyfish".to_owned();
/// let object_fzw = Object::new(&mut store, jolly_price, colorful_pets, modern_turkey);
/// let associative_referent_uqy = AssociativeReferent::new(&mut store, &object_fzw);
/// let windy_pickle = "agonizing_bells".to_owned();
/// let trite_horn = "sordid_treatment".to_owned();
/// let exuberant_clock = "calm_jump".to_owned();
/// let object_tam = Object::new(&mut store, windy_pickle, trite_horn, exuberant_clock);
/// let associative_referrer_pql = AssociativeReferrer::new(&mut store, &object_tam);
///
/// let associative = Associative::new(&mut store, &associative_referent_vjj, &associative_referent_uqy, &associative_referrer_pql, 42);
/// let associative_xkv = sarzak_get_one_r_assoc_across_r22!(associative_referent_uqy, store);
///
/// assert_eq!(&associative, associative_xkv);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_r_assoc_across_r22-emit_binary_main"}}}
macro_rules! sarzak_get_one_r_assoc_across_r22 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"associative_referent-associative-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_associative()
            .find(|z| z.1.other == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"associative_referent-associative-emit_one_unconditional_lookup"}}}
    }};
}
pub use sarzak_get_one_r_assoc_across_r22;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_r_assoc_across_r22-emit_binary_main"}}}

/// Macro to traverse [`Supertype`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R14_
///
/// This macro expects a &[`Supertype`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Supertype
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak_get_one_obj_across_r14;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let combative_bag = "worried_fact".to_owned();
/// let cowardly_silk = "precious_passenger".to_owned();
/// let high_pitched_society = "nutty_cow".to_owned();
/// let object_opd = Object::new(&mut store, combative_bag, cowardly_silk, high_pitched_society);
///
/// let supertype = Supertype::new(&mut store, &object_opd);
///
/// let object_vxi = sarzak_get_one_obj_across_r14!(supertype, store);
/// assert_eq!(&object_opd, object_vxi);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_obj_across_r14-emit_binary_main"}}}
macro_rules! sarzak_get_one_obj_across_r14 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-emit_one_unconditional"}}}
    }};
}
pub use sarzak_get_one_obj_across_r14;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_obj_across_r14-emit_binary_main"}}}

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Supertype`][ðŸ¦ž], via _R14(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Supertype`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Supertype
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak_maybe_get_many_r_sups_across_r14;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let grandiose_zephyr = "witty_hook".to_owned();
/// let relieved_mass = "doubtful_mailbox".to_owned();
/// let unwieldy_ticket = "large_vest".to_owned();
/// let object_lcw = Object::new(&mut store, grandiose_zephyr, relieved_mass, unwieldy_ticket);
///
/// let supertype = Supertype::new(&mut store, &object_lcw);
/// let supertype_xum = sarzak_maybe_get_many_r_sups_across_r14!(object_lcw, store);
///
/// assert!(supertype_xum.iter().find(|&x| **x == supertype).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_maybe_get_many_r_sups_across_r14-emit_binary_main"}}}
macro_rules! sarzak_maybe_get_many_r_sups_across_r14 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-supertype-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_supertype()
            .filter_map(|z| if z.1.obj_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&Supertype>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-supertype-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_r_sups_across_r14;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_maybe_get_many_r_sups_across_r14-emit_binary_main"}}}

/// Macro to traverse [`Associative`][ðŸ¦€] âž¡ [`AssociativeReferrer`][ðŸ¦ž], via _R21_
///
/// This macro expects a &[`Associative`][ðŸ¦€], and returns a &[`AssociativeReferrer`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Associative
/// [ðŸ¦ž]: crate::sarzak::types::AssociativeReferrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::AssociativeReferrer;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::AssociativeReferent;
/// # use sarzak::sarzak_get_one_ass_from_across_r21;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let earthy_chicken = "hellish_shelf".to_owned();
/// let knotty_beds = "wide_eyed_quarter".to_owned();
/// let spotless_beggar = "phobic_nose".to_owned();
/// let object_ffp = Object::new(&mut store, earthy_chicken, knotty_beds, spotless_beggar);
/// let associative_referent_ufy = AssociativeReferent::new(&mut store, &object_ffp);
/// let hurried_basketball = "brawny_flavor".to_owned();
/// let concerned_bikes = "absurd_curtain".to_owned();
/// let troubled_ear = "clean_hammer".to_owned();
/// let object_azu = Object::new(&mut store, hurried_basketball, concerned_bikes, troubled_ear);
/// let associative_referent_pjt = AssociativeReferent::new(&mut store, &object_azu);
/// let quarrelsome_chain = "tart_goat".to_owned();
/// let young_sky = "shrill_pump".to_owned();
/// let important_cows = "panicky_authority".to_owned();
/// let object_pbc = Object::new(&mut store, quarrelsome_chain, young_sky, important_cows);
/// let associative_referrer_ney = AssociativeReferrer::new(&mut store, &object_pbc);
///
/// let associative = Associative::new(&mut store, &associative_referent_ufy, &associative_referent_pjt, &associative_referrer_ney, 42);
///
/// let associative_referrer_jdh = sarzak_get_one_ass_from_across_r21!(associative, store);
/// assert_eq!(&associative_referrer_ney, associative_referrer_jdh);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_ass_from_across_r21-emit_binary_main"}}}
macro_rules! sarzak_get_one_ass_from_across_r21 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"associative_referrer-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_associative_referrer(&$input.from).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"associative_referrer-emit_one_unconditional"}}}
    }};
}
pub use sarzak_get_one_ass_from_across_r21;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_ass_from_across_r21-emit_binary_main"}}}

/// Macro to traverse [`AssociativeReferrer`][ðŸ¦€] âž¡ [`Associative`][ðŸ¦ž], via _R21_
///
/// This macro expects a &[`AssociativeReferrer`][ðŸ¦€], and returns a &[`Associative`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::AssociativeReferrer
/// [ðŸ¦ž]: crate::sarzak::types::Associative
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::AssociativeReferent;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::AssociativeReferrer;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak_get_one_r_assoc_across_r21;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let nimble_bulb = "festive_salt".to_owned();
/// let abandoned_plastic = "tall_industry".to_owned();
/// let expensive_copper = "wiggly_goose".to_owned();
/// let object_ysg = Object::new(&mut store, nimble_bulb, abandoned_plastic, expensive_copper);
/// let associative_referent_dzb = AssociativeReferent::new(&mut store, &object_ysg);
/// let periodic_monkey = "absent_fireman".to_owned();
/// let loutish_loaf = "special_distance".to_owned();
/// let clean_toothpaste = "bustling_shame".to_owned();
/// let object_nbo = Object::new(&mut store, periodic_monkey, loutish_loaf, clean_toothpaste);
/// let associative_referent_hxt = AssociativeReferent::new(&mut store, &object_nbo);
/// let resonant_pig = "physical_finger".to_owned();
/// let lively_crib = "unaccountable_wealth".to_owned();
/// let ill_informed_club = "political_believe".to_owned();
/// let object_vup = Object::new(&mut store, resonant_pig, lively_crib, ill_informed_club);
/// let associative_referrer_rnd = AssociativeReferrer::new(&mut store, &object_vup);
///
/// let associative = Associative::new(&mut store, &associative_referent_dzb, &associative_referent_hxt, &associative_referrer_rnd, 42);
/// let associative_raw = sarzak_get_one_r_assoc_across_r21!(associative_referrer_rnd, store);
///
/// assert_eq!(&associative, associative_raw);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_r_assoc_across_r21-emit_binary_main"}}}
macro_rules! sarzak_get_one_r_assoc_across_r21 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"associative_referrer-associative-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_associative()
            .find(|z| z.1.from == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"associative_referrer-associative-emit_one_unconditional_lookup"}}}
    }};
}
pub use sarzak_get_one_r_assoc_across_r21;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_r_assoc_across_r21-emit_binary_main"}}}

/// Macro to traverse [`Referrer`][ðŸ¦€] âž¡ [`Cardinality`][ðŸ¦ž], via _R9_
///
/// This macro expects a &[`Referrer`][ðŸ¦€], and returns a &[`Cardinality`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referrer
/// [ðŸ¦ž]: crate::sarzak::types::Cardinality
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak_get_one_card_across_r9;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_nkz = Conditionality::test_default(&mut store);
/// let dashing_throat = "acoustic_house".to_owned();
/// let loud_mom = "itchy_bag".to_owned();
/// let lucky_crook = "awake_year".to_owned();
/// let object_pxa = Object::new(&mut store, dashing_throat, loud_mom, lucky_crook);
/// let cardinality_vrs = Cardinality::test_default(&mut store);
/// let succinct_dirt = "well_off_territory".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_nkz, &object_pxa, &cardinality_vrs, succinct_dirt);
///
/// let cardinality_fyk = sarzak_get_one_card_across_r9!(referrer, store);
/// assert_eq!(&cardinality_vrs, cardinality_fyk);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_card_across_r9-emit_binary_main"}}}
macro_rules! sarzak_get_one_card_across_r9 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"cardinality-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_cardinality(&$input.cardinality).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"cardinality-emit_one_unconditional"}}}
    }};
}
pub use sarzak_get_one_card_across_r9;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_card_across_r9-emit_binary_main"}}}

/// Macro to traverse [`Cardinality`][ðŸ¦€] âž¡ [`Referrer`][ðŸ¦ž], via _R9(c)_
///
/// This macro expects a &[`Cardinality`][ðŸ¦€], and returns an Option<&[`Referrer`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Cardinality
/// [ðŸ¦ž]: crate::sarzak::types::Referrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak_maybe_get_many_r_froms_across_r9;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_rns = Conditionality::test_default(&mut store);
/// let adjoining_walk = "feeble_banana".to_owned();
/// let frightened_payment = "frequent_swing".to_owned();
/// let pretty_stamp = "gamy_account".to_owned();
/// let object_gxo = Object::new(&mut store, adjoining_walk, frightened_payment, pretty_stamp);
/// let cardinality_vig = Cardinality::test_default(&mut store);
/// let grey_office = "scintillating_mist".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_rns, &object_gxo, &cardinality_vig, grey_office);
/// let referrer_uyl = sarzak_maybe_get_many_r_froms_across_r9!(cardinality_vig, store);
///
/// assert!(referrer_uyl.iter().find(|&x| **x == referrer).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_maybe_get_many_r_froms_across_r9-emit_binary_main"}}}
macro_rules! sarzak_maybe_get_many_r_froms_across_r9 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"cardinality-referrer-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referrer()
            .filter_map(|z| if z.1.cardinality == $input.get_id() { Some(z.1) } else { None })
            .collect::<Vec<&Referrer>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"cardinality-referrer-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_r_froms_across_r9;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_maybe_get_many_r_froms_across_r9-emit_binary_main"}}}

/// Macro to traverse [`Attribute`][ðŸ¦€] âž¡ [`Type`][ðŸ¦ž], via _R2_
///
/// This macro expects a &[`Attribute`][ðŸ¦€], and returns a &[`Type`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Attribute
/// [ðŸ¦ž]: crate::sarzak::types::Type
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Type;
/// # use sarzak::sarzak::Attribute;
/// # use sarzak::sarzak_get_one_t_across_r2;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let red_hole = "numerous_station".to_owned();
/// let petite_meat = "dark_rainstorm".to_owned();
/// let guttural_authority = "impolite_holiday".to_owned();
/// let object = Object::new(&mut store, red_hole, petite_meat, guttural_authority);
/// let type_ejq = Type::test_default(&mut store);
/// let flawless_lace = "righteous_science".to_owned();
///
/// let attribute = Attribute::new(&mut store, Some(&object), &type_ejq, flawless_lace);
///
/// let type_xha = sarzak_get_one_t_across_r2!(attribute, store);
/// assert_eq!(&type_ejq, type_xha);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_t_across_r2-emit_binary_main"}}}
macro_rules! sarzak_get_one_t_across_r2 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"ty-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_ty(&$input.ty).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"ty-emit_one_unconditional"}}}
    }};
}
pub use sarzak_get_one_t_across_r2;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_t_across_r2-emit_binary_main"}}}

/// Macro to traverse [`Type`][ðŸ¦€] âž¡ [`Attribute`][ðŸ¦ž], via _R2_
///
/// This macro expects a &[`Type`][ðŸ¦€], and returns a &[`Attribute`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Type
/// [ðŸ¦ž]: crate::sarzak::types::Attribute
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Type;
/// # use sarzak::sarzak::Attribute;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_a_across_r2;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let swift_cracker = "heavenly_sneeze".to_owned();
/// let spicy_trick = "previous_science".to_owned();
/// let political_brothers = "fascinated_start".to_owned();
/// let object = Object::new(&mut store, swift_cracker, spicy_trick, political_brothers);
/// let type_dgi = Type::test_default(&mut store);
/// let electric_card = "belligerent_show".to_owned();
///
/// let attribute = Attribute::new(&mut store, Some(&object), &type_dgi, electric_card);
/// let attribute_sor = sarzak_get_one_a_across_r2!(type_dgi, store);
///
/// assert_eq!(&attribute, attribute_sor);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_a_across_r2-emit_binary_main"}}}
macro_rules! sarzak_get_one_a_across_r2 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"ty-attribute-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_attribute()
            .find(|z| z.1.ty == $input.get_id())
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"ty-attribute-emit_one_unconditional_lookup"}}}
    }};
}
pub use sarzak_get_one_a_across_r2;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_a_across_r2-emit_binary_main"}}}

/// Macro to traverse [`Binary`][ðŸ¦€] âž¡ [`Referrer`][ðŸ¦ž], via _R6_
///
/// This macro expects a &[`Binary`][ðŸ¦€], and returns a &[`Referrer`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Binary
/// [ðŸ¦ž]: crate::sarzak::types::Referrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak_get_one_r_from_across_r6;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_jke = Conditionality::test_default(&mut store);
/// let berserk_sticks = "glorious_grain".to_owned();
/// let shallow_seat = "spiky_trick".to_owned();
/// let second_hand_throat = "wanting_operation".to_owned();
/// let object_pty = Object::new(&mut store, berserk_sticks, shallow_seat, second_hand_throat);
/// let cardinality_wzj = Cardinality::test_default(&mut store);
/// let referent_mpx = Referent::new(&mut store, &conditionality_jke, &object_pty, &cardinality_wzj);
/// let conditionality_srb = Conditionality::test_default(&mut store);
/// let lyrical_sponge = "rigid_bead".to_owned();
/// let certain_believe = "furry_pigs".to_owned();
/// let abandoned_eggs = "warm_minister".to_owned();
/// let object_xmj = Object::new(&mut store, lyrical_sponge, certain_believe, abandoned_eggs);
/// let cardinality_uqp = Cardinality::test_default(&mut store);
/// let tranquil_value = "abrasive_drop".to_owned();
/// let referrer_tom = Referrer::new(&mut store, &conditionality_srb, &object_xmj, &cardinality_uqp, tranquil_value);
///
/// let binary = Binary::new(&mut store, &referent_mpx, &referrer_tom, 42);
///
/// let referrer_ium = sarzak_get_one_r_from_across_r6!(binary, store);
/// assert_eq!(&referrer_tom, referrer_ium);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_r_from_across_r6-emit_binary_main"}}}
macro_rules! sarzak_get_one_r_from_across_r6 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"referrer-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_referrer(&$input.from).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"referrer-emit_one_unconditional"}}}
    }};
}
pub use sarzak_get_one_r_from_across_r6;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_r_from_across_r6-emit_binary_main"}}}

/// Macro to traverse [`Referrer`][ðŸ¦€] âž¡ [`Binary`][ðŸ¦ž], via _R6_
///
/// This macro expects a &[`Referrer`][ðŸ¦€], and returns a &[`Binary`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referrer
/// [ðŸ¦ž]: crate::sarzak::types::Binary
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak_get_one_r_bin_across_r6;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_faf = Conditionality::test_default(&mut store);
/// let nimble_form = "swift_store".to_owned();
/// let capricious_crime = "general_sense".to_owned();
/// let wiggly_waves = "clever_increase".to_owned();
/// let object_bhp = Object::new(&mut store, nimble_form, capricious_crime, wiggly_waves);
/// let cardinality_aqq = Cardinality::test_default(&mut store);
/// let referent_gwq = Referent::new(&mut store, &conditionality_faf, &object_bhp, &cardinality_aqq);
/// let conditionality_ykl = Conditionality::test_default(&mut store);
/// let smoggy_board = "defeated_fall".to_owned();
/// let mixed_truck = "open_drink".to_owned();
/// let aberrant_bun = "nippy_approval".to_owned();
/// let object_cob = Object::new(&mut store, smoggy_board, mixed_truck, aberrant_bun);
/// let cardinality_uju = Cardinality::test_default(&mut store);
/// let taboo_town = "overwrought_title".to_owned();
/// let referrer_jmq = Referrer::new(&mut store, &conditionality_ykl, &object_cob, &cardinality_uju, taboo_town);
///
/// let binary = Binary::new(&mut store, &referent_gwq, &referrer_jmq, 42);
/// let binary_aar = sarzak_get_one_r_bin_across_r6!(referrer_jmq, store);
///
/// assert_eq!(&binary, binary_aar);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_r_bin_across_r6-emit_binary_main"}}}
macro_rules! sarzak_get_one_r_bin_across_r6 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"referrer-binary-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_binary()
            .find(|z| z.1.from == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"referrer-binary-emit_one_unconditional_lookup"}}}
    }};
}
pub use sarzak_get_one_r_bin_across_r6;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_r_bin_across_r6-emit_binary_main"}}}

/// Macro to traverse [`Event`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R19_
///
/// This macro expects a &[`Event`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Event
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Event;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r19;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let evasive_event = "daffy_nest".to_owned();
/// let first_rabbit = "ugly_decision".to_owned();
/// let domineering_burst = "pointless_humor".to_owned();
/// let object_shv = Object::new(&mut store, evasive_event, first_rabbit, domineering_burst);
/// let mighty_vein = "exultant_fan".to_owned();
///
/// let event = Event::new(&mut store, &object_shv, mighty_vein);
///
/// let object_qrp = sarzak_get_one_obj_across_r19!(event, store);
/// assert_eq!(&object_shv, object_qrp);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_obj_across_r19-emit_binary_main"}}}
macro_rules! sarzak_get_one_obj_across_r19 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-emit_one_unconditional"}}}
    }};
}
pub use sarzak_get_one_obj_across_r19;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_obj_across_r19-emit_binary_main"}}}

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Event`][ðŸ¦ž], via _R19(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Event`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Event
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Event;
/// # use sarzak::sarzak_maybe_get_many_es_across_r19;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let functional_ladybug = "breakable_wheel".to_owned();
/// let merciful_letters = "thinkable_voyage".to_owned();
/// let precious_disease = "abounding_vein".to_owned();
/// let object_euh = Object::new(&mut store, functional_ladybug, merciful_letters, precious_disease);
/// let unknown_measure = "thankful_history".to_owned();
///
/// let event = Event::new(&mut store, &object_euh, unknown_measure);
/// let event_mir = sarzak_maybe_get_many_es_across_r19!(object_euh, store);
///
/// assert!(event_mir.iter().find(|&x| **x == event).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_maybe_get_many_es_across_r19-emit_binary_main"}}}
macro_rules! sarzak_maybe_get_many_es_across_r19 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-event-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_event()
            .filter_map(|z| if z.1.obj_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&Event>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-event-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_es_across_r19;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_maybe_get_many_es_across_r19-emit_binary_main"}}}

/// Macro to traverse [`Attribute`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R1(c)_
///
/// This macro expects a &[`Attribute`][ðŸ¦€], and returns an Option<&[`Object`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Attribute
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Attribute;
/// # use sarzak::sarzak::Type;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_one_obj_across_r1;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let beneficial_bear = "thundering_cellar".to_owned();
/// let tawdry_planes = "seemly_reason".to_owned();
/// let weak_hall = "tense_recess".to_owned();
/// let object = Object::new(&mut store, beneficial_bear, tawdry_planes, weak_hall);
/// let type_oog = Type::test_default(&mut store);
/// let graceful_crib = "sore_woman".to_owned();
/// let tart_friend = "exclusive_chairs".to_owned();
/// let somber_jam = "ethereal_disgust".to_owned();
/// let undesirable_town = "rural_whistle".to_owned();
///
/// let attribute = Attribute::new(&mut store, Some(&object), &type_oog, graceful_crib);
///
/// let object_vzq = sarzak_maybe_get_one_obj_across_r1!(attribute, store);
/// assert_eq!(Some(&object), object_vzq);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_maybe_get_one_obj_across_r1-emit_binary_main"}}}
macro_rules! sarzak_maybe_get_one_obj_across_r1 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-emit_one_conditional"}}}
        // nut::codegen::template::macros::emit_one_conditional
        match &$input.obj_id {
            Some(i) => $store.exhume_object(i),
            None => None,
        }
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-emit_one_conditional"}}}
    }};
}
pub use sarzak_maybe_get_one_obj_across_r1;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_maybe_get_one_obj_across_r1-emit_binary_main"}}}

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Attribute`][ðŸ¦ž], via _R1_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns a &[`Attribute`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Attribute
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Type;
/// # use sarzak::sarzak::Attribute;
/// # use sarzak::sarzak_get_many_as_across_r1;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let hungry_swing = "cuddly_rabbit".to_owned();
/// let obedient_oatmeal = "wary_jellyfish".to_owned();
/// let phobic_rest = "telling_banana".to_owned();
/// let enormous_jar = "stimulating_beef".to_owned();
/// let guiltless_shame = "dull_train".to_owned();
/// let petite_market = "enchanting_sponge".to_owned();
/// let object = Object::new(&mut store, enormous_jar, guiltless_shame, petite_market);
/// let type_slp = Type::test_default(&mut store);
/// let weak_haircut = "nauseating_sink".to_owned();
///
/// let attribute = Attribute::new(&mut store, Some(&object), &type_slp, weak_haircut);
///
/// let attribute_ofd = sarzak_get_many_as_across_r1!(object, store);
/// assert!(attribute_ofd.iter().find(|&x| **x == attribute).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_many_as_across_r1-emit_binary_main"}}}
macro_rules! sarzak_get_many_as_across_r1 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-attribute-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_attribute()
            .filter_map(|z| if z.1.obj_id == Some($input.id) { Some(z.1) } else { None })
            .collect::<Vec<&Attribute>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-attribute-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_get_many_as_across_r1;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_many_as_across_r1-emit_binary_main"}}}

/// Macro to traverse [`Subtype`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R15_
///
/// This macro expects a &[`Subtype`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Subtype
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Isa;
/// # use sarzak::sarzak::Subtype;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak_get_one_obj_across_r15;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let pricey_lawyer = "whimsical_self".to_owned();
/// let terrific_trucks = "even_silver".to_owned();
/// let waiting_men = "wretched_vessel".to_owned();
/// let object_gkt = Object::new(&mut store, pricey_lawyer, terrific_trucks, waiting_men);
/// let supertype_cae = Supertype::new(&mut store, &object_gkt);
/// let isa_xth = Isa::new(&mut store, &supertype_cae, 42);
/// let acceptable_protest = "lumpy_kite".to_owned();
/// let keen_voice = "wiggly_run".to_owned();
/// let makeshift_curtain = "equable_galley".to_owned();
/// let object_zwi = Object::new(&mut store, acceptable_protest, keen_voice, makeshift_curtain);
///
/// let subtype = Subtype::new(&mut store, &isa_xth, &object_zwi);
///
/// let object_hsw = sarzak_get_one_obj_across_r15!(subtype, store);
/// assert_eq!(&object_zwi, object_hsw);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_obj_across_r15-emit_binary_main"}}}
macro_rules! sarzak_get_one_obj_across_r15 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-emit_one_unconditional"}}}
    }};
}
pub use sarzak_get_one_obj_across_r15;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_obj_across_r15-emit_binary_main"}}}

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Subtype`][ðŸ¦ž], via _R15(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Subtype`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Subtype
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Subtype;
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::sarzak_maybe_get_many_r_subs_across_r15;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let feigned_wool = "earthy_bottle".to_owned();
/// let afraid_order = "wary_cannon".to_owned();
/// let obnoxious_grass = "gamy_chair".to_owned();
/// let object_tir = Object::new(&mut store, feigned_wool, afraid_order, obnoxious_grass);
/// let supertype_uiz = Supertype::new(&mut store, &object_tir);
/// let isa_aam = Isa::new(&mut store, &supertype_uiz, 42);
/// let tested_van = "numerous_cattle".to_owned();
/// let colorful_cap = "panoramic_knife".to_owned();
/// let hesitant_kitten = "faithful_snail".to_owned();
/// let object_wss = Object::new(&mut store, tested_van, colorful_cap, hesitant_kitten);
///
/// let subtype = Subtype::new(&mut store, &isa_aam, &object_wss);
/// let subtype_htp = sarzak_maybe_get_many_r_subs_across_r15!(object_wss, store);
///
/// assert!(subtype_htp.iter().find(|&x| **x == subtype).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_maybe_get_many_r_subs_across_r15-emit_binary_main"}}}
macro_rules! sarzak_maybe_get_many_r_subs_across_r15 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-subtype-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_subtype()
            .filter_map(|z| if z.1.obj_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&Subtype>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-subtype-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_r_subs_across_r15;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_maybe_get_many_r_subs_across_r15-emit_binary_main"}}}

/// Macro to traverse [`Associative`][ðŸ¦€] âž¡ [`AssociativeReferent`][ðŸ¦ž], via _R23_
///
/// This macro expects a &[`Associative`][ðŸ¦€], and returns a &[`AssociativeReferent`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Associative
/// [ðŸ¦ž]: crate::sarzak::types::AssociativeReferent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::AssociativeReferent;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::AssociativeReferrer;
/// # use sarzak::sarzak_get_one_ass_to_across_r23;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let didactic_umbrella = "petite_dirt".to_owned();
/// let gaudy_feeling = "living_turn".to_owned();
/// let elastic_position = "lyrical_value".to_owned();
/// let object_umq = Object::new(&mut store, didactic_umbrella, gaudy_feeling, elastic_position);
/// let associative_referent_nwj = AssociativeReferent::new(&mut store, &object_umq);
/// let shy_chance = "ludicrous_toes".to_owned();
/// let remarkable_crown = "peaceful_memory".to_owned();
/// let garrulous_anger = "cultured_girls".to_owned();
/// let object_lzl = Object::new(&mut store, shy_chance, remarkable_crown, garrulous_anger);
/// let associative_referent_avn = AssociativeReferent::new(&mut store, &object_lzl);
/// let abusive_morning = "second_hand_fact".to_owned();
/// let childlike_birth = "unaccountable_belief".to_owned();
/// let abrupt_quilt = "false_wave".to_owned();
/// let object_hsr = Object::new(&mut store, abusive_morning, childlike_birth, abrupt_quilt);
/// let associative_referrer_lgw = AssociativeReferrer::new(&mut store, &object_hsr);
///
/// let associative = Associative::new(&mut store, &associative_referent_nwj, &associative_referent_avn, &associative_referrer_lgw, 42);
///
/// let associative_referent_rkq = sarzak_get_one_ass_to_across_r23!(associative, store);
/// assert_eq!(&associative_referent_nwj, associative_referent_rkq);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_ass_to_across_r23-emit_binary_main"}}}
macro_rules! sarzak_get_one_ass_to_across_r23 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"associative_referent-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_associative_referent(&$input.one).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"associative_referent-emit_one_unconditional"}}}
    }};
}
pub use sarzak_get_one_ass_to_across_r23;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_ass_to_across_r23-emit_binary_main"}}}

/// Macro to traverse [`AssociativeReferent`][ðŸ¦€] âž¡ [`Associative`][ðŸ¦ž], via _R23_
///
/// This macro expects a &[`AssociativeReferent`][ðŸ¦€], and returns a &[`Associative`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::AssociativeReferent
/// [ðŸ¦ž]: crate::sarzak::types::Associative
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::AssociativeReferent;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::AssociativeReferrer;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_r_assoc_across_r23;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let aboriginal_cat = "meaty_queen".to_owned();
/// let terrible_nation = "enormous_monkey".to_owned();
/// let spiffy_quarter = "burly_skin".to_owned();
/// let object_ahn = Object::new(&mut store, aboriginal_cat, terrible_nation, spiffy_quarter);
/// let associative_referent_brn = AssociativeReferent::new(&mut store, &object_ahn);
/// let fresh_pigs = "threatening_detail".to_owned();
/// let smart_cent = "kindhearted_tent".to_owned();
/// let damaged_fan = "luxuriant_laborer".to_owned();
/// let object_ysw = Object::new(&mut store, fresh_pigs, smart_cent, damaged_fan);
/// let associative_referent_bif = AssociativeReferent::new(&mut store, &object_ysw);
/// let tasty_process = "wet_team".to_owned();
/// let furry_income = "poor_fold".to_owned();
/// let married_profit = "spotless_angle".to_owned();
/// let object_whl = Object::new(&mut store, tasty_process, furry_income, married_profit);
/// let associative_referrer_yxe = AssociativeReferrer::new(&mut store, &object_whl);
///
/// let associative = Associative::new(&mut store, &associative_referent_brn, &associative_referent_bif, &associative_referrer_yxe, 42);
/// let associative_hev = sarzak_get_one_r_assoc_across_r23!(associative_referent_brn, store);
///
/// assert_eq!(&associative, associative_hev);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_r_assoc_across_r23-emit_binary_main"}}}
macro_rules! sarzak_get_one_r_assoc_across_r23 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"associative_referent-associative-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_associative()
            .find(|z| z.1.one == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"associative_referent-associative-emit_one_unconditional_lookup"}}}
    }};
}
pub use sarzak_get_one_r_assoc_across_r23;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_r_assoc_across_r23-emit_binary_main"}}}

/// Macro to traverse [`AssociativeReferent`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R25_
///
/// This macro expects a &[`AssociativeReferent`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::AssociativeReferent
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::AssociativeReferent;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r25;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let flippant_crib = "incandescent_teaching".to_owned();
/// let lively_lawyer = "sharp_agreement".to_owned();
/// let nonstop_memory = "murky_stone".to_owned();
/// let object_wtr = Object::new(&mut store, flippant_crib, lively_lawyer, nonstop_memory);
///
/// let associative_referent = AssociativeReferent::new(&mut store, &object_wtr);
///
/// let object_vxg = sarzak_get_one_obj_across_r25!(associative_referent, store);
/// assert_eq!(&object_wtr, object_vxg);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_obj_across_r25-emit_binary_main"}}}
macro_rules! sarzak_get_one_obj_across_r25 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-emit_one_unconditional"}}}
    }};
}
pub use sarzak_get_one_obj_across_r25;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_obj_across_r25-emit_binary_main"}}}

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`AssociativeReferent`][ðŸ¦ž], via _R25(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`AssociativeReferent`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::AssociativeReferent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::AssociativeReferent;
/// # use sarzak::sarzak_maybe_get_many_ass_tos_across_r25;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let lucky_creator = "entertaining_brain".to_owned();
/// let probable_wheel = "domineering_bath".to_owned();
/// let overrated_boot = "shy_yak".to_owned();
/// let object_jsg = Object::new(&mut store, lucky_creator, probable_wheel, overrated_boot);
///
/// let associative_referent = AssociativeReferent::new(&mut store, &object_jsg);
/// let associative_referent_pel = sarzak_maybe_get_many_ass_tos_across_r25!(object_jsg, store);
///
/// assert!(associative_referent_pel.iter().find(|&x| **x == associative_referent).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_maybe_get_many_ass_tos_across_r25-emit_binary_main"}}}
macro_rules! sarzak_maybe_get_many_ass_tos_across_r25 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object-associative_referent-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_associative_referent()
            .filter_map(|z| if z.1.obj_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&AssociativeReferent>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object-associative_referent-emit_many_conditional_lookup"}}}
    }};
}
pub use sarzak_maybe_get_many_ass_tos_across_r25;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_maybe_get_many_ass_tos_across_r25-emit_binary_main"}}}

/// Macro to traverse [`Binary`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R5_
///
/// This macro expects a &[`Binary`][ðŸ¦€], and returns a &[`Referent`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Binary
/// [ðŸ¦ž]: crate::sarzak::types::Referent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_r_to_across_r5;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_jss = Conditionality::test_default(&mut store);
/// let bite_sized_detail = "grateful_religion".to_owned();
/// let dirty_clock = "outgoing_minute".to_owned();
/// let craven_eggs = "marked_oil".to_owned();
/// let object_hxq = Object::new(&mut store, bite_sized_detail, dirty_clock, craven_eggs);
/// let cardinality_xoz = Cardinality::test_default(&mut store);
/// let referent_vdr = Referent::new(&mut store, &conditionality_jss, &object_hxq, &cardinality_xoz);
/// let conditionality_nqo = Conditionality::test_default(&mut store);
/// let supreme_form = "panicky_dog".to_owned();
/// let blue_eyed_deer = "sordid_wind".to_owned();
/// let thick_tomatoes = "cowardly_nail".to_owned();
/// let object_hzo = Object::new(&mut store, supreme_form, blue_eyed_deer, thick_tomatoes);
/// let cardinality_gpv = Cardinality::test_default(&mut store);
/// let annoying_sticks = "accessible_flesh".to_owned();
/// let referrer_ybs = Referrer::new(&mut store, &conditionality_nqo, &object_hzo, &cardinality_gpv, annoying_sticks);
///
/// let binary = Binary::new(&mut store, &referent_vdr, &referrer_ybs, 42);
///
/// let referent_izk = sarzak_get_one_r_to_across_r5!(binary, store);
/// assert_eq!(&referent_vdr, referent_izk);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_r_to_across_r5-emit_binary_main"}}}
macro_rules! sarzak_get_one_r_to_across_r5 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"referent-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_referent(&$input.to).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"referent-emit_one_unconditional"}}}
    }};
}
pub use sarzak_get_one_r_to_across_r5;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_r_to_across_r5-emit_binary_main"}}}

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`Binary`][ðŸ¦ž], via _R5_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`Binary`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referent
/// [ðŸ¦ž]: crate::sarzak::types::Binary
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak_get_one_r_bin_across_r5;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_ftb = Conditionality::test_default(&mut store);
/// let square_cars = "fertile_substance".to_owned();
/// let rare_pies = "mushy_sand".to_owned();
/// let obsolete_machine = "ambitious_milk".to_owned();
/// let object_gsc = Object::new(&mut store, square_cars, rare_pies, obsolete_machine);
/// let cardinality_hhc = Cardinality::test_default(&mut store);
/// let referent_fek = Referent::new(&mut store, &conditionality_ftb, &object_gsc, &cardinality_hhc);
/// let conditionality_cyi = Conditionality::test_default(&mut store);
/// let simple_cattle = "husky_group".to_owned();
/// let curved_bat = "thoughtful_judge".to_owned();
/// let didactic_store = "sordid_dinosaurs".to_owned();
/// let object_lvc = Object::new(&mut store, simple_cattle, curved_bat, didactic_store);
/// let cardinality_emg = Cardinality::test_default(&mut store);
/// let pastoral_snakes = "agreeable_hate".to_owned();
/// let referrer_ccq = Referrer::new(&mut store, &conditionality_cyi, &object_lvc, &cardinality_emg, pastoral_snakes);
///
/// let binary = Binary::new(&mut store, &referent_fek, &referrer_ccq, 42);
/// let binary_rby = sarzak_get_one_r_bin_across_r5!(referent_fek, store);
///
/// assert_eq!(&binary, binary_rby);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"sarzak_get_one_r_bin_across_r5-emit_binary_main"}}}
macro_rules! sarzak_get_one_r_bin_across_r5 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"referent-binary-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_binary()
            .find(|z| z.1.to == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"referent-binary-emit_one_unconditional_lookup"}}}
    }};
}
pub use sarzak_get_one_r_bin_across_r5;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"sarzak_get_one_r_bin_across_r5-emit_binary_main"}}}
