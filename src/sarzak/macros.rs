//! {"magic":"îž¨","version":"0.0.1"}
//! Macros for navigating the "Sarzak" domain
//!
//! Generated Code -- edit _carefully_.
//! Don't mess with anything between {"magic":"îž¨","kind":"CriticalBlockBegin"}
//! and {"magic":"îž¨","kind":"CriticalBlockEnd"}. Otherwise, you should be free
//! to go wild. Happy hacking!
//! Use the following invocation to reproduce:
//! ```shell
//!  sarzak gen
//! ```

/// Macro to traverse [`Referrer`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R17_
///
/// This macro expects a &[`Referrer`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referrer
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak_get_one_obj_across_r17;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_iig = Conditionality::test_default(&mut store);
/// let volatile_coach = "damaging_hill".to_owned();
/// let object_spb = Object::new(&mut store, volatile_coach);
/// let cardinality_ojs = Cardinality::test_default(&mut store);
/// let frightened_lead = "bite_sized_range".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_iig, &object_spb, &cardinality_ojs, frightened_lead);
///
/// let object_zgs = sarzak_get_one_obj_across_r17!(referrer, store);
/// assert_eq!(&object_spb, object_zgs);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r17 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r17;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Referrer`][ðŸ¦ž], via _R17(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Referrer`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Referrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak_maybe_get_one_r_from_across_r17;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_oce = Conditionality::test_default(&mut store);
/// let uncovered_dolls = "vulgar_brake".to_owned();
/// let object_vpl = Object::new(&mut store, uncovered_dolls);
/// let cardinality_adx = Cardinality::test_default(&mut store);
/// let amazing_insect = "jagged_throat".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_oce, &object_vpl, &cardinality_adx, amazing_insect);
/// let referrer_ypl = sarzak_maybe_get_one_r_from_across_r17!(object_vpl, store);
///
/// assert_eq!(Some(&referrer), referrer_ypl);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_from_across_r17 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_referrer()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
            // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_one_r_from_across_r17;

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`Cardinality`][ðŸ¦ž], via _R8_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`Cardinality`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referent
/// [ðŸ¦ž]: crate::sarzak::types::Cardinality
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak_get_one_card_across_r8;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_nnc = Conditionality::test_default(&mut store);
/// let ethereal_can = "weak_smell".to_owned();
/// let object_evy = Object::new(&mut store, ethereal_can);
/// let cardinality_kvf = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_nnc, &object_evy, &cardinality_kvf);
///
/// let cardinality_gon = sarzak_get_one_card_across_r8!(referent, store);
/// assert_eq!(&cardinality_kvf, cardinality_gon);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_card_across_r8 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_cardinality(&$input.cardinality).unwrap()
    }};
}
pub use sarzak_get_one_card_across_r8;

/// Macro to traverse [`Cardinality`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R8(c)_
///
/// This macro expects a &[`Cardinality`][ðŸ¦€], and returns an Option<&[`Referent`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Cardinality
/// [ðŸ¦ž]: crate::sarzak::types::Referent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_many_r_tos_across_r8;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_bti = Conditionality::test_default(&mut store);
/// let encouraging_toe = "obeisant_stop".to_owned();
/// let object_rvv = Object::new(&mut store, encouraging_toe);
/// let cardinality_sag = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_bti, &object_rvv, &cardinality_sag);
/// let referent_tel = sarzak_maybe_get_many_r_tos_across_r8!(cardinality_sag, store);
///
/// assert!(referent_tel.iter().find(|&x| **x == referent).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_r_tos_across_r8 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referent()
            .filter_map(|z| if z.1.cardinality == $input.get_id() { Some(z.1) } else { None })
            .collect::<Vec<&Referent>>()
            // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_many_r_tos_across_r8;

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R16_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referent
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak_get_one_obj_across_r16;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_qav = Conditionality::test_default(&mut store);
/// let gamy_quill = "mushy_servant".to_owned();
/// let object_psw = Object::new(&mut store, gamy_quill);
/// let cardinality_lpe = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_qav, &object_psw, &cardinality_lpe);
///
/// let object_wds = sarzak_get_one_obj_across_r16!(referent, store);
/// assert_eq!(&object_psw, object_wds);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r16 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r16;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R16(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Referent`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Referent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak_maybe_get_one_r_to_across_r16;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_mem = Conditionality::test_default(&mut store);
/// let oval_cork = "giant_fog".to_owned();
/// let object_hzo = Object::new(&mut store, oval_cork);
/// let cardinality_xqx = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_mem, &object_hzo, &cardinality_xqx);
/// let referent_qdx = sarzak_maybe_get_one_r_to_across_r16!(object_hzo, store);
///
/// assert_eq!(Some(&referent), referent_qdx);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_to_across_r16 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_referent()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
            // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_one_r_to_across_r16;

/// Macro to traverse [`OneSide`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R24_
///
/// This macro expects a &[`OneSide`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::OneSide
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak_get_one_obj_across_r24;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let debonair_need = "juvenile_attack".to_owned();
/// let object_ixo = Object::new(&mut store, debonair_need);
///
/// let one_side = OneSide::new(&mut store, &object_ixo);
///
/// let object_jne = sarzak_get_one_obj_across_r24!(one_side, store);
/// assert_eq!(&object_ixo, object_jne);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r24 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r24;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`OneSide`][ðŸ¦ž], via _R24(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`OneSide`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::OneSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_one_r_one_across_r24;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let black_and_white_sky = "parched_taste".to_owned();
/// let object_cul = Object::new(&mut store, black_and_white_sky);
///
/// let one_side = OneSide::new(&mut store, &object_cul);
/// let one_side_adk = sarzak_maybe_get_one_r_one_across_r24!(object_cul, store);
///
/// assert_eq!(Some(&one_side), one_side_adk);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_one_across_r24 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_one_side()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
            // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_one_r_one_across_r24;

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`Conditionality`][ðŸ¦ž], via _R12_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`Conditionality`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referent
/// [ðŸ¦ž]: crate::sarzak::types::Conditionality
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_cond_across_r12;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_bvm = Conditionality::test_default(&mut store);
/// let tenuous_force = "stimulating_calendar".to_owned();
/// let object_paf = Object::new(&mut store, tenuous_force);
/// let cardinality_aek = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_bvm, &object_paf, &cardinality_aek);
///
/// let conditionality_khm = sarzak_get_one_cond_across_r12!(referent, store);
/// assert_eq!(&conditionality_bvm, conditionality_khm);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_cond_across_r12 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_conditionality(&$input.conditionality).unwrap()
    }};
}
pub use sarzak_get_one_cond_across_r12;

/// Macro to traverse [`Conditionality`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R12(c)_
///
/// This macro expects a &[`Conditionality`][ðŸ¦€], and returns an Option<&[`Referent`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Conditionality
/// [ðŸ¦ž]: crate::sarzak::types::Referent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak_maybe_get_many_r_tos_across_r12;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_zzl = Conditionality::test_default(&mut store);
/// let icky_branch = "regular_slope".to_owned();
/// let object_nad = Object::new(&mut store, icky_branch);
/// let cardinality_qdd = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_zzl, &object_nad, &cardinality_qdd);
/// let referent_hdo = sarzak_maybe_get_many_r_tos_across_r12!(conditionality_zzl, store);
///
/// assert!(referent_hdo.iter().find(|&x| **x == referent).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_r_tos_across_r12 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referent()
            .filter_map(|z| if z.1.conditionality == $input.get_id() { Some(z.1) } else { None })
            .collect::<Vec<&Referent>>()
            // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_many_r_tos_across_r12;

/// Macro to traverse [`AssociativeSide`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R26_
///
/// This macro expects a &[`AssociativeSide`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::AssociativeSide
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r26;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let hard_fold = "sad_wing".to_owned();
/// let object_dvx = Object::new(&mut store, hard_fold);
///
/// let associative_side = AssociativeSide::new(&mut store, &object_dvx);
///
/// let object_bmk = sarzak_get_one_obj_across_r26!(associative_side, store);
/// assert_eq!(&object_dvx, object_bmk);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r26 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r26;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`AssociativeSide`][ðŸ¦ž], via _R26(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`AssociativeSide`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::AssociativeSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_one_r_ass_across_r26;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let absent_spoon = "profuse_trees".to_owned();
/// let object_lfq = Object::new(&mut store, absent_spoon);
///
/// let associative_side = AssociativeSide::new(&mut store, &object_lfq);
/// let associative_side_vsk = sarzak_maybe_get_one_r_ass_across_r26!(object_lfq, store);
///
/// assert_eq!(Some(&associative_side), associative_side_vsk);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_ass_across_r26 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_side()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
            // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_one_r_ass_across_r26;

/// Macro to traverse [`Referrer`][ðŸ¦€] âž¡ [`Conditionality`][ðŸ¦ž], via _R11_
///
/// This macro expects a &[`Referrer`][ðŸ¦€], and returns a &[`Conditionality`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referrer
/// [ðŸ¦ž]: crate::sarzak::types::Conditionality
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak_get_one_cond_across_r11;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_mrc = Conditionality::test_default(&mut store);
/// let classy_string = "momentous_list".to_owned();
/// let object_azw = Object::new(&mut store, classy_string);
/// let cardinality_tqw = Cardinality::test_default(&mut store);
/// let hysterical_laborer = "kaput_cloud".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_mrc, &object_azw, &cardinality_tqw, hysterical_laborer);
///
/// let conditionality_lyn = sarzak_get_one_cond_across_r11!(referrer, store);
/// assert_eq!(&conditionality_mrc, conditionality_lyn);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_cond_across_r11 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_conditionality(&$input.conditionality).unwrap()
    }};
}
pub use sarzak_get_one_cond_across_r11;

/// Macro to traverse [`Conditionality`][ðŸ¦€] âž¡ [`Referrer`][ðŸ¦ž], via _R11(c)_
///
/// This macro expects a &[`Conditionality`][ðŸ¦€], and returns an Option<&[`Referrer`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Conditionality
/// [ðŸ¦ž]: crate::sarzak::types::Referrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_many_r_froms_across_r11;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_tkz = Conditionality::test_default(&mut store);
/// let ambitious_eyes = "closed_feet".to_owned();
/// let object_xjs = Object::new(&mut store, ambitious_eyes);
/// let cardinality_ykk = Cardinality::test_default(&mut store);
/// let highfalutin_moon = "evasive_fly".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_tkz, &object_xjs, &cardinality_ykk, highfalutin_moon);
/// let referrer_thx = sarzak_maybe_get_many_r_froms_across_r11!(conditionality_tkz, store);
///
/// assert!(referrer_thx.iter().find(|&x| **x == referrer).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_r_froms_across_r11 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referrer()
            .filter_map(|z| if z.1.conditionality == $input.get_id() { Some(z.1) } else { None })
            .collect::<Vec<&Referrer>>()
            // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_many_r_froms_across_r11;

/// Macro to traverse [`State`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R18_
///
/// This macro expects a &[`State`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::State
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::State;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r18;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let blushing_copper = "billowy_expansion".to_owned();
/// let object_xzg = Object::new(&mut store, blushing_copper);
/// let neighborly_eggs = "whispering_verse".to_owned();
///
/// let state = State::new(&mut store, &object_xzg, neighborly_eggs);
///
/// let object_ujb = sarzak_get_one_obj_across_r18!(state, store);
/// assert_eq!(&object_xzg, object_ujb);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r18 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r18;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`State`][ðŸ¦ž], via _R18(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`State`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::State
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::State;
/// # use sarzak::sarzak_maybe_get_many_ss_across_r18;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let fearful_jam = "terrible_stew".to_owned();
/// let object_jfz = Object::new(&mut store, fearful_jam);
/// let magenta_plot = "absorbed_wool".to_owned();
///
/// let state = State::new(&mut store, &object_jfz, magenta_plot);
/// let state_xrc = sarzak_maybe_get_many_ss_across_r18!(object_jfz, store);
///
/// assert!(state_xrc.iter().find(|&x| **x == state).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_ss_across_r18 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_state()
            .filter_map(|z| if z.1.obj_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&State>>()
            // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_many_ss_across_r18;

/// Macro to traverse [`State`][ðŸ¦€] âž¡ [`Event`][ðŸ¦ž], across [`AcknowledgedEvent`][ðŸ¦‘] via _R20_
///
/// This macro expects a &[`State`][ðŸ¦€], and returns a &[`Event`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ðŸ¦€]: crate::sarzak::types::State
/// [ðŸ¦ž]: crate::sarzak::types::Event
/// [ðŸ¦‘]: crate::sarzak::types::AcknowledgedEvent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::State;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Event;
/// # use sarzak::sarzak::AcknowledgedEvent;
/// # use sarzak::sarzak_get_many_e_across_r20;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let lavish_sisters = "woebegone_walk".to_owned();
/// let object_ytw = Object::new(&mut store, lavish_sisters);
/// let aware_toothbrush = "undesirable_dinner".to_owned();
/// let state_rex = State::new(&mut store, &object_ytw, aware_toothbrush);
/// let motionless_cup = "profuse_soap".to_owned();
/// let object_spa = Object::new(&mut store, motionless_cup);
/// let laughable_plants = "historical_home".to_owned();
/// let event_smg = Event::new(&mut store, &object_spa, laughable_plants);
/// let acknowledged_event = AcknowledgedEvent::new(&mut store, &state_rex, &event_smg);
///
/// let event_bos = sarzak_get_many_e_across_r20!(state_rex, store);
/// assert!(event_bos.iter().find(|&x| **x == event_smg).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_many_e_across_r20 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_many
        $store
            .iter_acknowledged_event()
            .filter(|a| a.1.state_id == $input.id)
            .map(|a| $store.exhume_event(&a.1.event_id).unwrap())
            .collect::<Vec<&Event>>()
    }};
}
pub use sarzak_get_many_e_across_r20;

/// Macro to traverse [`Event`][ðŸ¦€] âž¡ [`State`][ðŸ¦ž], across [`AcknowledgedEvent`][ðŸ¦‘] via _R20_
///
/// This macro expects a &[`Event`][ðŸ¦€], and returns a &[`State`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ðŸ¦€]: crate::sarzak::types::Event
/// [ðŸ¦ž]: crate::sarzak::types::State
/// [ðŸ¦‘]: crate::sarzak::types::AcknowledgedEvent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::AcknowledgedEvent;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::State;
/// # use sarzak::sarzak::Event;
/// # use sarzak::sarzak_get_many_s_across_r20;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let precious_prison = "warm_dolls".to_owned();
/// let object_pvt = Object::new(&mut store, precious_prison);
/// let four_system = "needy_run".to_owned();
/// let state_qkb = State::new(&mut store, &object_pvt, four_system);
/// let empty_angle = "defeated_trouble".to_owned();
/// let object_abh = Object::new(&mut store, empty_angle);
/// let homeless_rice = "swanky_crook".to_owned();
/// let event_zmi = Event::new(&mut store, &object_abh, homeless_rice);
/// let acknowledged_event = AcknowledgedEvent::new(&mut store, &state_qkb, &event_zmi);
///
/// let state_elj = sarzak_get_many_s_across_r20!(event_zmi, store);
/// assert!(state_elj.iter().find(|&x| **x == state_qkb).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_many_s_across_r20 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_many
        $store
            .iter_acknowledged_event()
            .filter(|a| a.1.event_id == $input.id)
            .map(|a| $store.exhume_state(&a.1.state_id).unwrap())
            .collect::<Vec<&State>>()
    }};
}
pub use sarzak_get_many_s_across_r20;

/// Macro to traverse [`Associative`][ðŸ¦€] âž¡ [`OtherSide`][ðŸ¦ž], via _R22_
///
/// This macro expects a &[`Associative`][ðŸ¦€], and returns a &[`OtherSide`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Associative
/// [ðŸ¦ž]: crate::sarzak::types::OtherSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak_get_one_r_oth_across_r22;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let understood_sticks = "glorious_sea".to_owned();
/// let object_mub = Object::new(&mut store, understood_sticks);
/// let one_side_zdo = OneSide::new(&mut store, &object_mub);
/// let waggish_seed = "capable_truck".to_owned();
/// let object_zph = Object::new(&mut store, waggish_seed);
/// let other_side_sdr = OtherSide::new(&mut store, &object_zph);
/// let swanky_wheel = "scattered_amusement".to_owned();
/// let object_spx = Object::new(&mut store, swanky_wheel);
/// let associative_side_nuz = AssociativeSide::new(&mut store, &object_spx);
///
/// let associative = Associative::new(&mut store, &one_side_zdo, &other_side_sdr, &associative_side_nuz, 42);
///
/// let other_side_mky = sarzak_get_one_r_oth_across_r22!(associative, store);
/// assert_eq!(&other_side_sdr, other_side_mky);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_oth_across_r22 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_other_side(&$input.other).unwrap()
    }};
}
pub use sarzak_get_one_r_oth_across_r22;

/// Macro to traverse [`OtherSide`][ðŸ¦€] âž¡ [`Associative`][ðŸ¦ž], via _R22_
///
/// This macro expects a &[`OtherSide`][ðŸ¦€], and returns a &[`Associative`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::OtherSide
/// [ðŸ¦ž]: crate::sarzak::types::Associative
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak_get_one_r_assoc_across_r22;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let pastoral_hill = "overconfident_clam".to_owned();
/// let object_hvo = Object::new(&mut store, pastoral_hill);
/// let one_side_kni = OneSide::new(&mut store, &object_hvo);
/// let groovy_plants = "rabid_brick".to_owned();
/// let object_pgk = Object::new(&mut store, groovy_plants);
/// let other_side_ngw = OtherSide::new(&mut store, &object_pgk);
/// let precious_organization = "fumbling_body".to_owned();
/// let object_zhv = Object::new(&mut store, precious_organization);
/// let associative_side_xjn = AssociativeSide::new(&mut store, &object_zhv);
///
/// let associative = Associative::new(&mut store, &one_side_kni, &other_side_ngw, &associative_side_xjn, 42);
/// let associative_uhz = sarzak_get_one_r_assoc_across_r22!(other_side_ngw, store);
///
/// assert_eq!(&associative, associative_uhz);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_assoc_across_r22 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_associative()
            .find(|z| z.1.other == $input.id)
            .map(|z| z.1)
            .unwrap()
            // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_get_one_r_assoc_across_r22;

/// Macro to traverse [`Associative`][ðŸ¦€] âž¡ [`OneSide`][ðŸ¦ž], via _R23_
///
/// This macro expects a &[`Associative`][ðŸ¦€], and returns a &[`OneSide`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Associative
/// [ðŸ¦ž]: crate::sarzak::types::OneSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak_get_one_r_one_across_r23;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let descriptive_wind = "unsuitable_grandfather".to_owned();
/// let object_vje = Object::new(&mut store, descriptive_wind);
/// let one_side_tro = OneSide::new(&mut store, &object_vje);
/// let deep_cent = "mere_rain".to_owned();
/// let object_loe = Object::new(&mut store, deep_cent);
/// let other_side_ran = OtherSide::new(&mut store, &object_loe);
/// let neat_railway = "low_step".to_owned();
/// let object_oou = Object::new(&mut store, neat_railway);
/// let associative_side_nog = AssociativeSide::new(&mut store, &object_oou);
///
/// let associative = Associative::new(&mut store, &one_side_tro, &other_side_ran, &associative_side_nog, 42);
///
/// let one_side_qqa = sarzak_get_one_r_one_across_r23!(associative, store);
/// assert_eq!(&one_side_tro, one_side_qqa);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_one_across_r23 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_one_side(&$input.one).unwrap()
    }};
}
pub use sarzak_get_one_r_one_across_r23;

/// Macro to traverse [`OneSide`][ðŸ¦€] âž¡ [`Associative`][ðŸ¦ž], via _R23_
///
/// This macro expects a &[`OneSide`][ðŸ¦€], and returns a &[`Associative`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::OneSide
/// [ðŸ¦ž]: crate::sarzak::types::Associative
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak_get_one_r_assoc_across_r23;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let cold_basket = "wide_mass".to_owned();
/// let object_zpl = Object::new(&mut store, cold_basket);
/// let one_side_unw = OneSide::new(&mut store, &object_zpl);
/// let lazy_kick = "typical_shock".to_owned();
/// let object_hus = Object::new(&mut store, lazy_kick);
/// let other_side_dxf = OtherSide::new(&mut store, &object_hus);
/// let gainful_control = "angry_amusement".to_owned();
/// let object_cpe = Object::new(&mut store, gainful_control);
/// let associative_side_wvw = AssociativeSide::new(&mut store, &object_cpe);
///
/// let associative = Associative::new(&mut store, &one_side_unw, &other_side_dxf, &associative_side_wvw, 42);
/// let associative_got = sarzak_get_one_r_assoc_across_r23!(one_side_unw, store);
///
/// assert_eq!(&associative, associative_got);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_assoc_across_r23 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_associative()
            .find(|z| z.1.one == $input.id)
            .map(|z| z.1)
            .unwrap()
            // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_get_one_r_assoc_across_r23;

/// Macro to traverse [`Supertype`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R14_
///
/// This macro expects a &[`Supertype`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Supertype
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r14;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let heavy_bears = "lying_lizards".to_owned();
/// let object_hoz = Object::new(&mut store, heavy_bears);
///
/// let supertype = Supertype::new(&mut store, &object_hoz);
///
/// let object_hra = sarzak_get_one_obj_across_r14!(supertype, store);
/// assert_eq!(&object_hoz, object_hra);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r14 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r14;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Supertype`][ðŸ¦ž], via _R14(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Supertype`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Supertype
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_one_r_sup_across_r14;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let rhetorical_plants = "tan_metal".to_owned();
/// let object_pnl = Object::new(&mut store, rhetorical_plants);
///
/// let supertype = Supertype::new(&mut store, &object_pnl);
/// let supertype_zxt = sarzak_maybe_get_one_r_sup_across_r14!(object_pnl, store);
///
/// assert_eq!(Some(&supertype), supertype_zxt);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_sup_across_r14 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_supertype()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
            // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_one_r_sup_across_r14;

/// Macro to traverse [`Associative`][ðŸ¦€] âž¡ [`AssociativeSide`][ðŸ¦ž], via _R21_
///
/// This macro expects a &[`Associative`][ðŸ¦€], and returns a &[`AssociativeSide`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Associative
/// [ðŸ¦ž]: crate::sarzak::types::AssociativeSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak_get_one_r_ass_across_r21;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let few_poison = "quixotic_acoustics".to_owned();
/// let object_rif = Object::new(&mut store, few_poison);
/// let one_side_uyt = OneSide::new(&mut store, &object_rif);
/// let happy_scissors = "weak_nerve".to_owned();
/// let object_tpq = Object::new(&mut store, happy_scissors);
/// let other_side_kcf = OtherSide::new(&mut store, &object_tpq);
/// let wet_wire = "forgetful_library".to_owned();
/// let object_aeq = Object::new(&mut store, wet_wire);
/// let associative_side_jyv = AssociativeSide::new(&mut store, &object_aeq);
///
/// let associative = Associative::new(&mut store, &one_side_uyt, &other_side_kcf, &associative_side_jyv, 42);
///
/// let associative_side_bso = sarzak_get_one_r_ass_across_r21!(associative, store);
/// assert_eq!(&associative_side_jyv, associative_side_bso);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_ass_across_r21 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_associative_side(&$input.from).unwrap()
    }};
}
pub use sarzak_get_one_r_ass_across_r21;

/// Macro to traverse [`AssociativeSide`][ðŸ¦€] âž¡ [`Associative`][ðŸ¦ž], via _R21_
///
/// This macro expects a &[`AssociativeSide`][ðŸ¦€], and returns a &[`Associative`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::AssociativeSide
/// [ðŸ¦ž]: crate::sarzak::types::Associative
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak_get_one_r_assoc_across_r21;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let efficient_note = "sincere_title".to_owned();
/// let object_xmt = Object::new(&mut store, efficient_note);
/// let one_side_yns = OneSide::new(&mut store, &object_xmt);
/// let safe_color = "nutty_record".to_owned();
/// let object_pxq = Object::new(&mut store, safe_color);
/// let other_side_fxq = OtherSide::new(&mut store, &object_pxq);
/// let talented_step = "political_voice".to_owned();
/// let object_udk = Object::new(&mut store, talented_step);
/// let associative_side_qth = AssociativeSide::new(&mut store, &object_udk);
///
/// let associative = Associative::new(&mut store, &one_side_yns, &other_side_fxq, &associative_side_qth, 42);
/// let associative_mdw = sarzak_get_one_r_assoc_across_r21!(associative_side_qth, store);
///
/// assert_eq!(&associative, associative_mdw);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_assoc_across_r21 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_associative()
            .find(|z| z.1.from == $input.id)
            .map(|z| z.1)
            .unwrap()
            // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_get_one_r_assoc_across_r21;

/// Macro to traverse [`Referrer`][ðŸ¦€] âž¡ [`Cardinality`][ðŸ¦ž], via _R9_
///
/// This macro expects a &[`Referrer`][ðŸ¦€], and returns a &[`Cardinality`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referrer
/// [ðŸ¦ž]: crate::sarzak::types::Cardinality
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak_get_one_card_across_r9;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_jks = Conditionality::test_default(&mut store);
/// let tough_cherry = "three_magic".to_owned();
/// let object_xwd = Object::new(&mut store, tough_cherry);
/// let cardinality_sxa = Cardinality::test_default(&mut store);
/// let poor_fruit = "hard_to_find_representative".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_jks, &object_xwd, &cardinality_sxa, poor_fruit);
///
/// let cardinality_atp = sarzak_get_one_card_across_r9!(referrer, store);
/// assert_eq!(&cardinality_sxa, cardinality_atp);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_card_across_r9 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_cardinality(&$input.cardinality).unwrap()
    }};
}
pub use sarzak_get_one_card_across_r9;

/// Macro to traverse [`Cardinality`][ðŸ¦€] âž¡ [`Referrer`][ðŸ¦ž], via _R9(c)_
///
/// This macro expects a &[`Cardinality`][ðŸ¦€], and returns an Option<&[`Referrer`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Cardinality
/// [ðŸ¦ž]: crate::sarzak::types::Referrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak_maybe_get_many_r_froms_across_r9;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_rap = Conditionality::test_default(&mut store);
/// let psychedelic_kite = "unruly_girl".to_owned();
/// let object_iiw = Object::new(&mut store, psychedelic_kite);
/// let cardinality_lyk = Cardinality::test_default(&mut store);
/// let earthy_channel = "roomy_airport".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_rap, &object_iiw, &cardinality_lyk, earthy_channel);
/// let referrer_kwr = sarzak_maybe_get_many_r_froms_across_r9!(cardinality_lyk, store);
///
/// assert!(referrer_kwr.iter().find(|&x| **x == referrer).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_r_froms_across_r9 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referrer()
            .filter_map(|z| if z.1.cardinality == $input.get_id() { Some(z.1) } else { None })
            .collect::<Vec<&Referrer>>()
            // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_many_r_froms_across_r9;

/// Macro to traverse [`Attribute`][ðŸ¦€] âž¡ [`Type`][ðŸ¦ž], via _R2_
///
/// This macro expects a &[`Attribute`][ðŸ¦€], and returns a &[`Type`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Attribute
/// [ðŸ¦ž]: crate::sarzak::types::Type
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Type;
/// # use sarzak::sarzak::Attribute;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_t_across_r2;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let funny_suggestion = "abnormal_morning".to_owned();
/// let object = Object::new(&mut store, funny_suggestion);
/// let type_uae = Type::test_default(&mut store);
/// let placid_invention = "illustrious_advice".to_owned();
///
/// let attribute = Attribute::new(&mut store, Some(&object), &type_uae, placid_invention);
///
/// let type_tyt = sarzak_get_one_t_across_r2!(attribute, store);
/// assert_eq!(&type_uae, type_tyt);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_t_across_r2 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_ty(&$input.ty).unwrap()
    }};
}
pub use sarzak_get_one_t_across_r2;

/// Macro to traverse [`Type`][ðŸ¦€] âž¡ [`Attribute`][ðŸ¦ž], via _R2_
///
/// This macro expects a &[`Type`][ðŸ¦€], and returns a &[`Attribute`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Type
/// [ðŸ¦ž]: crate::sarzak::types::Attribute
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Attribute;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Type;
/// # use sarzak::sarzak_get_one_a_across_r2;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let discreet_number = "jumbled_paste".to_owned();
/// let object = Object::new(&mut store, discreet_number);
/// let type_xaz = Type::test_default(&mut store);
/// let dramatic_meeting = "lucky_bun".to_owned();
///
/// let attribute = Attribute::new(&mut store, Some(&object), &type_xaz, dramatic_meeting);
/// let attribute_agc = sarzak_get_one_a_across_r2!(type_xaz, store);
///
/// assert_eq!(&attribute, attribute_agc);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_a_across_r2 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_attribute()
            .find(|z| z.1.ty == $input.get_id())
            .map(|z| z.1)
            .unwrap()
            // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_get_one_a_across_r2;

/// Macro to traverse [`Binary`][ðŸ¦€] âž¡ [`Referrer`][ðŸ¦ž], via _R6_
///
/// This macro expects a &[`Binary`][ðŸ¦€], and returns a &[`Referrer`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Binary
/// [ðŸ¦ž]: crate::sarzak::types::Referrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::sarzak_get_one_r_from_across_r6;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_fkh = Conditionality::test_default(&mut store);
/// let pretty_wine = "elfin_hall".to_owned();
/// let object_msw = Object::new(&mut store, pretty_wine);
/// let cardinality_bey = Cardinality::test_default(&mut store);
/// let referent_fog = Referent::new(&mut store, &conditionality_fkh, &object_msw, &cardinality_bey);
/// let conditionality_svu = Conditionality::test_default(&mut store);
/// let yellow_theory = "worthless_money".to_owned();
/// let object_dbf = Object::new(&mut store, yellow_theory);
/// let cardinality_kpo = Cardinality::test_default(&mut store);
/// let grateful_river = "tidy_noise".to_owned();
/// let referrer_plb = Referrer::new(&mut store, &conditionality_svu, &object_dbf, &cardinality_kpo, grateful_river);
///
/// let binary = Binary::new(&mut store, &referent_fog, &referrer_plb, 42);
///
/// let referrer_yfz = sarzak_get_one_r_from_across_r6!(binary, store);
/// assert_eq!(&referrer_plb, referrer_yfz);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_from_across_r6 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_referrer(&$input.from).unwrap()
    }};
}
pub use sarzak_get_one_r_from_across_r6;

/// Macro to traverse [`Referrer`][ðŸ¦€] âž¡ [`Binary`][ðŸ¦ž], via _R6_
///
/// This macro expects a &[`Referrer`][ðŸ¦€], and returns a &[`Binary`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referrer
/// [ðŸ¦ž]: crate::sarzak::types::Binary
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak_get_one_r_bin_across_r6;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_svg = Conditionality::test_default(&mut store);
/// let hellish_lunch = "makeshift_balance".to_owned();
/// let object_azm = Object::new(&mut store, hellish_lunch);
/// let cardinality_ltv = Cardinality::test_default(&mut store);
/// let referent_gfm = Referent::new(&mut store, &conditionality_svg, &object_azm, &cardinality_ltv);
/// let conditionality_nwx = Conditionality::test_default(&mut store);
/// let faulty_parent = "possessive_bomb".to_owned();
/// let object_gef = Object::new(&mut store, faulty_parent);
/// let cardinality_zip = Cardinality::test_default(&mut store);
/// let wanting_dog = "noisy_steel".to_owned();
/// let referrer_xzo = Referrer::new(&mut store, &conditionality_nwx, &object_gef, &cardinality_zip, wanting_dog);
///
/// let binary = Binary::new(&mut store, &referent_gfm, &referrer_xzo, 42);
/// let binary_ric = sarzak_get_one_r_bin_across_r6!(referrer_xzo, store);
///
/// assert_eq!(&binary, binary_ric);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_bin_across_r6 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_binary()
            .find(|z| z.1.from == $input.id)
            .map(|z| z.1)
            .unwrap()
            // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_get_one_r_bin_across_r6;

/// Macro to traverse [`Event`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R19_
///
/// This macro expects a &[`Event`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Event
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Event;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r19;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let superficial_ducks = "hungry_price".to_owned();
/// let object_qii = Object::new(&mut store, superficial_ducks);
/// let violent_territory = "erect_force".to_owned();
///
/// let event = Event::new(&mut store, &object_qii, violent_territory);
///
/// let object_ofg = sarzak_get_one_obj_across_r19!(event, store);
/// assert_eq!(&object_qii, object_ofg);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r19 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r19;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Event`][ðŸ¦ž], via _R19(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Event`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Event
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Event;
/// # use sarzak::sarzak_maybe_get_many_es_across_r19;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let terrific_bedroom = "little_beef".to_owned();
/// let object_ehy = Object::new(&mut store, terrific_bedroom);
/// let habitual_egg = "stingy_leaf".to_owned();
///
/// let event = Event::new(&mut store, &object_ehy, habitual_egg);
/// let event_fro = sarzak_maybe_get_many_es_across_r19!(object_ehy, store);
///
/// assert!(event_fro.iter().find(|&x| **x == event).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_es_across_r19 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_event()
            .filter_map(|z| if z.1.obj_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&Event>>()
            // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_many_es_across_r19;

/// Macro to traverse [`Attribute`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R1(c)_
///
/// This macro expects a &[`Attribute`][ðŸ¦€], and returns an Option<&[`Object`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Attribute
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Type;
/// # use sarzak::sarzak::Attribute;
/// # use sarzak::sarzak_maybe_get_one_obj_across_r1;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let demonic_word = "crooked_pig".to_owned();
/// let object = Object::new(&mut store, demonic_word);
/// let type_pup = Type::test_default(&mut store);
/// let offbeat_adjustment = "awesome_rod".to_owned();
/// let lazy_trick = "woebegone_skate".to_owned();
///
/// let attribute = Attribute::new(&mut store, Some(&object), &type_pup, offbeat_adjustment);
///
/// let object_elx = sarzak_maybe_get_one_obj_across_r1!(attribute, store);
/// assert_eq!(Some(&object), object_elx);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_obj_across_r1 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_conditional
        match &$input.obj_id {
            Some(i) => $store.exhume_object(i),
            None => None,
        }
    }};
}
pub use sarzak_maybe_get_one_obj_across_r1;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Attribute`][ðŸ¦ž], via _R1_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns a &[`Attribute`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Attribute
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Attribute;
/// # use sarzak::sarzak::Type;
/// # use sarzak::sarzak_get_many_as_across_r1;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let numerous_smell = "makeshift_money".to_owned();
/// let quixotic_fairies = "steep_test".to_owned();
/// let object = Object::new(&mut store, quixotic_fairies);
/// let type_ych = Type::test_default(&mut store);
/// let eight_bike = "jolly_salt".to_owned();
///
/// let attribute = Attribute::new(&mut store, Some(&object), &type_ych, eight_bike);
///
/// let attribute_xpk = sarzak_get_many_as_across_r1!(object, store);
/// assert!(attribute_xpk.iter().find(|&x| **x == attribute).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_many_as_across_r1 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_attribute()
            .filter_map(|z| if z.1.obj_id == Some($input.id) { Some(z.1) } else { None })
            .collect::<Vec<&Attribute>>()
            // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_get_many_as_across_r1;

/// Macro to traverse [`Subtype`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R15_
///
/// This macro expects a &[`Subtype`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Subtype
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Subtype;
/// # use sarzak::sarzak_get_one_obj_across_r15;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let billowy_cave = "flimsy_control".to_owned();
/// let object_xvv = Object::new(&mut store, billowy_cave);
///
/// let subtype = Subtype::new(&mut store, &object_xvv);
///
/// let object_ghn = sarzak_get_one_obj_across_r15!(subtype, store);
/// assert_eq!(&object_xvv, object_ghn);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r15 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r15;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Subtype`][ðŸ¦ž], via _R15(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Subtype`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Subtype
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Subtype;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_one_r_sub_across_r15;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let frequent_knife = "snotty_pancake".to_owned();
/// let object_mfp = Object::new(&mut store, frequent_knife);
///
/// let subtype = Subtype::new(&mut store, &object_mfp);
/// let subtype_ohh = sarzak_maybe_get_one_r_sub_across_r15!(object_mfp, store);
///
/// assert_eq!(Some(&subtype), subtype_ohh);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_sub_across_r15 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_subtype()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
            // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_one_r_sub_across_r15;

/// Macro to traverse [`OtherSide`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R25_
///
/// This macro expects a &[`OtherSide`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::OtherSide
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak_get_one_obj_across_r25;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let outgoing_calendar = "fascinated_pail".to_owned();
/// let object_kjc = Object::new(&mut store, outgoing_calendar);
///
/// let other_side = OtherSide::new(&mut store, &object_kjc);
///
/// let object_ldi = sarzak_get_one_obj_across_r25!(other_side, store);
/// assert_eq!(&object_kjc, object_ldi);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r25 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r25;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`OtherSide`][ðŸ¦ž], via _R25(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`OtherSide`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::OtherSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak_maybe_get_one_r_oth_across_r25;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let purple_hat = "few_women".to_owned();
/// let object_teu = Object::new(&mut store, purple_hat);
///
/// let other_side = OtherSide::new(&mut store, &object_teu);
/// let other_side_roq = sarzak_maybe_get_one_r_oth_across_r25!(object_teu, store);
///
/// assert_eq!(Some(&other_side), other_side_roq);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_oth_across_r25 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_other_side()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
            // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_one_r_oth_across_r25;

/// Macro to traverse [`Binary`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R5_
///
/// This macro expects a &[`Binary`][ðŸ¦€], and returns a &[`Referent`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Binary
/// [ðŸ¦ž]: crate::sarzak::types::Referent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Binary;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak_get_one_r_to_across_r5;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_sqq = Conditionality::test_default(&mut store);
/// let romantic_maid = "utter_love".to_owned();
/// let object_qzx = Object::new(&mut store, romantic_maid);
/// let cardinality_axw = Cardinality::test_default(&mut store);
/// let referent_cdq = Referent::new(&mut store, &conditionality_sqq, &object_qzx, &cardinality_axw);
/// let conditionality_qin = Conditionality::test_default(&mut store);
/// let likeable_theory = "probable_stove".to_owned();
/// let object_net = Object::new(&mut store, likeable_theory);
/// let cardinality_oic = Cardinality::test_default(&mut store);
/// let aloof_army = "smart_pizzas".to_owned();
/// let referrer_dgy = Referrer::new(&mut store, &conditionality_qin, &object_net, &cardinality_oic, aloof_army);
///
/// let binary = Binary::new(&mut store, &referent_cdq, &referrer_dgy, 42);
///
/// let referent_uma = sarzak_get_one_r_to_across_r5!(binary, store);
/// assert_eq!(&referent_cdq, referent_uma);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_to_across_r5 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_referent(&$input.to).unwrap()
    }};
}
pub use sarzak_get_one_r_to_across_r5;

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`Binary`][ðŸ¦ž], via _R5_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`Binary`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referent
/// [ðŸ¦ž]: crate::sarzak::types::Binary
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::sarzak_get_one_r_bin_across_r5;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_uok = Conditionality::test_default(&mut store);
/// let befitting_honey = "expensive_key".to_owned();
/// let object_jeq = Object::new(&mut store, befitting_honey);
/// let cardinality_yus = Cardinality::test_default(&mut store);
/// let referent_ome = Referent::new(&mut store, &conditionality_uok, &object_jeq, &cardinality_yus);
/// let conditionality_dbj = Conditionality::test_default(&mut store);
/// let plant_badge = "utter_river".to_owned();
/// let object_fph = Object::new(&mut store, plant_badge);
/// let cardinality_qqw = Cardinality::test_default(&mut store);
/// let instinctive_note = "dynamic_cub".to_owned();
/// let referrer_pdx = Referrer::new(&mut store, &conditionality_dbj, &object_fph, &cardinality_qqw, instinctive_note);
///
/// let binary = Binary::new(&mut store, &referent_ome, &referrer_pdx, 42);
/// let binary_cwv = sarzak_get_one_r_bin_across_r5!(referent_ome, store);
///
/// assert_eq!(&binary, binary_cwv);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_bin_across_r5 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_binary()
            .find(|z| z.1.to == $input.id)
            .map(|z| z.1)
            .unwrap()
            // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_get_one_r_bin_across_r5;
