//! Macros for navigating the "Sarzak" domain
//!
//! # Generated Code -- edit _with care_.
//!
//! Don't mess with anything between `{"magic":"îž¨","kind":"CriticalBlockBegin"}`
//! and `{"magic":"îž¨","kind":"CriticalBlockEnd"}`. Otherwise, you should be free
//! to go wild. Happy hacking!
//!
//! Use the following invocation to reproduce:
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
//! ```shell
//!  sarzak gen
//! ```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
// {"magic":"îž¨","version":"0.5.0"}

/// Macro to traverse [`Referrer`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R17_
///
/// This macro expects a &[`Referrer`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referrer
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak_get_one_obj_across_r17;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_xqy = Conditionality::test_default(&mut store);
/// let spotless_head = "unsuitable_things".to_owned();
/// let object_prq = Object::new(&mut store, spotless_head);
/// let cardinality_wup = Cardinality::test_default(&mut store);
/// let nosy_stop = "annoying_account".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_xqy, &object_prq, &cardinality_wup, nosy_stop);
///
/// let object_oku = sarzak_get_one_obj_across_r17!(referrer, store);
/// assert_eq!(&object_prq, object_oku);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r17 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r17;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Referrer`][ðŸ¦ž], via _R17(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Referrer`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Referrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_one_r_from_across_r17;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_gma = Conditionality::test_default(&mut store);
/// let jaded_branch = "grumpy_line".to_owned();
/// let object_ucx = Object::new(&mut store, jaded_branch);
/// let cardinality_opc = Cardinality::test_default(&mut store);
/// let plastic_front = "wanting_pear".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_gma, &object_ucx, &cardinality_opc, plastic_front);
/// let referrer_hoc = sarzak_maybe_get_one_r_from_across_r17!(object_ucx, store);
///
/// assert_eq!(Some(&referrer), referrer_hoc);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_from_across_r17 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_referrer()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_one_r_from_across_r17;

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`Cardinality`][ðŸ¦ž], via _R8_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`Cardinality`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referent
/// [ðŸ¦ž]: crate::sarzak::types::Cardinality
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_card_across_r8;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_qhv = Conditionality::test_default(&mut store);
/// let useless_knee = "selective_sea".to_owned();
/// let object_ifj = Object::new(&mut store, useless_knee);
/// let cardinality_jxt = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_qhv, &object_ifj, &cardinality_jxt);
///
/// let cardinality_xpa = sarzak_get_one_card_across_r8!(referent, store);
/// assert_eq!(&cardinality_jxt, cardinality_xpa);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_card_across_r8 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_cardinality(&$input.cardinality).unwrap()
    }};
}
pub use sarzak_get_one_card_across_r8;

/// Macro to traverse [`Cardinality`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R8(c)_
///
/// This macro expects a &[`Cardinality`][ðŸ¦€], and returns an Option<&[`Referent`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Cardinality
/// [ðŸ¦ž]: crate::sarzak::types::Referent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak_maybe_get_many_r_tos_across_r8;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_fwm = Conditionality::test_default(&mut store);
/// let wooden_opinion = "outrageous_addition".to_owned();
/// let object_ewh = Object::new(&mut store, wooden_opinion);
/// let cardinality_rtk = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_fwm, &object_ewh, &cardinality_rtk);
/// let referent_kkf = sarzak_maybe_get_many_r_tos_across_r8!(cardinality_rtk, store);
///
/// assert!(referent_kkf.iter().find(|&x| **x == referent).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_r_tos_across_r8 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referent()
            .filter_map(|z| {
                if z.1.cardinality == $input.get_id() {
                    Some(z.1)
                } else {
                    None
                }
            })
            .collect::<Vec<&Referent>>()
        // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_many_r_tos_across_r8;

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R16_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referent
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r16;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_ijm = Conditionality::test_default(&mut store);
/// let abundant_cable = "taboo_pain".to_owned();
/// let object_aoe = Object::new(&mut store, abundant_cable);
/// let cardinality_htk = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_ijm, &object_aoe, &cardinality_htk);
///
/// let object_bup = sarzak_get_one_obj_across_r16!(referent, store);
/// assert_eq!(&object_aoe, object_bup);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r16 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r16;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R16(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Referent`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Referent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak_maybe_get_one_r_to_across_r16;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_kzj = Conditionality::test_default(&mut store);
/// let oval_bike = "hollow_galley".to_owned();
/// let object_sji = Object::new(&mut store, oval_bike);
/// let cardinality_fqg = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_kzj, &object_sji, &cardinality_fqg);
/// let referent_ekt = sarzak_maybe_get_one_r_to_across_r16!(object_sji, store);
///
/// assert_eq!(Some(&referent), referent_ekt);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_to_across_r16 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_referent()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_one_r_to_across_r16;

/// Macro to traverse [`OneSide`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R24_
///
/// This macro expects a &[`OneSide`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::OneSide
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r24;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let puny_creature = "periodic_eyes".to_owned();
/// let object_gis = Object::new(&mut store, puny_creature);
///
/// let one_side = OneSide::new(&mut store, &object_gis);
///
/// let object_kcq = sarzak_get_one_obj_across_r24!(one_side, store);
/// assert_eq!(&object_gis, object_kcq);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r24 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r24;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`OneSide`][ðŸ¦ž], via _R24(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`OneSide`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::OneSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_one_r_one_across_r24;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let outgoing_canvas = "slippery_toothpaste".to_owned();
/// let object_bpc = Object::new(&mut store, outgoing_canvas);
///
/// let one_side = OneSide::new(&mut store, &object_bpc);
/// let one_side_gup = sarzak_maybe_get_one_r_one_across_r24!(object_bpc, store);
///
/// assert_eq!(Some(&one_side), one_side_gup);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_one_across_r24 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_one_side()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_one_r_one_across_r24;

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`Conditionality`][ðŸ¦ž], via _R12_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`Conditionality`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referent
/// [ðŸ¦ž]: crate::sarzak::types::Conditionality
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak_get_one_cond_across_r12;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_ufk = Conditionality::test_default(&mut store);
/// let moaning_ink = "guarded_smash".to_owned();
/// let object_ijd = Object::new(&mut store, moaning_ink);
/// let cardinality_wpc = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_ufk, &object_ijd, &cardinality_wpc);
///
/// let conditionality_lqa = sarzak_get_one_cond_across_r12!(referent, store);
/// assert_eq!(&conditionality_ufk, conditionality_lqa);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_cond_across_r12 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store
            .exhume_conditionality(&$input.conditionality)
            .unwrap()
    }};
}
pub use sarzak_get_one_cond_across_r12;

/// Macro to traverse [`Conditionality`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R12(c)_
///
/// This macro expects a &[`Conditionality`][ðŸ¦€], and returns an Option<&[`Referent`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Conditionality
/// [ðŸ¦ž]: crate::sarzak::types::Referent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_many_r_tos_across_r12;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_ilw = Conditionality::test_default(&mut store);
/// let rabid_cherry = "cute_back".to_owned();
/// let object_esv = Object::new(&mut store, rabid_cherry);
/// let cardinality_xug = Cardinality::test_default(&mut store);
///
/// let referent = Referent::new(&mut store, &conditionality_ilw, &object_esv, &cardinality_xug);
/// let referent_xhe = sarzak_maybe_get_many_r_tos_across_r12!(conditionality_ilw, store);
///
/// assert!(referent_xhe.iter().find(|&x| **x == referent).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_r_tos_across_r12 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referent()
            .filter_map(|z| {
                if z.1.conditionality == $input.get_id() {
                    Some(z.1)
                } else {
                    None
                }
            })
            .collect::<Vec<&Referent>>()
        // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_many_r_tos_across_r12;

/// Macro to traverse [`AssociativeSide`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R26_
///
/// This macro expects a &[`AssociativeSide`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::AssociativeSide
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r26;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let symptomatic_rock = "mushy_tongue".to_owned();
/// let object_obx = Object::new(&mut store, symptomatic_rock);
///
/// let associative_side = AssociativeSide::new(&mut store, &object_obx);
///
/// let object_nmw = sarzak_get_one_obj_across_r26!(associative_side, store);
/// assert_eq!(&object_obx, object_nmw);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r26 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r26;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`AssociativeSide`][ðŸ¦ž], via _R26(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`AssociativeSide`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::AssociativeSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_one_r_ass_across_r26;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let mushy_middle = "zany_nerve".to_owned();
/// let object_vkv = Object::new(&mut store, mushy_middle);
///
/// let associative_side = AssociativeSide::new(&mut store, &object_vkv);
/// let associative_side_ycr = sarzak_maybe_get_one_r_ass_across_r26!(object_vkv, store);
///
/// assert_eq!(Some(&associative_side), associative_side_ycr);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_ass_across_r26 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_side()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_one_r_ass_across_r26;

/// Macro to traverse [`Referrer`][ðŸ¦€] âž¡ [`Conditionality`][ðŸ¦ž], via _R11_
///
/// This macro expects a &[`Referrer`][ðŸ¦€], and returns a &[`Conditionality`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referrer
/// [ðŸ¦ž]: crate::sarzak::types::Conditionality
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak_get_one_cond_across_r11;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_tds = Conditionality::test_default(&mut store);
/// let many_polish = "unusual_hour".to_owned();
/// let object_csr = Object::new(&mut store, many_polish);
/// let cardinality_mjk = Cardinality::test_default(&mut store);
/// let royal_mailbox = "meaty_drink".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_tds, &object_csr, &cardinality_mjk, royal_mailbox);
///
/// let conditionality_uys = sarzak_get_one_cond_across_r11!(referrer, store);
/// assert_eq!(&conditionality_tds, conditionality_uys);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_cond_across_r11 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store
            .exhume_conditionality(&$input.conditionality)
            .unwrap()
    }};
}
pub use sarzak_get_one_cond_across_r11;

/// Macro to traverse [`Conditionality`][ðŸ¦€] âž¡ [`Referrer`][ðŸ¦ž], via _R11(c)_
///
/// This macro expects a &[`Conditionality`][ðŸ¦€], and returns an Option<&[`Referrer`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Conditionality
/// [ðŸ¦ž]: crate::sarzak::types::Referrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak_maybe_get_many_r_froms_across_r11;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_cpp = Conditionality::test_default(&mut store);
/// let physical_cows = "glib_wave".to_owned();
/// let object_ofx = Object::new(&mut store, physical_cows);
/// let cardinality_ozt = Cardinality::test_default(&mut store);
/// let interesting_fly = "disastrous_paper".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_cpp, &object_ofx, &cardinality_ozt, interesting_fly);
/// let referrer_hmw = sarzak_maybe_get_many_r_froms_across_r11!(conditionality_cpp, store);
///
/// assert!(referrer_hmw.iter().find(|&x| **x == referrer).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_r_froms_across_r11 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referrer()
            .filter_map(|z| {
                if z.1.conditionality == $input.get_id() {
                    Some(z.1)
                } else {
                    None
                }
            })
            .collect::<Vec<&Referrer>>()
        // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_many_r_froms_across_r11;

/// Macro to traverse [`State`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R18_
///
/// This macro expects a &[`State`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::State
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::State;
/// # use sarzak::sarzak_get_one_obj_across_r18;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let colossal_measure = "white_step".to_owned();
/// let object_pij = Object::new(&mut store, colossal_measure);
/// let sneaky_regret = "shut_turn".to_owned();
///
/// let state = State::new(&mut store, &object_pij, sneaky_regret);
///
/// let object_ldr = sarzak_get_one_obj_across_r18!(state, store);
/// assert_eq!(&object_pij, object_ldr);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r18 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r18;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`State`][ðŸ¦ž], via _R18(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`State`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::State
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::State;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_maybe_get_many_ss_across_r18;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let gifted_skin = "hideous_kite".to_owned();
/// let object_wvf = Object::new(&mut store, gifted_skin);
/// let tidy_chance = "unkempt_approval".to_owned();
///
/// let state = State::new(&mut store, &object_wvf, tidy_chance);
/// let state_lva = sarzak_maybe_get_many_ss_across_r18!(object_wvf, store);
///
/// assert!(state_lva.iter().find(|&x| **x == state).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_ss_across_r18 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_state()
            .filter_map(|z| {
                if z.1.obj_id == $input.id {
                    Some(z.1)
                } else {
                    None
                }
            })
            .collect::<Vec<&State>>()
        // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_many_ss_across_r18;

/// Macro to traverse [`State`][ðŸ¦€] âž¡ [`Event`][ðŸ¦ž], across [`AcknowledgedEvent`][ðŸ¦‘] via _R20_
///
/// This macro expects a &[`State`][ðŸ¦€], and returns a &[`Event`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ðŸ¦€]: crate::sarzak::types::State
/// [ðŸ¦ž]: crate::sarzak::types::Event
/// [ðŸ¦‘]: crate::sarzak::types::AcknowledgedEvent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::AcknowledgedEvent;
/// # use sarzak::sarzak::State;
/// # use sarzak::sarzak::Event;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_many_e_across_r20;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let natural_dress = "lively_egg".to_owned();
/// let object_jyg = Object::new(&mut store, natural_dress);
/// let enchanted_note = "judicious_silver".to_owned();
/// let state_uku = State::new(&mut store, &object_jyg, enchanted_note);
/// let panoramic_quiet = "different_achieve".to_owned();
/// let object_uzs = Object::new(&mut store, panoramic_quiet);
/// let tense_eggs = "plucky_brush".to_owned();
/// let event_kgx = Event::new(&mut store, &object_uzs, tense_eggs);
/// let acknowledged_event = AcknowledgedEvent::new(&mut store, &state_uku, &event_kgx);
///
/// let event_uvo = sarzak_get_many_e_across_r20!(state_uku, store);
/// assert!(event_uvo.iter().find(|&x| **x == event_kgx).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_many_e_across_r20 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_many
        $store
            .iter_acknowledged_event()
            .filter(|a| a.1.state_id == $input.id)
            .map(|a| $store.exhume_event(&a.1.event_id).unwrap())
            .collect::<Vec<&Event>>()
    }};
}
pub use sarzak_get_many_e_across_r20;

/// Macro to traverse [`Event`][ðŸ¦€] âž¡ [`State`][ðŸ¦ž], across [`AcknowledgedEvent`][ðŸ¦‘] via _R20_
///
/// This macro expects a &[`Event`][ðŸ¦€], and returns a &[`State`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ðŸ¦€]: crate::sarzak::types::Event
/// [ðŸ¦ž]: crate::sarzak::types::State
/// [ðŸ¦‘]: crate::sarzak::types::AcknowledgedEvent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::AcknowledgedEvent;
/// # use sarzak::sarzak::State;
/// # use sarzak::sarzak::Event;
/// # use sarzak::sarzak_get_many_s_across_r20;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let little_plastic = "faulty_sort".to_owned();
/// let object_qsw = Object::new(&mut store, little_plastic);
/// let giant_event = "penitent_flower".to_owned();
/// let state_agp = State::new(&mut store, &object_qsw, giant_event);
/// let glorious_sort = "fast_protest".to_owned();
/// let object_gnz = Object::new(&mut store, glorious_sort);
/// let quick_answer = "rhetorical_insurance".to_owned();
/// let event_xpr = Event::new(&mut store, &object_gnz, quick_answer);
/// let acknowledged_event = AcknowledgedEvent::new(&mut store, &state_agp, &event_xpr);
///
/// let state_ftd = sarzak_get_many_s_across_r20!(event_xpr, store);
/// assert!(state_ftd.iter().find(|&x| **x == state_agp).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_many_s_across_r20 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_many
        $store
            .iter_acknowledged_event()
            .filter(|a| a.1.event_id == $input.id)
            .map(|a| $store.exhume_state(&a.1.state_id).unwrap())
            .collect::<Vec<&State>>()
    }};
}
pub use sarzak_get_many_s_across_r20;

/// Macro to traverse [`Associative`][ðŸ¦€] âž¡ [`OtherSide`][ðŸ¦ž], via _R22_
///
/// This macro expects a &[`Associative`][ðŸ¦€], and returns a &[`OtherSide`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Associative
/// [ðŸ¦ž]: crate::sarzak::types::OtherSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak_get_one_r_oth_across_r22;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let successful_berry = "inconclusive_price".to_owned();
/// let object_wwy = Object::new(&mut store, successful_berry);
/// let one_side_uon = OneSide::new(&mut store, &object_wwy);
/// let rhetorical_time = "knowledgeable_whip".to_owned();
/// let object_pcj = Object::new(&mut store, rhetorical_time);
/// let other_side_hwx = OtherSide::new(&mut store, &object_pcj);
/// let groovy_design = "next_crown".to_owned();
/// let object_jwh = Object::new(&mut store, groovy_design);
/// let associative_side_qmb = AssociativeSide::new(&mut store, &object_jwh);
///
/// let associative = Associative::new(&mut store, &one_side_uon, &other_side_hwx, &associative_side_qmb, 42);
///
/// let other_side_ecs = sarzak_get_one_r_oth_across_r22!(associative, store);
/// assert_eq!(&other_side_hwx, other_side_ecs);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_oth_across_r22 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_other_side(&$input.other).unwrap()
    }};
}
pub use sarzak_get_one_r_oth_across_r22;

/// Macro to traverse [`OtherSide`][ðŸ¦€] âž¡ [`Associative`][ðŸ¦ž], via _R22_
///
/// This macro expects a &[`OtherSide`][ðŸ¦€], and returns a &[`Associative`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::OtherSide
/// [ðŸ¦ž]: crate::sarzak::types::Associative
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak_get_one_r_assoc_across_r22;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let obscene_potato = "direful_loss".to_owned();
/// let object_sen = Object::new(&mut store, obscene_potato);
/// let one_side_fez = OneSide::new(&mut store, &object_sen);
/// let robust_history = "material_copper".to_owned();
/// let object_zox = Object::new(&mut store, robust_history);
/// let other_side_cca = OtherSide::new(&mut store, &object_zox);
/// let lyrical_plate = "adhesive_kettle".to_owned();
/// let object_qgh = Object::new(&mut store, lyrical_plate);
/// let associative_side_dpk = AssociativeSide::new(&mut store, &object_qgh);
///
/// let associative = Associative::new(&mut store, &one_side_fez, &other_side_cca, &associative_side_dpk, 42);
/// let associative_dwe = sarzak_get_one_r_assoc_across_r22!(other_side_cca, store);
///
/// assert_eq!(&associative, associative_dwe);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_assoc_across_r22 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_associative()
            .find(|z| z.1.other == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_get_one_r_assoc_across_r22;

/// Macro to traverse [`Associative`][ðŸ¦€] âž¡ [`OneSide`][ðŸ¦ž], via _R23_
///
/// This macro expects a &[`Associative`][ðŸ¦€], and returns a &[`OneSide`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Associative
/// [ðŸ¦ž]: crate::sarzak::types::OneSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak_get_one_r_one_across_r23;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let aggressive_kettle = "devilish_cellar".to_owned();
/// let object_gkd = Object::new(&mut store, aggressive_kettle);
/// let one_side_vwl = OneSide::new(&mut store, &object_gkd);
/// let abhorrent_mother = "material_band".to_owned();
/// let object_mce = Object::new(&mut store, abhorrent_mother);
/// let other_side_vrn = OtherSide::new(&mut store, &object_mce);
/// let exotic_cord = "caring_start".to_owned();
/// let object_gzo = Object::new(&mut store, exotic_cord);
/// let associative_side_fal = AssociativeSide::new(&mut store, &object_gzo);
///
/// let associative = Associative::new(&mut store, &one_side_vwl, &other_side_vrn, &associative_side_fal, 42);
///
/// let one_side_oco = sarzak_get_one_r_one_across_r23!(associative, store);
/// assert_eq!(&one_side_vwl, one_side_oco);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_one_across_r23 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_one_side(&$input.one).unwrap()
    }};
}
pub use sarzak_get_one_r_one_across_r23;

/// Macro to traverse [`OneSide`][ðŸ¦€] âž¡ [`Associative`][ðŸ¦ž], via _R23_
///
/// This macro expects a &[`OneSide`][ðŸ¦€], and returns a &[`Associative`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::OneSide
/// [ðŸ¦ž]: crate::sarzak::types::Associative
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak_get_one_r_assoc_across_r23;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let obsolete_metal = "actually_weight".to_owned();
/// let object_dpj = Object::new(&mut store, obsolete_metal);
/// let one_side_rfl = OneSide::new(&mut store, &object_dpj);
/// let cloistered_smile = "loose_hall".to_owned();
/// let object_qoa = Object::new(&mut store, cloistered_smile);
/// let other_side_vli = OtherSide::new(&mut store, &object_qoa);
/// let mere_rest = "thick_pest".to_owned();
/// let object_qss = Object::new(&mut store, mere_rest);
/// let associative_side_pfq = AssociativeSide::new(&mut store, &object_qss);
///
/// let associative = Associative::new(&mut store, &one_side_rfl, &other_side_vli, &associative_side_pfq, 42);
/// let associative_fhl = sarzak_get_one_r_assoc_across_r23!(one_side_rfl, store);
///
/// assert_eq!(&associative, associative_fhl);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_assoc_across_r23 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_associative()
            .find(|z| z.1.one == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_get_one_r_assoc_across_r23;

/// Macro to traverse [`Supertype`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R14_
///
/// This macro expects a &[`Supertype`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Supertype
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak_get_one_obj_across_r14;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let healthy_unit = "absorbed_rest".to_owned();
/// let object_sdn = Object::new(&mut store, healthy_unit);
///
/// let supertype = Supertype::new(&mut store, &object_sdn);
///
/// let object_wmc = sarzak_get_one_obj_across_r14!(supertype, store);
/// assert_eq!(&object_sdn, object_wmc);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r14 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r14;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Supertype`][ðŸ¦ž], via _R14(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Supertype`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Supertype
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Supertype;
/// # use sarzak::sarzak_maybe_get_one_r_sup_across_r14;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let horrible_approval = "serious_debt".to_owned();
/// let object_blo = Object::new(&mut store, horrible_approval);
///
/// let supertype = Supertype::new(&mut store, &object_blo);
/// let supertype_unu = sarzak_maybe_get_one_r_sup_across_r14!(object_blo, store);
///
/// assert_eq!(Some(&supertype), supertype_unu);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_sup_across_r14 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_supertype()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_one_r_sup_across_r14;

/// Macro to traverse [`Associative`][ðŸ¦€] âž¡ [`AssociativeSide`][ðŸ¦ž], via _R21_
///
/// This macro expects a &[`Associative`][ðŸ¦€], and returns a &[`AssociativeSide`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Associative
/// [ðŸ¦ž]: crate::sarzak::types::AssociativeSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak_get_one_r_ass_across_r21;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let nimble_trick = "different_arch".to_owned();
/// let object_bxc = Object::new(&mut store, nimble_trick);
/// let one_side_vgz = OneSide::new(&mut store, &object_bxc);
/// let animated_cars = "drab_blade".to_owned();
/// let object_dgk = Object::new(&mut store, animated_cars);
/// let other_side_fio = OtherSide::new(&mut store, &object_dgk);
/// let unequaled_pump = "clean_good_bye".to_owned();
/// let object_zgm = Object::new(&mut store, unequaled_pump);
/// let associative_side_zfo = AssociativeSide::new(&mut store, &object_zgm);
///
/// let associative = Associative::new(&mut store, &one_side_vgz, &other_side_fio, &associative_side_zfo, 42);
///
/// let associative_side_piz = sarzak_get_one_r_ass_across_r21!(associative, store);
/// assert_eq!(&associative_side_zfo, associative_side_piz);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_ass_across_r21 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_associative_side(&$input.from).unwrap()
    }};
}
pub use sarzak_get_one_r_ass_across_r21;

/// Macro to traverse [`AssociativeSide`][ðŸ¦€] âž¡ [`Associative`][ðŸ¦ž], via _R21_
///
/// This macro expects a &[`AssociativeSide`][ðŸ¦€], and returns a &[`Associative`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::AssociativeSide
/// [ðŸ¦ž]: crate::sarzak::types::Associative
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::AssociativeSide;
/// # use sarzak::sarzak::OneSide;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak_get_one_r_assoc_across_r21;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let quiet_sail = "jolly_attempt".to_owned();
/// let object_qfx = Object::new(&mut store, quiet_sail);
/// let one_side_uwd = OneSide::new(&mut store, &object_qfx);
/// let worthless_back = "even_acoustics".to_owned();
/// let object_atr = Object::new(&mut store, worthless_back);
/// let other_side_vnt = OtherSide::new(&mut store, &object_atr);
/// let tough_leg = "ruthless_direction".to_owned();
/// let object_xcj = Object::new(&mut store, tough_leg);
/// let associative_side_cdz = AssociativeSide::new(&mut store, &object_xcj);
///
/// let associative = Associative::new(&mut store, &one_side_uwd, &other_side_vnt, &associative_side_cdz, 42);
/// let associative_sub = sarzak_get_one_r_assoc_across_r21!(associative_side_cdz, store);
///
/// assert_eq!(&associative, associative_sub);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_assoc_across_r21 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_associative()
            .find(|z| z.1.from == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_get_one_r_assoc_across_r21;

/// Macro to traverse [`Referrer`][ðŸ¦€] âž¡ [`Cardinality`][ðŸ¦ž], via _R9_
///
/// This macro expects a &[`Referrer`][ðŸ¦€], and returns a &[`Cardinality`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referrer
/// [ðŸ¦ž]: crate::sarzak::types::Cardinality
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak_get_one_card_across_r9;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_thx = Conditionality::test_default(&mut store);
/// let gray_birds = "puzzling_body".to_owned();
/// let object_lkl = Object::new(&mut store, gray_birds);
/// let cardinality_wvw = Cardinality::test_default(&mut store);
/// let possessive_idea = "exultant_business".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_thx, &object_lkl, &cardinality_wvw, possessive_idea);
///
/// let cardinality_ulg = sarzak_get_one_card_across_r9!(referrer, store);
/// assert_eq!(&cardinality_wvw, cardinality_ulg);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_card_across_r9 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_cardinality(&$input.cardinality).unwrap()
    }};
}
pub use sarzak_get_one_card_across_r9;

/// Macro to traverse [`Cardinality`][ðŸ¦€] âž¡ [`Referrer`][ðŸ¦ž], via _R9(c)_
///
/// This macro expects a &[`Cardinality`][ðŸ¦€], and returns an Option<&[`Referrer`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Cardinality
/// [ðŸ¦ž]: crate::sarzak::types::Referrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak_maybe_get_many_r_froms_across_r9;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_rxt = Conditionality::test_default(&mut store);
/// let complex_push = "phobic_stone".to_owned();
/// let object_bqx = Object::new(&mut store, complex_push);
/// let cardinality_qtd = Cardinality::test_default(&mut store);
/// let vigorous_song = "tiny_cub".to_owned();
///
/// let referrer = Referrer::new(&mut store, &conditionality_rxt, &object_bqx, &cardinality_qtd, vigorous_song);
/// let referrer_cef = sarzak_maybe_get_many_r_froms_across_r9!(cardinality_qtd, store);
///
/// assert!(referrer_cef.iter().find(|&x| **x == referrer).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_r_froms_across_r9 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_referrer()
            .filter_map(|z| {
                if z.1.cardinality == $input.get_id() {
                    Some(z.1)
                } else {
                    None
                }
            })
            .collect::<Vec<&Referrer>>()
        // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_many_r_froms_across_r9;

/// Macro to traverse [`Attribute`][ðŸ¦€] âž¡ [`Type`][ðŸ¦ž], via _R2_
///
/// This macro expects a &[`Attribute`][ðŸ¦€], and returns a &[`Type`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Attribute
/// [ðŸ¦ž]: crate::sarzak::types::Type
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Type;
/// # use sarzak::sarzak::Attribute;
/// # use sarzak::sarzak_get_one_t_across_r2;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let big_girl = "jaded_ants".to_owned();
/// let object = Object::new(&mut store, big_girl);
/// let type_kvk = Type::test_default(&mut store);
/// let exotic_minister = "measly_behavior".to_owned();
///
/// let attribute = Attribute::new(&mut store, Some(&object), &type_kvk, exotic_minister);
///
/// let type_eql = sarzak_get_one_t_across_r2!(attribute, store);
/// assert_eq!(&type_kvk, type_eql);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_t_across_r2 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_ty(&$input.ty).unwrap()
    }};
}
pub use sarzak_get_one_t_across_r2;

/// Macro to traverse [`Type`][ðŸ¦€] âž¡ [`Attribute`][ðŸ¦ž], via _R2_
///
/// This macro expects a &[`Type`][ðŸ¦€], and returns a &[`Attribute`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Type
/// [ðŸ¦ž]: crate::sarzak::types::Attribute
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Attribute;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Type;
/// # use sarzak::sarzak_get_one_a_across_r2;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let difficult_chair = "tired_year".to_owned();
/// let object = Object::new(&mut store, difficult_chair);
/// let type_cwd = Type::test_default(&mut store);
/// let rich_hobbies = "acceptable_friend".to_owned();
///
/// let attribute = Attribute::new(&mut store, Some(&object), &type_cwd, rich_hobbies);
/// let attribute_xnh = sarzak_get_one_a_across_r2!(type_cwd, store);
///
/// assert_eq!(&attribute, attribute_xnh);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_a_across_r2 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_attribute()
            .find(|z| z.1.ty == $input.get_id())
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_get_one_a_across_r2;

/// Macro to traverse [`Binary`][ðŸ¦€] âž¡ [`Referrer`][ðŸ¦ž], via _R6_
///
/// This macro expects a &[`Binary`][ðŸ¦€], and returns a &[`Referrer`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Binary
/// [ðŸ¦ž]: crate::sarzak::types::Referrer
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak_get_one_r_from_across_r6;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_cni = Conditionality::test_default(&mut store);
/// let stiff_stage = "charming_horn".to_owned();
/// let object_vjd = Object::new(&mut store, stiff_stage);
/// let cardinality_ozm = Cardinality::test_default(&mut store);
/// let referent_gre = Referent::new(&mut store, &conditionality_cni, &object_vjd, &cardinality_ozm);
/// let conditionality_blc = Conditionality::test_default(&mut store);
/// let grateful_talk = "sticky_cart".to_owned();
/// let object_pss = Object::new(&mut store, grateful_talk);
/// let cardinality_sdt = Cardinality::test_default(&mut store);
/// let inquisitive_operation = "cheerful_verse".to_owned();
/// let referrer_asv = Referrer::new(&mut store, &conditionality_blc, &object_pss, &cardinality_sdt, inquisitive_operation);
///
/// let binary = Binary::new(&mut store, &referent_gre, &referrer_asv, 42);
///
/// let referrer_zec = sarzak_get_one_r_from_across_r6!(binary, store);
/// assert_eq!(&referrer_asv, referrer_zec);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_from_across_r6 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_referrer(&$input.from).unwrap()
    }};
}
pub use sarzak_get_one_r_from_across_r6;

/// Macro to traverse [`Referrer`][ðŸ¦€] âž¡ [`Binary`][ðŸ¦ž], via _R6_
///
/// This macro expects a &[`Referrer`][ðŸ¦€], and returns a &[`Binary`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referrer
/// [ðŸ¦ž]: crate::sarzak::types::Binary
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Binary;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_r_bin_across_r6;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_foq = Conditionality::test_default(&mut store);
/// let tranquil_table = "hideous_railway".to_owned();
/// let object_jja = Object::new(&mut store, tranquil_table);
/// let cardinality_alr = Cardinality::test_default(&mut store);
/// let referent_fnc = Referent::new(&mut store, &conditionality_foq, &object_jja, &cardinality_alr);
/// let conditionality_jbb = Conditionality::test_default(&mut store);
/// let dark_skate = "simplistic_rub".to_owned();
/// let object_ula = Object::new(&mut store, dark_skate);
/// let cardinality_plm = Cardinality::test_default(&mut store);
/// let abnormal_bell = "typical_believe".to_owned();
/// let referrer_sqm = Referrer::new(&mut store, &conditionality_jbb, &object_ula, &cardinality_plm, abnormal_bell);
///
/// let binary = Binary::new(&mut store, &referent_fnc, &referrer_sqm, 42);
/// let binary_nng = sarzak_get_one_r_bin_across_r6!(referrer_sqm, store);
///
/// assert_eq!(&binary, binary_nng);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_bin_across_r6 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_binary()
            .find(|z| z.1.from == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_get_one_r_bin_across_r6;

/// Macro to traverse [`Event`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R19_
///
/// This macro expects a &[`Event`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Event
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Event;
/// # use sarzak::sarzak_get_one_obj_across_r19;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let careful_rule = "instinctive_design".to_owned();
/// let object_snf = Object::new(&mut store, careful_rule);
/// let half_rain = "living_dogs".to_owned();
///
/// let event = Event::new(&mut store, &object_snf, half_rain);
///
/// let object_anx = sarzak_get_one_obj_across_r19!(event, store);
/// assert_eq!(&object_snf, object_anx);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r19 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r19;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Event`][ðŸ¦ž], via _R19(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Event`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Event
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Event;
/// # use sarzak::sarzak_maybe_get_many_es_across_r19;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let envious_question = "mammoth_wave".to_owned();
/// let object_bnw = Object::new(&mut store, envious_question);
/// let ancient_afternoon = "erratic_relation".to_owned();
///
/// let event = Event::new(&mut store, &object_bnw, ancient_afternoon);
/// let event_qtq = sarzak_maybe_get_many_es_across_r19!(object_bnw, store);
///
/// assert!(event_qtq.iter().find(|&x| **x == event).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_many_es_across_r19 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_event()
            .filter_map(|z| {
                if z.1.obj_id == $input.id {
                    Some(z.1)
                } else {
                    None
                }
            })
            .collect::<Vec<&Event>>()
        // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_many_es_across_r19;

/// Macro to traverse [`Attribute`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R1(c)_
///
/// This macro expects a &[`Attribute`][ðŸ¦€], and returns an Option<&[`Object`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Attribute
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Attribute;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Type;
/// # use sarzak::sarzak_maybe_get_one_obj_across_r1;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let breakable_organization = "shocking_oranges".to_owned();
/// let object = Object::new(&mut store, breakable_organization);
/// let type_vbo = Type::test_default(&mut store);
/// let chilly_offer = "ambitious_wine".to_owned();
/// let nimble_kitty = "waggish_stick".to_owned();
///
/// let attribute = Attribute::new(&mut store, Some(&object), &type_vbo, chilly_offer);
///
/// let object_jpd = sarzak_maybe_get_one_obj_across_r1!(attribute, store);
/// assert_eq!(Some(&object), object_jpd);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_obj_across_r1 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_conditional
        match &$input.obj_id {
            Some(i) => $store.exhume_object(i),
            None => None,
        }
    }};
}
pub use sarzak_maybe_get_one_obj_across_r1;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Attribute`][ðŸ¦ž], via _R1_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns a &[`Attribute`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Attribute
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Attribute;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Type;
/// # use sarzak::sarzak_get_many_as_across_r1;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let materialistic_instrument = "mixed_riddle".to_owned();
/// let courageous_stem = "boorish_snakes".to_owned();
/// let object = Object::new(&mut store, courageous_stem);
/// let type_ukn = Type::test_default(&mut store);
/// let future_ocean = "oafish_bait".to_owned();
///
/// let attribute = Attribute::new(&mut store, Some(&object), &type_ukn, future_ocean);
///
/// let attribute_ykk = sarzak_get_many_as_across_r1!(object, store);
/// assert!(attribute_ykk.iter().find(|&x| **x == attribute).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_many_as_across_r1 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_attribute()
            .filter_map(|z| {
                if z.1.obj_id == Some($input.id) {
                    Some(z.1)
                } else {
                    None
                }
            })
            .collect::<Vec<&Attribute>>()
        // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_get_many_as_across_r1;

/// Macro to traverse [`Subtype`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R15_
///
/// This macro expects a &[`Subtype`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Subtype
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Subtype;
/// # use sarzak::sarzak_get_one_obj_across_r15;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let like_salt = "new_bit".to_owned();
/// let object_kvf = Object::new(&mut store, like_salt);
///
/// let subtype = Subtype::new(&mut store, &object_kvf);
///
/// let object_igx = sarzak_get_one_obj_across_r15!(subtype, store);
/// assert_eq!(&object_kvf, object_igx);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r15 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r15;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`Subtype`][ðŸ¦ž], via _R15(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`Subtype`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::Subtype
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Subtype;
/// # use sarzak::sarzak_maybe_get_one_r_sub_across_r15;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let frantic_library = "squealing_sock".to_owned();
/// let object_zvj = Object::new(&mut store, frantic_library);
///
/// let subtype = Subtype::new(&mut store, &object_zvj);
/// let subtype_vem = sarzak_maybe_get_one_r_sub_across_r15!(object_zvj, store);
///
/// assert_eq!(Some(&subtype), subtype_vem);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_sub_across_r15 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_subtype()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_one_r_sub_across_r15;

/// Macro to traverse [`OtherSide`][ðŸ¦€] âž¡ [`Object`][ðŸ¦ž], via _R25_
///
/// This macro expects a &[`OtherSide`][ðŸ¦€], and returns a &[`Object`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::OtherSide
/// [ðŸ¦ž]: crate::sarzak::types::Object
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_obj_across_r25;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let far_office = "versed_trick".to_owned();
/// let object_eor = Object::new(&mut store, far_office);
///
/// let other_side = OtherSide::new(&mut store, &object_eor);
///
/// let object_nny = sarzak_get_one_obj_across_r25!(other_side, store);
/// assert_eq!(&object_eor, object_nny);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_obj_across_r25 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object(&$input.obj_id).unwrap()
    }};
}
pub use sarzak_get_one_obj_across_r25;

/// Macro to traverse [`Object`][ðŸ¦€] âž¡ [`OtherSide`][ðŸ¦ž], via _R25(c)_
///
/// This macro expects a &[`Object`][ðŸ¦€], and returns an Option<&[`OtherSide`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Object
/// [ðŸ¦ž]: crate::sarzak::types::OtherSide
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::OtherSide;
/// # use sarzak::sarzak_maybe_get_one_r_oth_across_r25;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let secretive_calendar = "awesome_time".to_owned();
/// let object_jmb = Object::new(&mut store, secretive_calendar);
///
/// let other_side = OtherSide::new(&mut store, &object_jmb);
/// let other_side_hon = sarzak_maybe_get_one_r_oth_across_r25!(object_jmb, store);
///
/// assert_eq!(Some(&other_side), other_side_hon);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_maybe_get_one_r_oth_across_r25 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_other_side()
            .find(|z| z.1.obj_id == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_maybe_get_one_r_oth_across_r25;

/// Macro to traverse [`Binary`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R5_
///
/// This macro expects a &[`Binary`][ðŸ¦€], and returns a &[`Referent`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Binary
/// [ðŸ¦ž]: crate::sarzak::types::Referent
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak_get_one_r_to_across_r5;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_pps = Conditionality::test_default(&mut store);
/// let mellow_flowers = "screeching_plot".to_owned();
/// let object_vnj = Object::new(&mut store, mellow_flowers);
/// let cardinality_tnv = Cardinality::test_default(&mut store);
/// let referent_uws = Referent::new(&mut store, &conditionality_pps, &object_vnj, &cardinality_tnv);
/// let conditionality_ijo = Conditionality::test_default(&mut store);
/// let gamy_decision = "elated_tent".to_owned();
/// let object_hfm = Object::new(&mut store, gamy_decision);
/// let cardinality_bbl = Cardinality::test_default(&mut store);
/// let possible_bean = "miscreant_angle".to_owned();
/// let referrer_ehw = Referrer::new(&mut store, &conditionality_ijo, &object_hfm, &cardinality_bbl, possible_bean);
///
/// let binary = Binary::new(&mut store, &referent_uws, &referrer_ehw, 42);
///
/// let referent_atp = sarzak_get_one_r_to_across_r5!(binary, store);
/// assert_eq!(&referent_uws, referent_atp);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_to_across_r5 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_referent(&$input.to).unwrap()
    }};
}
pub use sarzak_get_one_r_to_across_r5;

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`Binary`][ðŸ¦ž], via _R5_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`Binary`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::sarzak::types::Referent
/// [ðŸ¦ž]: crate::sarzak::types::Binary
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Cardinality;
/// # use sarzak::sarzak::Referrer;
/// # use sarzak::sarzak::Conditionality;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::sarzak::Referent;
/// # use sarzak::sarzak::Object;
/// # use sarzak::sarzak_get_one_r_bin_across_r5;
/// # let mut store = sarzak::sarzak::ObjectStore::new();
///
/// let conditionality_wdj = Conditionality::test_default(&mut store);
/// let aback_education = "jolly_zinc".to_owned();
/// let object_wto = Object::new(&mut store, aback_education);
/// let cardinality_kaq = Cardinality::test_default(&mut store);
/// let referent_ypw = Referent::new(&mut store, &conditionality_wdj, &object_wto, &cardinality_kaq);
/// let conditionality_wro = Conditionality::test_default(&mut store);
/// let subsequent_trains = "gleaming_regret".to_owned();
/// let object_hoy = Object::new(&mut store, subsequent_trains);
/// let cardinality_jzs = Cardinality::test_default(&mut store);
/// let drab_direction = "limping_print".to_owned();
/// let referrer_kxc = Referrer::new(&mut store, &conditionality_wro, &object_hoy, &cardinality_jzs, drab_direction);
///
/// let binary = Binary::new(&mut store, &referent_ypw, &referrer_kxc, 42);
/// let binary_nmz = sarzak_get_one_r_bin_across_r5!(referent_ypw, store);
///
/// assert_eq!(&binary, binary_nmz);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! sarzak_get_one_r_bin_across_r5 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_binary()
            .find(|z| z.1.to == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":"CriticalBlockEnd"}
    }};
}
pub use sarzak_get_one_r_bin_across_r5;
