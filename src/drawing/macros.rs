//! Macros for navigating the "Drawing" domain
//!
//! # Generated Code -- edit _with care_.
//!
//! Don't mess with anything between `{"magic":"îž¨","kind":"CriticalBlockBegin"}`
//! and `{"magic":"îž¨","kind":"CriticalBlockEnd"}`. Otherwise, you should be free
//! to go wild. Happy hacking!
//!
//! Use the following invocation to reproduce:
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
//! ```shell
//!  sarzak gen
//! ```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
// {"magic":"îž¨","version":"0.5.0"}

/// Macro to traverse [`IsaUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R9_
///
/// This macro expects a &[`IsaUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::IsaUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing_get_one_anch_across_r9;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let isa_hdn = Isa::default();
///
/// let point_lvi = Point::new(&mut store, 42, 42);
/// let point_muc = Point::new(&mut store, 42, 42);
/// let edge_byy = Edge::test_default(&mut store);
/// let anchor_ptu = Anchor::new(&mut store, &point_lvi, &point_muc, &edge_byy);
///
/// let isa_ui = IsaUi::new(&mut store, &isa_hdn, &anchor_ptu);
///
/// let anchor_eka = drawing_get_one_anch_across_r9!(isa_ui, store);
/// assert_eq!(&anchor_ptu, anchor_eka);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r9 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.from).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r9;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`IsaUi`][ðŸ¦ž], via _R9(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`IsaUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::IsaUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing_maybe_get_one_iui_across_r9;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let isa_ikj = Isa::default();
///
/// let point_wqv = Point::new(&mut store, 42, 42);
/// let point_bcs = Point::new(&mut store, 42, 42);
/// let edge_zae = Edge::test_default(&mut store);
/// let anchor_pvb = Anchor::new(&mut store, &point_wqv, &point_bcs, &edge_zae);
///
/// let isa_ui = IsaUi::new(&mut store, &isa_ikj, &anchor_pvb);
/// let isa_ui_fft = drawing_maybe_get_one_iui_across_r9!(anchor_pvb, store);
///
/// assert_eq!(Some(&isa_ui), isa_ui_fft);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_iui_across_r9 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-isa_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_isa_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-isa_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_iui_across_r9;

/// Macro to traverse [`AssociativeUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R15_
///
/// This macro expects a &[`AssociativeUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::AssociativeUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_anch_across_r15;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_ymi = Associative::default();
///
/// let point_rme = Point::new(&mut store, 42, 42);
/// let point_ozn = Point::new(&mut store, 42, 42);
/// let edge_tak = Edge::test_default(&mut store);
/// let anchor_qsc = Anchor::new(&mut store, &point_rme, &point_ozn, &edge_tak);
/// let point_kfd = Point::new(&mut store, 42, 42);
/// let point_gjy = Point::new(&mut store, 42, 42);
/// let edge_dif = Edge::test_default(&mut store);
/// let anchor_ijo = Anchor::new(&mut store, &point_kfd, &point_gjy, &edge_dif);
/// let point_hit = Point::new(&mut store, 42, 42);
/// let point_tgc = Point::new(&mut store, 42, 42);
/// let edge_khn = Edge::test_default(&mut store);
/// let anchor_kys = Anchor::new(&mut store, &point_hit, &point_tgc, &edge_khn);
/// let point_iuc = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_ymi, &anchor_qsc, &anchor_ijo, &anchor_kys, &point_iuc);
///
/// let anchor_wov = drawing_get_one_anch_across_r15!(associative_ui, store);
/// assert_eq!(&anchor_qsc, anchor_wov);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r15 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.other).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r15;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`AssociativeUi`][ðŸ¦ž], via _R15(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`AssociativeUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::AssociativeUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_maybe_get_one_aui_across_r15;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_tax = Associative::default();
///
/// let point_tma = Point::new(&mut store, 42, 42);
/// let point_ykc = Point::new(&mut store, 42, 42);
/// let edge_goc = Edge::test_default(&mut store);
/// let anchor_uci = Anchor::new(&mut store, &point_tma, &point_ykc, &edge_goc);
/// let point_ssb = Point::new(&mut store, 42, 42);
/// let point_axm = Point::new(&mut store, 42, 42);
/// let edge_xfz = Edge::test_default(&mut store);
/// let anchor_kgp = Anchor::new(&mut store, &point_ssb, &point_axm, &edge_xfz);
/// let point_zpr = Point::new(&mut store, 42, 42);
/// let point_wof = Point::new(&mut store, 42, 42);
/// let edge_ykz = Edge::test_default(&mut store);
/// let anchor_kct = Anchor::new(&mut store, &point_zpr, &point_wof, &edge_ykz);
/// let point_xjo = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_tax, &anchor_uci, &anchor_kgp, &anchor_kct, &point_xjo);
/// let associative_ui_fbw = drawing_maybe_get_one_aui_across_r15!(anchor_uci, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_fbw);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_aui_across_r15 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.other == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r15;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`Point`][ðŸ¦ž], via _R5_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns a &[`Point`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::Point
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_pnt_across_r5;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_zpi = Point::new(&mut store, 42, 42);
/// let point_rxq = Point::new(&mut store, 42, 42);
/// let edge_xev = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_zpi, &point_rxq, &edge_xev);
///
/// let point_mya = drawing_get_one_pnt_across_r5!(anchor, store);
/// assert_eq!(&point_zpi, point_mya);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_pnt_across_r5 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.offset).unwrap()
    }};
}
pub use drawing_get_one_pnt_across_r5;

/// Macro to traverse [`Point`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R5(c)_
///
/// This macro expects a &[`Point`][ðŸ¦€], and returns an Option<&[`Anchor`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Point
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_maybe_get_one_anch_across_r5;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_pvq = Point::new(&mut store, 42, 42);
/// let point_gsq = Point::new(&mut store, 42, 42);
/// let edge_pti = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_pvq, &point_gsq, &edge_pti);
/// let anchor_eai = drawing_maybe_get_one_anch_across_r5!(point_pvq, store);
///
/// assert_eq!(Some(&anchor), anchor_eai);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_anch_across_r5 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.offset == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_anch_across_r5;

/// Macro to traverse [`AssociativeUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R14_
///
/// This macro expects a &[`AssociativeUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::AssociativeUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_get_one_anch_across_r14;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_gsm = Associative::default();
///
/// let point_sgd = Point::new(&mut store, 42, 42);
/// let point_njr = Point::new(&mut store, 42, 42);
/// let edge_hqg = Edge::test_default(&mut store);
/// let anchor_amv = Anchor::new(&mut store, &point_sgd, &point_njr, &edge_hqg);
/// let point_yif = Point::new(&mut store, 42, 42);
/// let point_osw = Point::new(&mut store, 42, 42);
/// let edge_rbc = Edge::test_default(&mut store);
/// let anchor_wnv = Anchor::new(&mut store, &point_yif, &point_osw, &edge_rbc);
/// let point_wbd = Point::new(&mut store, 42, 42);
/// let point_mvi = Point::new(&mut store, 42, 42);
/// let edge_oam = Edge::test_default(&mut store);
/// let anchor_rjl = Anchor::new(&mut store, &point_wbd, &point_mvi, &edge_oam);
/// let point_uoq = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_gsm, &anchor_amv, &anchor_wnv, &anchor_rjl, &point_uoq);
///
/// let anchor_vpv = drawing_get_one_anch_across_r14!(associative_ui, store);
/// assert_eq!(&anchor_amv, anchor_vpv);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r14 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.one).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r14;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`AssociativeUi`][ðŸ¦ž], via _R14(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`AssociativeUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::AssociativeUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_aui_across_r14;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_pvi = Associative::default();
///
/// let point_ipa = Point::new(&mut store, 42, 42);
/// let point_ody = Point::new(&mut store, 42, 42);
/// let edge_ppp = Edge::test_default(&mut store);
/// let anchor_ebw = Anchor::new(&mut store, &point_ipa, &point_ody, &edge_ppp);
/// let point_uek = Point::new(&mut store, 42, 42);
/// let point_glg = Point::new(&mut store, 42, 42);
/// let edge_bda = Edge::test_default(&mut store);
/// let anchor_edo = Anchor::new(&mut store, &point_uek, &point_glg, &edge_bda);
/// let point_fzy = Point::new(&mut store, 42, 42);
/// let point_uei = Point::new(&mut store, 42, 42);
/// let edge_nnf = Edge::test_default(&mut store);
/// let anchor_bxm = Anchor::new(&mut store, &point_fzy, &point_uei, &edge_nnf);
/// let point_toe = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_pvi, &anchor_ebw, &anchor_edo, &anchor_bxm, &point_toe);
/// let associative_ui_jbc = drawing_maybe_get_one_aui_across_r14!(anchor_ebw, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_jbc);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_aui_across_r14 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.one == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r14;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`IsaUi`][ðŸ¦ž], across [`SubtypeAnchors`][ðŸ¦‘] via _R10_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns a &[`IsaUi`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::IsaUi
/// [ðŸ¦‘]: crate::drawing::types::SubtypeAnchors
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::SubtypeAnchors;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::drawing_maybe_get_one_iui_across_r10;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_prx = Point::new(&mut store, 42, 42);
/// let point_eob = Point::new(&mut store, 42, 42);
/// let edge_zpu = Edge::test_default(&mut store);
/// let anchor_ihn = Anchor::new(&mut store, &point_prx, &point_eob, &edge_zpu);
/// let isa_ubt = Isa::default();
///
/// let point_itk = Point::new(&mut store, 42, 42);
/// let point_nyc = Point::new(&mut store, 42, 42);
/// let edge_ihz = Edge::test_default(&mut store);
/// let anchor_nwj = Anchor::new(&mut store, &point_itk, &point_nyc, &edge_ihz);
/// let isa_ui_mym = IsaUi::new(&mut store, &isa_ubt, &anchor_nwj);
/// let subtype_anchors = SubtypeAnchors::new(&mut store, &anchor_ihn, &isa_ui_mym);
///
/// let isa_ui_czu = drawing_maybe_get_one_iui_across_r10!(anchor_ihn, store);
/// assert_eq!(Some(&isa_ui_mym), isa_ui_czu);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_iui_across_r10 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_maybe_get_one
        $store
            .iter_subtype_anchors()
            .filter(|a| a.1.anchor_id == $input.id)
            .next()
            .and_then(|a| $store.exhume_isa_ui(&a.1.isaui_id))
    }};
}
pub use drawing_maybe_get_one_iui_across_r10;

/// Macro to traverse [`IsaUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], across [`SubtypeAnchors`][ðŸ¦‘] via _R10_
///
/// This macro expects a &[`IsaUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ðŸ¦€]: crate::drawing::types::IsaUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
/// [ðŸ¦‘]: crate::drawing::types::SubtypeAnchors
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::SubtypeAnchors;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::drawing_get_many_anch_across_r10;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_wif = Point::new(&mut store, 42, 42);
/// let point_ciw = Point::new(&mut store, 42, 42);
/// let edge_dqh = Edge::test_default(&mut store);
/// let anchor_noa = Anchor::new(&mut store, &point_wif, &point_ciw, &edge_dqh);
/// let isa_hiv = Isa::default();
///
/// let point_fiu = Point::new(&mut store, 42, 42);
/// let point_ovu = Point::new(&mut store, 42, 42);
/// let edge_tdn = Edge::test_default(&mut store);
/// let anchor_oco = Anchor::new(&mut store, &point_fiu, &point_ovu, &edge_tdn);
/// let isa_ui_lhg = IsaUi::new(&mut store, &isa_hiv, &anchor_oco);
/// let subtype_anchors = SubtypeAnchors::new(&mut store, &anchor_noa, &isa_ui_lhg);
///
/// let anchor_qlx = drawing_get_many_anch_across_r10!(isa_ui_lhg, store);
/// assert!(anchor_qlx.iter().find(|&x| **x == anchor_noa).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_many_anch_across_r10 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_many
        $store
            .iter_subtype_anchors()
            .filter(|a| a.1.isaui_id == $input.id)
            .map(|a| $store.exhume_anchor(&a.1.anchor_id).unwrap())
            .collect::<Vec<&Anchor>>()
    }};
}
pub use drawing_get_many_anch_across_r10;

/// Macro to traverse [`ObjectUi`][ðŸ¦€] âž¡ [`Point`][ðŸ¦ž], via _R13_
///
/// This macro expects a &[`ObjectUi`][ðŸ¦€], and returns a &[`Point`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::ObjectUi
/// [ðŸ¦ž]: crate::drawing::types::Point
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing_get_one_pnt_across_r13;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_jzz = Point::new(&mut store, 42, 42);
/// let wary_steam = "strong_earthquake".to_owned();
/// let object_tcv = Object::default();
///
///
/// let object_ui = ObjectUi::new(&mut store, &point_jzz, &object_tcv, 42, 42);
///
/// let point_rjq = drawing_get_one_pnt_across_r13!(object_ui, store);
/// assert_eq!(&point_jzz, point_rjq);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_pnt_across_r13 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.origin).unwrap()
    }};
}
pub use drawing_get_one_pnt_across_r13;

/// Macro to traverse [`Point`][ðŸ¦€] âž¡ [`ObjectUi`][ðŸ¦ž], via _R13(c)_
///
/// This macro expects a &[`Point`][ðŸ¦€], and returns an Option<&[`ObjectUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Point
/// [ðŸ¦ž]: crate::drawing::types::ObjectUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_oui_across_r13;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_qwl = Point::new(&mut store, 42, 42);
/// let cheerful_ball = "puzzled_arithmetic".to_owned();
/// let object_jxn = Object::default();
///
///
/// let object_ui = ObjectUi::new(&mut store, &point_qwl, &object_jxn, 42, 42);
/// let object_ui_tuo = drawing_maybe_get_one_oui_across_r13!(point_qwl, store);
///
/// assert_eq!(Some(&object_ui), object_ui_tuo);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_oui_across_r13 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-object_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_object_ui()
            .find(|z| z.1.origin == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-object_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_oui_across_r13;

/// Macro to traverse [`AssociativeUi`][ðŸ¦€] âž¡ [`Point`][ðŸ¦ž], via _R17_
///
/// This macro expects a &[`AssociativeUi`][ðŸ¦€], and returns a &[`Point`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::AssociativeUi
/// [ðŸ¦ž]: crate::drawing::types::Point
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_pnt_across_r17;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_uqi = Associative::default();
///
/// let point_bua = Point::new(&mut store, 42, 42);
/// let point_vyh = Point::new(&mut store, 42, 42);
/// let edge_hpn = Edge::test_default(&mut store);
/// let anchor_gkp = Anchor::new(&mut store, &point_bua, &point_vyh, &edge_hpn);
/// let point_ebh = Point::new(&mut store, 42, 42);
/// let point_zwb = Point::new(&mut store, 42, 42);
/// let edge_ysw = Edge::test_default(&mut store);
/// let anchor_zyc = Anchor::new(&mut store, &point_ebh, &point_zwb, &edge_ysw);
/// let point_qyb = Point::new(&mut store, 42, 42);
/// let point_jwp = Point::new(&mut store, 42, 42);
/// let edge_ulu = Edge::test_default(&mut store);
/// let anchor_dqw = Anchor::new(&mut store, &point_qyb, &point_jwp, &edge_ulu);
/// let point_yry = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_uqi, &anchor_gkp, &anchor_zyc, &anchor_dqw, &point_yry);
///
/// let point_ebl = drawing_get_one_pnt_across_r17!(associative_ui, store);
/// assert_eq!(&point_yry, point_ebl);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_pnt_across_r17 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.middle).unwrap()
    }};
}
pub use drawing_get_one_pnt_across_r17;

/// Macro to traverse [`Point`][ðŸ¦€] âž¡ [`AssociativeUi`][ðŸ¦ž], via _R17(c)_
///
/// This macro expects a &[`Point`][ðŸ¦€], and returns an Option<&[`AssociativeUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Point
/// [ðŸ¦ž]: crate::drawing::types::AssociativeUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_maybe_get_one_aui_across_r17;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_gbh = Associative::default();
///
/// let point_xns = Point::new(&mut store, 42, 42);
/// let point_agq = Point::new(&mut store, 42, 42);
/// let edge_eyr = Edge::test_default(&mut store);
/// let anchor_ubs = Anchor::new(&mut store, &point_xns, &point_agq, &edge_eyr);
/// let point_fhr = Point::new(&mut store, 42, 42);
/// let point_its = Point::new(&mut store, 42, 42);
/// let edge_dyc = Edge::test_default(&mut store);
/// let anchor_nty = Anchor::new(&mut store, &point_fhr, &point_its, &edge_dyc);
/// let point_asa = Point::new(&mut store, 42, 42);
/// let point_vod = Point::new(&mut store, 42, 42);
/// let edge_msv = Edge::test_default(&mut store);
/// let anchor_jio = Anchor::new(&mut store, &point_asa, &point_vod, &edge_msv);
/// let point_sne = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_gbh, &anchor_ubs, &anchor_nty, &anchor_jio, &point_sne);
/// let associative_ui_sxi = drawing_maybe_get_one_aui_across_r17!(point_sne, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_sxi);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_aui_across_r17 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.middle == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r17;

/// Macro to traverse [`ObjectEdge`][ðŸ¦€] âž¡ [`ObjectUi`][ðŸ¦ž], via _R18_
///
/// This macro expects a &[`ObjectEdge`][ðŸ¦€], and returns a &[`ObjectUi`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::ObjectEdge
/// [ðŸ¦ž]: crate::drawing::types::ObjectUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_oui_across_r18;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_ryg = Edge::test_default(&mut store);
/// let point_icq = Point::new(&mut store, 42, 42);
/// let literate_hate = "careless_attempt".to_owned();
/// let object_wlr = Object::default();
///
/// let object_ui_tql = ObjectUi::new(&mut store, &point_icq, &object_wlr, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_ryg, &object_ui_tql);
///
/// let object_ui_rwu = drawing_get_one_oui_across_r18!(object_edge, store);
/// assert_eq!(&object_ui_tql, object_ui_rwu);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_oui_across_r18 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object_ui(&$input.oui_id).unwrap()
    }};
}
pub use drawing_get_one_oui_across_r18;

/// Macro to traverse [`ObjectUi`][ðŸ¦€] âž¡ [`ObjectEdge`][ðŸ¦ž], via _R18_
///
/// This macro expects a &[`ObjectUi`][ðŸ¦€], and returns a &[`ObjectEdge`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::ObjectUi
/// [ðŸ¦ž]: crate::drawing::types::ObjectEdge
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_many_oui_es_across_r18;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_zfb = Edge::test_default(&mut store);
/// let point_mtj = Point::new(&mut store, 42, 42);
/// let telling_station = "automatic_polish".to_owned();
/// let object_byy = Object::default();
///
/// let object_ui_lsv = ObjectUi::new(&mut store, &point_mtj, &object_byy, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_zfb, &object_ui_lsv);
/// let object_edge_utl = drawing_get_many_oui_es_across_r18!(object_ui_lsv, store);
///
/// assert!(object_edge_utl.iter().find(|&x| **x == object_edge).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_many_oui_es_across_r18 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object_ui-object_edge-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_object_edge()
            .filter_map(|z| if z.1.oui_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&ObjectEdge>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object_ui-object_edge-emit_many_conditional_lookup"}}}
    }};
}
pub use drawing_get_many_oui_es_across_r18;

/// Macro to traverse [`BinaryUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R8_
///
/// This macro expects a &[`BinaryUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::BinaryUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing_get_one_anch_across_r8;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_gpf = Point::new(&mut store, 42, 42);
/// let point_aiz = Point::new(&mut store, 42, 42);
/// let edge_yuu = Edge::test_default(&mut store);
/// let anchor_enu = Anchor::new(&mut store, &point_gpf, &point_aiz, &edge_yuu);
/// let point_lua = Point::new(&mut store, 42, 42);
/// let point_hcw = Point::new(&mut store, 42, 42);
/// let edge_xer = Edge::test_default(&mut store);
/// let anchor_zju = Anchor::new(&mut store, &point_lua, &point_hcw, &edge_xer);
/// let binary_oio = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_enu, &anchor_zju, &binary_oio);
///
/// let anchor_vne = drawing_get_one_anch_across_r8!(binary_ui, store);
/// assert_eq!(&anchor_enu, anchor_vne);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r8 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.to).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r8;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`BinaryUi`][ðŸ¦ž], via _R8(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`BinaryUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::BinaryUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing_maybe_get_one_bui_across_r8;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_xvm = Point::new(&mut store, 42, 42);
/// let point_jqq = Point::new(&mut store, 42, 42);
/// let edge_lzy = Edge::test_default(&mut store);
/// let anchor_pxg = Anchor::new(&mut store, &point_xvm, &point_jqq, &edge_lzy);
/// let point_hxz = Point::new(&mut store, 42, 42);
/// let point_ewe = Point::new(&mut store, 42, 42);
/// let edge_ade = Edge::test_default(&mut store);
/// let anchor_nfg = Anchor::new(&mut store, &point_hxz, &point_ewe, &edge_ade);
/// let binary_nhi = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_pxg, &anchor_nfg, &binary_nhi);
/// let binary_ui_tkj = drawing_maybe_get_one_bui_across_r8!(anchor_pxg, store);
///
/// assert_eq!(Some(&binary_ui), binary_ui_tkj);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_bui_across_r8 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_binary_ui()
            .find(|z| z.1.to == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_bui_across_r8;

/// Macro to traverse [`AssociativeUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R16_
///
/// This macro expects a &[`AssociativeUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::AssociativeUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing_get_one_anch_across_r16;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_jnb = Associative::default();
///
/// let point_nen = Point::new(&mut store, 42, 42);
/// let point_ptv = Point::new(&mut store, 42, 42);
/// let edge_qkp = Edge::test_default(&mut store);
/// let anchor_gjg = Anchor::new(&mut store, &point_nen, &point_ptv, &edge_qkp);
/// let point_wtr = Point::new(&mut store, 42, 42);
/// let point_aes = Point::new(&mut store, 42, 42);
/// let edge_bmi = Edge::test_default(&mut store);
/// let anchor_hxn = Anchor::new(&mut store, &point_wtr, &point_aes, &edge_bmi);
/// let point_yez = Point::new(&mut store, 42, 42);
/// let point_pyz = Point::new(&mut store, 42, 42);
/// let edge_flw = Edge::test_default(&mut store);
/// let anchor_tvi = Anchor::new(&mut store, &point_yez, &point_pyz, &edge_flw);
/// let point_ihj = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_jnb, &anchor_gjg, &anchor_hxn, &anchor_tvi, &point_ihj);
///
/// let anchor_rgk = drawing_get_one_anch_across_r16!(associative_ui, store);
/// assert_eq!(&anchor_gjg, anchor_rgk);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r16 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.from).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r16;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`AssociativeUi`][ðŸ¦ž], via _R16(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`AssociativeUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::AssociativeUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_maybe_get_one_aui_across_r16;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_pdg = Associative::default();
///
/// let point_fzn = Point::new(&mut store, 42, 42);
/// let point_btk = Point::new(&mut store, 42, 42);
/// let edge_wub = Edge::test_default(&mut store);
/// let anchor_qsr = Anchor::new(&mut store, &point_fzn, &point_btk, &edge_wub);
/// let point_znw = Point::new(&mut store, 42, 42);
/// let point_suo = Point::new(&mut store, 42, 42);
/// let edge_ybf = Edge::test_default(&mut store);
/// let anchor_deh = Anchor::new(&mut store, &point_znw, &point_suo, &edge_ybf);
/// let point_pfs = Point::new(&mut store, 42, 42);
/// let point_edr = Point::new(&mut store, 42, 42);
/// let edge_owg = Edge::test_default(&mut store);
/// let anchor_ixd = Anchor::new(&mut store, &point_pfs, &point_edr, &edge_owg);
/// let point_bqn = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_pdg, &anchor_qsr, &anchor_deh, &anchor_ixd, &point_bqn);
/// let associative_ui_llx = drawing_maybe_get_one_aui_across_r16!(anchor_qsr, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_llx);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_aui_across_r16 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r16;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`Edge`][ðŸ¦ž], via _R3_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns a &[`Edge`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::Edge
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_edg_across_r3;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_mvx = Point::new(&mut store, 42, 42);
/// let point_jvx = Point::new(&mut store, 42, 42);
/// let edge_oav = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_mvx, &point_jvx, &edge_oav);
///
/// let edge_piu = drawing_get_one_edg_across_r3!(anchor, store);
/// assert_eq!(&edge_oav, edge_piu);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_edg_across_r3 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_edge(&$input.edge).unwrap()
    }};
}
pub use drawing_get_one_edg_across_r3;

/// Macro to traverse [`Edge`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R3(c)_
///
/// This macro expects a &[`Edge`][ðŸ¦€], and returns an Option<&[`Anchor`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Edge
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_maybe_get_one_anch_across_r3;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_cku = Point::new(&mut store, 42, 42);
/// let point_ojl = Point::new(&mut store, 42, 42);
/// let edge_raj = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_cku, &point_ojl, &edge_raj);
/// let anchor_qol = drawing_maybe_get_one_anch_across_r3!(edge_raj, store);
///
/// assert_eq!(Some(&anchor), anchor_qol);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_anch_across_r3 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"edge-anchor-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.edge == $input.get_id())
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"edge-anchor-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_anch_across_r3;

/// Macro to traverse [`ObjectEdge`][ðŸ¦€] âž¡ [`Edge`][ðŸ¦ž], via _R19_
///
/// This macro expects a &[`ObjectEdge`][ðŸ¦€], and returns a &[`Edge`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::ObjectEdge
/// [ðŸ¦ž]: crate::drawing::types::Edge
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_edg_across_r19;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_apo = Edge::test_default(&mut store);
/// let point_psi = Point::new(&mut store, 42, 42);
/// let milky_activity = "busy_copper".to_owned();
/// let object_esj = Object::default();
///
/// let object_ui_qei = ObjectUi::new(&mut store, &point_psi, &object_esj, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_apo, &object_ui_qei);
///
/// let edge_nek = drawing_get_one_edg_across_r19!(object_edge, store);
/// assert_eq!(&edge_apo, edge_nek);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_edg_across_r19 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_edge(&$input.edge).unwrap()
    }};
}
pub use drawing_get_one_edg_across_r19;

/// Macro to traverse [`Edge`][ðŸ¦€] âž¡ [`ObjectEdge`][ðŸ¦ž], via _R19(c)_
///
/// This macro expects a &[`Edge`][ðŸ¦€], and returns an Option<&[`ObjectEdge`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Edge
/// [ðŸ¦ž]: crate::drawing::types::ObjectEdge
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_oui_e_across_r19;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_wlq = Edge::test_default(&mut store);
/// let point_zed = Point::new(&mut store, 42, 42);
/// let grieving_oven = "dysfunctional_crack".to_owned();
/// let object_wkv = Object::default();
///
/// let object_ui_hlw = ObjectUi::new(&mut store, &point_zed, &object_wkv, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_wlq, &object_ui_hlw);
/// let object_edge_npn = drawing_maybe_get_one_oui_e_across_r19!(edge_wlq, store);
///
/// assert_eq!(Some(&object_edge), object_edge_npn);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_oui_e_across_r19 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"edge-object_edge-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_object_edge()
            .find(|z| z.1.edge == $input.get_id())
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"edge-object_edge-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_oui_e_across_r19;

/// Macro to traverse [`BinaryUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R7_
///
/// This macro expects a &[`BinaryUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::BinaryUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_anch_across_r7;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_dgs = Point::new(&mut store, 42, 42);
/// let point_enb = Point::new(&mut store, 42, 42);
/// let edge_zji = Edge::test_default(&mut store);
/// let anchor_fcx = Anchor::new(&mut store, &point_dgs, &point_enb, &edge_zji);
/// let point_npk = Point::new(&mut store, 42, 42);
/// let point_nfw = Point::new(&mut store, 42, 42);
/// let edge_kyz = Edge::test_default(&mut store);
/// let anchor_esh = Anchor::new(&mut store, &point_npk, &point_nfw, &edge_kyz);
/// let binary_nav = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_fcx, &anchor_esh, &binary_nav);
///
/// let anchor_mdo = drawing_get_one_anch_across_r7!(binary_ui, store);
/// assert_eq!(&anchor_fcx, anchor_mdo);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r7 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.from).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r7;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`BinaryUi`][ðŸ¦ž], via _R7(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`BinaryUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::BinaryUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_maybe_get_one_bui_across_r7;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_flz = Point::new(&mut store, 42, 42);
/// let point_fuk = Point::new(&mut store, 42, 42);
/// let edge_mah = Edge::test_default(&mut store);
/// let anchor_tbl = Anchor::new(&mut store, &point_flz, &point_fuk, &edge_mah);
/// let point_ppm = Point::new(&mut store, 42, 42);
/// let point_srx = Point::new(&mut store, 42, 42);
/// let edge_sfk = Edge::test_default(&mut store);
/// let anchor_duz = Anchor::new(&mut store, &point_ppm, &point_srx, &edge_sfk);
/// let binary_bpw = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_tbl, &anchor_duz, &binary_bpw);
/// let binary_ui_grt = drawing_maybe_get_one_bui_across_r7!(anchor_tbl, store);
///
/// assert_eq!(Some(&binary_ui), binary_ui_grt);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_bui_across_r7 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_binary_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_bui_across_r7;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`Point`][ðŸ¦ž], via _R4_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns a &[`Point`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::Point
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_get_one_pnt_across_r4;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_woq = Point::new(&mut store, 42, 42);
/// let point_tnu = Point::new(&mut store, 42, 42);
/// let edge_dpg = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_woq, &point_tnu, &edge_dpg);
///
/// let point_lss = drawing_get_one_pnt_across_r4!(anchor, store);
/// assert_eq!(&point_woq, point_lss);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_pnt_across_r4 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.location).unwrap()
    }};
}
pub use drawing_get_one_pnt_across_r4;

/// Macro to traverse [`Point`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R4(c)_
///
/// This macro expects a &[`Point`][ðŸ¦€], and returns an Option<&[`Anchor`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Point
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_anch_across_r4;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_kmn = Point::new(&mut store, 42, 42);
/// let point_ddr = Point::new(&mut store, 42, 42);
/// let edge_svg = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_kmn, &point_ddr, &edge_svg);
/// let anchor_aee = drawing_maybe_get_one_anch_across_r4!(point_kmn, store);
///
/// assert_eq!(Some(&anchor), anchor_aee);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_anch_across_r4 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.location == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_anch_across_r4;
