//! Macros for navigating the "Drawing" domain
//!
//! # Generated Code -- edit _with care_.
//!
//! Don't mess with anything between `{"magic":"îž¨","kind":"CriticalBlockBegin"}`
//! and `{"magic":"îž¨","kind":"CriticalBlockEnd"}`. Otherwise, you should be free
//! to go wild. Happy hacking!
//!
//! Use the following invocation to reproduce:
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
//! ```shell
//!  sarzak gen sarzak -i true -m true -d true -e true
//! ```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
// {"magic":"îž¨","version":"0.5.0"}

/// Macro to traverse [`IsaUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R9_
///
/// This macro expects a &[`IsaUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::IsaUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_anch_across_r9;
/// # let mut store = sarzak::drawing::ObjectStore::new();
/// # let mut sarzak_store = sarzak::sarzak::ObjectStore::new();
///
/// let isa_kin = Isa::test_default(&mut sarzak_store);
///
/// let point_vhl = Point::new(&mut store, 42, 42);
/// let point_wbn = Point::new(&mut store, 42, 42);
/// let edge_brl = Edge::test_default(&mut store);
/// let anchor_eoz = Anchor::new(&mut store, &point_vhl, &point_wbn, &edge_brl);
///
/// let isa_ui = IsaUi::new(&mut store, &isa_kin, &anchor_eoz);
///
/// let anchor_ews = drawing_get_one_anch_across_r9!(isa_ui, store);
/// assert_eq!(&anchor_eoz, anchor_ews);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r9 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.from).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r9;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`IsaUi`][ðŸ¦ž], via _R9(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`IsaUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::IsaUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing_maybe_get_one_iui_across_r9;
/// # let mut store = sarzak::drawing::ObjectStore::new();
/// # let mut sarzak_store = sarzak::sarzak::ObjectStore::new();
///
/// let isa_pcg = Isa::test_default(&mut sarzak_store);
///
/// let point_ovl = Point::new(&mut store, 42, 42);
/// let point_qnd = Point::new(&mut store, 42, 42);
/// let edge_yzz = Edge::test_default(&mut store);
/// let anchor_eul = Anchor::new(&mut store, &point_ovl, &point_qnd, &edge_yzz);
///
/// let isa_ui = IsaUi::new(&mut store, &isa_pcg, &anchor_eul);
/// let isa_ui_gdb = drawing_maybe_get_one_iui_across_r9!(anchor_eul, store);
///
/// assert_eq!(Some(&isa_ui), isa_ui_gdb);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_iui_across_r9 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-isa_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_isa_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-isa_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_iui_across_r9;

/// Macro to traverse [`AssociativeUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R15_
///
/// This macro expects a &[`AssociativeUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::AssociativeUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_anch_across_r15;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_vls = Associative::default();
///
/// let point_eaj = Point::new(&mut store, 42, 42);
/// let point_bux = Point::new(&mut store, 42, 42);
/// let edge_uou = Edge::test_default(&mut store);
/// let anchor_hjj = Anchor::new(&mut store, &point_eaj, &point_bux, &edge_uou);
/// let point_bpu = Point::new(&mut store, 42, 42);
/// let point_lkb = Point::new(&mut store, 42, 42);
/// let edge_uqi = Edge::test_default(&mut store);
/// let anchor_bzq = Anchor::new(&mut store, &point_bpu, &point_lkb, &edge_uqi);
/// let point_hei = Point::new(&mut store, 42, 42);
/// let point_ebz = Point::new(&mut store, 42, 42);
/// let edge_dis = Edge::test_default(&mut store);
/// let anchor_aun = Anchor::new(&mut store, &point_hei, &point_ebz, &edge_dis);
/// let point_egw = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_vls, &anchor_hjj, &anchor_bzq, &anchor_aun, &point_egw);
///
/// let anchor_hxe = drawing_get_one_anch_across_r15!(associative_ui, store);
/// assert_eq!(&anchor_hjj, anchor_hxe);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r15 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.other).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r15;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`AssociativeUi`][ðŸ¦ž], via _R15(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`AssociativeUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::AssociativeUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_aui_across_r15;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_gbw = Associative::default();
///
/// let point_mth = Point::new(&mut store, 42, 42);
/// let point_mfc = Point::new(&mut store, 42, 42);
/// let edge_pew = Edge::test_default(&mut store);
/// let anchor_pzj = Anchor::new(&mut store, &point_mth, &point_mfc, &edge_pew);
/// let point_wtj = Point::new(&mut store, 42, 42);
/// let point_jxn = Point::new(&mut store, 42, 42);
/// let edge_fgb = Edge::test_default(&mut store);
/// let anchor_clz = Anchor::new(&mut store, &point_wtj, &point_jxn, &edge_fgb);
/// let point_nbo = Point::new(&mut store, 42, 42);
/// let point_mze = Point::new(&mut store, 42, 42);
/// let edge_qfe = Edge::test_default(&mut store);
/// let anchor_nzr = Anchor::new(&mut store, &point_nbo, &point_mze, &edge_qfe);
/// let point_uko = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_gbw, &anchor_pzj, &anchor_clz, &anchor_nzr, &point_uko);
/// let associative_ui_hdv = drawing_maybe_get_one_aui_across_r15!(anchor_pzj, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_hdv);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_aui_across_r15 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.other == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r15;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`Point`][ðŸ¦ž], via _R5_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns a &[`Point`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::Point
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_pnt_across_r5;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_vgp = Point::new(&mut store, 42, 42);
/// let point_nei = Point::new(&mut store, 42, 42);
/// let edge_dwg = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_vgp, &point_nei, &edge_dwg);
///
/// let point_yly = drawing_get_one_pnt_across_r5!(anchor, store);
/// assert_eq!(&point_vgp, point_yly);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_pnt_across_r5 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.offset).unwrap()
    }};
}
pub use drawing_get_one_pnt_across_r5;

/// Macro to traverse [`Point`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R5(c)_
///
/// This macro expects a &[`Point`][ðŸ¦€], and returns an Option<&[`Anchor`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Point
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_maybe_get_one_anch_across_r5;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_kgu = Point::new(&mut store, 42, 42);
/// let point_aot = Point::new(&mut store, 42, 42);
/// let edge_dqg = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_kgu, &point_aot, &edge_dqg);
/// let anchor_tdc = drawing_maybe_get_one_anch_across_r5!(point_kgu, store);
///
/// assert_eq!(Some(&anchor), anchor_tdc);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_anch_across_r5 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.offset == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_anch_across_r5;

/// Macro to traverse [`AssociativeUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R14_
///
/// This macro expects a &[`AssociativeUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::AssociativeUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_anch_across_r14;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_arp = Associative::default();
///
/// let point_gqn = Point::new(&mut store, 42, 42);
/// let point_byd = Point::new(&mut store, 42, 42);
/// let edge_srg = Edge::test_default(&mut store);
/// let anchor_qru = Anchor::new(&mut store, &point_gqn, &point_byd, &edge_srg);
/// let point_got = Point::new(&mut store, 42, 42);
/// let point_zsr = Point::new(&mut store, 42, 42);
/// let edge_bsg = Edge::test_default(&mut store);
/// let anchor_tjp = Anchor::new(&mut store, &point_got, &point_zsr, &edge_bsg);
/// let point_six = Point::new(&mut store, 42, 42);
/// let point_iip = Point::new(&mut store, 42, 42);
/// let edge_nww = Edge::test_default(&mut store);
/// let anchor_sbf = Anchor::new(&mut store, &point_six, &point_iip, &edge_nww);
/// let point_nzn = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_arp, &anchor_qru, &anchor_tjp, &anchor_sbf, &point_nzn);
///
/// let anchor_yyp = drawing_get_one_anch_across_r14!(associative_ui, store);
/// assert_eq!(&anchor_qru, anchor_yyp);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r14 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.one).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r14;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`AssociativeUi`][ðŸ¦ž], via _R14(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`AssociativeUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::AssociativeUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_maybe_get_one_aui_across_r14;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_gpw = Associative::default();
///
/// let point_azm = Point::new(&mut store, 42, 42);
/// let point_xge = Point::new(&mut store, 42, 42);
/// let edge_qiq = Edge::test_default(&mut store);
/// let anchor_lao = Anchor::new(&mut store, &point_azm, &point_xge, &edge_qiq);
/// let point_zim = Point::new(&mut store, 42, 42);
/// let point_eij = Point::new(&mut store, 42, 42);
/// let edge_euc = Edge::test_default(&mut store);
/// let anchor_axu = Anchor::new(&mut store, &point_zim, &point_eij, &edge_euc);
/// let point_cht = Point::new(&mut store, 42, 42);
/// let point_iwj = Point::new(&mut store, 42, 42);
/// let edge_bgb = Edge::test_default(&mut store);
/// let anchor_pul = Anchor::new(&mut store, &point_cht, &point_iwj, &edge_bgb);
/// let point_wuf = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_gpw, &anchor_lao, &anchor_axu, &anchor_pul, &point_wuf);
/// let associative_ui_kof = drawing_maybe_get_one_aui_across_r14!(anchor_lao, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_kof);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_aui_across_r14 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.one == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r14;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`IsaUi`][ðŸ¦ž], across [`SubtypeAnchors`][ðŸ¦‘] via _R10_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns a &[`IsaUi`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::IsaUi
/// [ðŸ¦‘]: crate::drawing::types::SubtypeAnchors
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::SubtypeAnchors;
/// # use sarzak::drawing_maybe_get_one_iui_across_r10;
/// # let mut store = sarzak::drawing::ObjectStore::new();
/// # let mut sarzak_store = sarzak::sarzak::ObjectStore::new();
///
/// let point_apm = Point::new(&mut store, 42, 42);
/// let point_chj = Point::new(&mut store, 42, 42);
/// let edge_wnp = Edge::test_default(&mut store);
/// let anchor_dgh = Anchor::new(&mut store, &point_apm, &point_chj, &edge_wnp);
/// let isa_gmx = Isa::test_default(&mut sarzak_store);
///
/// let point_zel = Point::new(&mut store, 42, 42);
/// let point_mdn = Point::new(&mut store, 42, 42);
/// let edge_fdk = Edge::test_default(&mut store);
/// let anchor_ltk = Anchor::new(&mut store, &point_zel, &point_mdn, &edge_fdk);
/// let isa_ui_tom = IsaUi::new(&mut store, &isa_gmx, &anchor_ltk);
/// let subtype_anchors = SubtypeAnchors::new(&mut store, &anchor_dgh, &isa_ui_tom);
///
/// let isa_ui_zre = drawing_maybe_get_one_iui_across_r10!(anchor_dgh, store);
/// assert_eq!(Some(&isa_ui_tom), isa_ui_zre);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_iui_across_r10 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_maybe_get_one
        $store
            .iter_subtype_anchors()
            .filter(|a| a.1.anchor_id == $input.id)
            .next()
            .and_then(|a| $store.exhume_isa_ui(&a.1.isaui_id))
    }};
}
pub use drawing_maybe_get_one_iui_across_r10;

/// Macro to traverse [`IsaUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], across [`SubtypeAnchors`][ðŸ¦‘] via _R10_
///
/// This macro expects a &[`IsaUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ðŸ¦€]: crate::drawing::types::IsaUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
/// [ðŸ¦‘]: crate::drawing::types::SubtypeAnchors
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::SubtypeAnchors;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::drawing_get_many_anch_across_r10;
/// # let mut store = sarzak::drawing::ObjectStore::new();
/// # let mut sarzak_store = sarzak::sarzak::ObjectStore::new();
///
/// let point_xal = Point::new(&mut store, 42, 42);
/// let point_ajm = Point::new(&mut store, 42, 42);
/// let edge_vux = Edge::test_default(&mut store);
/// let anchor_afd = Anchor::new(&mut store, &point_xal, &point_ajm, &edge_vux);
/// let isa_pqt = Isa::test_default(&mut sarzak_store);
///
/// let point_eal = Point::new(&mut store, 42, 42);
/// let point_ykw = Point::new(&mut store, 42, 42);
/// let edge_jas = Edge::test_default(&mut store);
/// let anchor_lem = Anchor::new(&mut store, &point_eal, &point_ykw, &edge_jas);
/// let isa_ui_tes = IsaUi::new(&mut store, &isa_pqt, &anchor_lem);
/// let subtype_anchors = SubtypeAnchors::new(&mut store, &anchor_afd, &isa_ui_tes);
///
/// let anchor_rjx = drawing_get_many_anch_across_r10!(isa_ui_tes, store);
/// assert!(anchor_rjx.iter().find(|&x| **x == anchor_afd).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_many_anch_across_r10 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_many
        $store
            .iter_subtype_anchors()
            .filter(|a| a.1.isaui_id == $input.id)
            .map(|a| $store.exhume_anchor(&a.1.anchor_id).unwrap())
            .collect::<Vec<&Anchor>>()
    }};
}
pub use drawing_get_many_anch_across_r10;

/// Macro to traverse [`ObjectUi`][ðŸ¦€] âž¡ [`Point`][ðŸ¦ž], via _R13_
///
/// This macro expects a &[`ObjectUi`][ðŸ¦€], and returns a &[`Point`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::ObjectUi
/// [ðŸ¦ž]: crate::drawing::types::Point
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_pnt_across_r13;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_etv = Point::new(&mut store, 42, 42);
/// let aboard_curve = "zonked_sock".to_owned();
/// let object_qah = Object::default();
///
///
/// let object_ui = ObjectUi::new(&mut store, &point_etv, &object_qah, 42, 42);
///
/// let point_yql = drawing_get_one_pnt_across_r13!(object_ui, store);
/// assert_eq!(&point_etv, point_yql);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_pnt_across_r13 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.origin).unwrap()
    }};
}
pub use drawing_get_one_pnt_across_r13;

/// Macro to traverse [`Point`][ðŸ¦€] âž¡ [`ObjectUi`][ðŸ¦ž], via _R13(c)_
///
/// This macro expects a &[`Point`][ðŸ¦€], and returns an Option<&[`ObjectUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Point
/// [ðŸ¦ž]: crate::drawing::types::ObjectUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing_maybe_get_one_oui_across_r13;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_jka = Point::new(&mut store, 42, 42);
/// let angry_jail = "tacit_face".to_owned();
/// let object_sza = Object::default();
///
///
/// let object_ui = ObjectUi::new(&mut store, &point_jka, &object_sza, 42, 42);
/// let object_ui_vrj = drawing_maybe_get_one_oui_across_r13!(point_jka, store);
///
/// assert_eq!(Some(&object_ui), object_ui_vrj);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_oui_across_r13 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-object_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_object_ui()
            .find(|z| z.1.origin == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-object_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_oui_across_r13;

/// Macro to traverse [`AssociativeUi`][ðŸ¦€] âž¡ [`Point`][ðŸ¦ž], via _R17_
///
/// This macro expects a &[`AssociativeUi`][ðŸ¦€], and returns a &[`Point`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::AssociativeUi
/// [ðŸ¦ž]: crate::drawing::types::Point
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing_get_one_pnt_across_r17;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_vmp = Associative::default();
///
/// let point_qlm = Point::new(&mut store, 42, 42);
/// let point_wlu = Point::new(&mut store, 42, 42);
/// let edge_xfo = Edge::test_default(&mut store);
/// let anchor_cwu = Anchor::new(&mut store, &point_qlm, &point_wlu, &edge_xfo);
/// let point_eob = Point::new(&mut store, 42, 42);
/// let point_wyh = Point::new(&mut store, 42, 42);
/// let edge_fds = Edge::test_default(&mut store);
/// let anchor_ogm = Anchor::new(&mut store, &point_eob, &point_wyh, &edge_fds);
/// let point_xzg = Point::new(&mut store, 42, 42);
/// let point_rkw = Point::new(&mut store, 42, 42);
/// let edge_und = Edge::test_default(&mut store);
/// let anchor_qgv = Anchor::new(&mut store, &point_xzg, &point_rkw, &edge_und);
/// let point_rba = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_vmp, &anchor_cwu, &anchor_ogm, &anchor_qgv, &point_rba);
///
/// let point_ynu = drawing_get_one_pnt_across_r17!(associative_ui, store);
/// assert_eq!(&point_rba, point_ynu);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_pnt_across_r17 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.middle).unwrap()
    }};
}
pub use drawing_get_one_pnt_across_r17;

/// Macro to traverse [`Point`][ðŸ¦€] âž¡ [`AssociativeUi`][ðŸ¦ž], via _R17(c)_
///
/// This macro expects a &[`Point`][ðŸ¦€], and returns an Option<&[`AssociativeUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Point
/// [ðŸ¦ž]: crate::drawing::types::AssociativeUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_maybe_get_one_aui_across_r17;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_rke = Associative::default();
///
/// let point_jyc = Point::new(&mut store, 42, 42);
/// let point_mnd = Point::new(&mut store, 42, 42);
/// let edge_thi = Edge::test_default(&mut store);
/// let anchor_slh = Anchor::new(&mut store, &point_jyc, &point_mnd, &edge_thi);
/// let point_ewf = Point::new(&mut store, 42, 42);
/// let point_tfu = Point::new(&mut store, 42, 42);
/// let edge_jcc = Edge::test_default(&mut store);
/// let anchor_ubu = Anchor::new(&mut store, &point_ewf, &point_tfu, &edge_jcc);
/// let point_eeq = Point::new(&mut store, 42, 42);
/// let point_fkz = Point::new(&mut store, 42, 42);
/// let edge_hdi = Edge::test_default(&mut store);
/// let anchor_ytw = Anchor::new(&mut store, &point_eeq, &point_fkz, &edge_hdi);
/// let point_mpn = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_rke, &anchor_slh, &anchor_ubu, &anchor_ytw, &point_mpn);
/// let associative_ui_tvd = drawing_maybe_get_one_aui_across_r17!(point_mpn, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_tvd);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_aui_across_r17 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.middle == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r17;

/// Macro to traverse [`ObjectEdge`][ðŸ¦€] âž¡ [`ObjectUi`][ðŸ¦ž], via _R18_
///
/// This macro expects a &[`ObjectEdge`][ðŸ¦€], and returns a &[`ObjectUi`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::ObjectEdge
/// [ðŸ¦ž]: crate::drawing::types::ObjectUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_oui_across_r18;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_djw = Edge::test_default(&mut store);
/// let point_lye = Point::new(&mut store, 42, 42);
/// let swanky_friend = "numerous_bulb".to_owned();
/// let object_gqk = Object::default();
///
/// let object_ui_xie = ObjectUi::new(&mut store, &point_lye, &object_gqk, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_djw, &object_ui_xie);
///
/// let object_ui_uhx = drawing_get_one_oui_across_r18!(object_edge, store);
/// assert_eq!(&object_ui_xie, object_ui_uhx);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_oui_across_r18 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object_ui(&$input.oui_id).unwrap()
    }};
}
pub use drawing_get_one_oui_across_r18;

/// Macro to traverse [`ObjectUi`][ðŸ¦€] âž¡ [`ObjectEdge`][ðŸ¦ž], via _R18_
///
/// This macro expects a &[`ObjectUi`][ðŸ¦€], and returns a &[`ObjectEdge`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::ObjectUi
/// [ðŸ¦ž]: crate::drawing::types::ObjectEdge
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing_get_many_oui_es_across_r18;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_eyp = Edge::test_default(&mut store);
/// let point_uog = Point::new(&mut store, 42, 42);
/// let dangerous_monkey = "crowded_flame".to_owned();
/// let object_kri = Object::default();
///
/// let object_ui_wkq = ObjectUi::new(&mut store, &point_uog, &object_kri, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_eyp, &object_ui_wkq);
/// let object_edge_inb = drawing_get_many_oui_es_across_r18!(object_ui_wkq, store);
///
/// assert!(object_edge_inb.iter().find(|&x| **x == object_edge).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_many_oui_es_across_r18 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object_ui-object_edge-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_object_edge()
            .filter_map(|z| if z.1.oui_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&ObjectEdge>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object_ui-object_edge-emit_many_conditional_lookup"}}}
    }};
}
pub use drawing_get_many_oui_es_across_r18;

/// Macro to traverse [`BinaryUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R8_
///
/// This macro expects a &[`BinaryUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::BinaryUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_get_one_anch_across_r8;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_ypw = Point::new(&mut store, 42, 42);
/// let point_zzw = Point::new(&mut store, 42, 42);
/// let edge_nme = Edge::test_default(&mut store);
/// let anchor_xlt = Anchor::new(&mut store, &point_ypw, &point_zzw, &edge_nme);
/// let point_dhl = Point::new(&mut store, 42, 42);
/// let point_mjt = Point::new(&mut store, 42, 42);
/// let edge_lka = Edge::test_default(&mut store);
/// let anchor_tqw = Anchor::new(&mut store, &point_dhl, &point_mjt, &edge_lka);
/// let binary_upp = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_xlt, &anchor_tqw, &binary_upp);
///
/// let anchor_inl = drawing_get_one_anch_across_r8!(binary_ui, store);
/// assert_eq!(&anchor_xlt, anchor_inl);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r8 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.to).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r8;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`BinaryUi`][ðŸ¦ž], via _R8(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`BinaryUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::BinaryUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_bui_across_r8;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_gcs = Point::new(&mut store, 42, 42);
/// let point_ppf = Point::new(&mut store, 42, 42);
/// let edge_lzw = Edge::test_default(&mut store);
/// let anchor_bqb = Anchor::new(&mut store, &point_gcs, &point_ppf, &edge_lzw);
/// let point_bsm = Point::new(&mut store, 42, 42);
/// let point_ndb = Point::new(&mut store, 42, 42);
/// let edge_pkb = Edge::test_default(&mut store);
/// let anchor_hbw = Anchor::new(&mut store, &point_bsm, &point_ndb, &edge_pkb);
/// let binary_exl = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_bqb, &anchor_hbw, &binary_exl);
/// let binary_ui_nsx = drawing_maybe_get_one_bui_across_r8!(anchor_bqb, store);
///
/// assert_eq!(Some(&binary_ui), binary_ui_nsx);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_bui_across_r8 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_binary_ui()
            .find(|z| z.1.to == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_bui_across_r8;

/// Macro to traverse [`AssociativeUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R16_
///
/// This macro expects a &[`AssociativeUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::AssociativeUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_get_one_anch_across_r16;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_xty = Associative::default();
///
/// let point_lgy = Point::new(&mut store, 42, 42);
/// let point_smz = Point::new(&mut store, 42, 42);
/// let edge_qan = Edge::test_default(&mut store);
/// let anchor_dgg = Anchor::new(&mut store, &point_lgy, &point_smz, &edge_qan);
/// let point_pjh = Point::new(&mut store, 42, 42);
/// let point_ufj = Point::new(&mut store, 42, 42);
/// let edge_hrq = Edge::test_default(&mut store);
/// let anchor_apn = Anchor::new(&mut store, &point_pjh, &point_ufj, &edge_hrq);
/// let point_skr = Point::new(&mut store, 42, 42);
/// let point_vwu = Point::new(&mut store, 42, 42);
/// let edge_cch = Edge::test_default(&mut store);
/// let anchor_eqb = Anchor::new(&mut store, &point_skr, &point_vwu, &edge_cch);
/// let point_xds = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_xty, &anchor_dgg, &anchor_apn, &anchor_eqb, &point_xds);
///
/// let anchor_ugg = drawing_get_one_anch_across_r16!(associative_ui, store);
/// assert_eq!(&anchor_dgg, anchor_ugg);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r16 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.from).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r16;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`AssociativeUi`][ðŸ¦ž], via _R16(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`AssociativeUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::AssociativeUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing_maybe_get_one_aui_across_r16;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_neq = Associative::default();
///
/// let point_kmp = Point::new(&mut store, 42, 42);
/// let point_elq = Point::new(&mut store, 42, 42);
/// let edge_vgi = Edge::test_default(&mut store);
/// let anchor_ipb = Anchor::new(&mut store, &point_kmp, &point_elq, &edge_vgi);
/// let point_nqt = Point::new(&mut store, 42, 42);
/// let point_qaw = Point::new(&mut store, 42, 42);
/// let edge_oxi = Edge::test_default(&mut store);
/// let anchor_ssb = Anchor::new(&mut store, &point_nqt, &point_qaw, &edge_oxi);
/// let point_zku = Point::new(&mut store, 42, 42);
/// let point_dmp = Point::new(&mut store, 42, 42);
/// let edge_kie = Edge::test_default(&mut store);
/// let anchor_ott = Anchor::new(&mut store, &point_zku, &point_dmp, &edge_kie);
/// let point_fqg = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_neq, &anchor_ipb, &anchor_ssb, &anchor_ott, &point_fqg);
/// let associative_ui_epz = drawing_maybe_get_one_aui_across_r16!(anchor_ipb, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_epz);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_aui_across_r16 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r16;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`Edge`][ðŸ¦ž], via _R3_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns a &[`Edge`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::Edge
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_get_one_edg_across_r3;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_sfy = Point::new(&mut store, 42, 42);
/// let point_sny = Point::new(&mut store, 42, 42);
/// let edge_mcz = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_sfy, &point_sny, &edge_mcz);
///
/// let edge_crz = drawing_get_one_edg_across_r3!(anchor, store);
/// assert_eq!(&edge_mcz, edge_crz);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_edg_across_r3 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_edge(&$input.edge).unwrap()
    }};
}
pub use drawing_get_one_edg_across_r3;

/// Macro to traverse [`Edge`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R3(c)_
///
/// This macro expects a &[`Edge`][ðŸ¦€], and returns an Option<&[`Anchor`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Edge
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_anch_across_r3;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_yzf = Point::new(&mut store, 42, 42);
/// let point_acn = Point::new(&mut store, 42, 42);
/// let edge_nks = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_yzf, &point_acn, &edge_nks);
/// let anchor_nyj = drawing_maybe_get_one_anch_across_r3!(edge_nks, store);
///
/// assert_eq!(Some(&anchor), anchor_nyj);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_anch_across_r3 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"edge-anchor-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.edge == $input.get_id())
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"edge-anchor-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_anch_across_r3;

/// Macro to traverse [`ObjectEdge`][ðŸ¦€] âž¡ [`Edge`][ðŸ¦ž], via _R19_
///
/// This macro expects a &[`ObjectEdge`][ðŸ¦€], and returns a &[`Edge`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::ObjectEdge
/// [ðŸ¦ž]: crate::drawing::types::Edge
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing_get_one_edg_across_r19;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_mbw = Edge::test_default(&mut store);
/// let point_bjr = Point::new(&mut store, 42, 42);
/// let savory_cellar = "selective_route".to_owned();
/// let object_tiv = Object::default();
///
/// let object_ui_nwf = ObjectUi::new(&mut store, &point_bjr, &object_tiv, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_mbw, &object_ui_nwf);
///
/// let edge_mwt = drawing_get_one_edg_across_r19!(object_edge, store);
/// assert_eq!(&edge_mbw, edge_mwt);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_edg_across_r19 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_edge(&$input.edge).unwrap()
    }};
}
pub use drawing_get_one_edg_across_r19;

/// Macro to traverse [`Edge`][ðŸ¦€] âž¡ [`ObjectEdge`][ðŸ¦ž], via _R19(c)_
///
/// This macro expects a &[`Edge`][ðŸ¦€], and returns an Option<&[`ObjectEdge`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Edge
/// [ðŸ¦ž]: crate::drawing::types::ObjectEdge
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_oui_e_across_r19;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_evk = Edge::test_default(&mut store);
/// let point_luc = Point::new(&mut store, 42, 42);
/// let aberrant_achiever = "silky_suit".to_owned();
/// let object_rwg = Object::default();
///
/// let object_ui_sxf = ObjectUi::new(&mut store, &point_luc, &object_rwg, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_evk, &object_ui_sxf);
/// let object_edge_xyu = drawing_maybe_get_one_oui_e_across_r19!(edge_evk, store);
///
/// assert_eq!(Some(&object_edge), object_edge_xyu);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_oui_e_across_r19 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"edge-object_edge-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_object_edge()
            .find(|z| z.1.edge == $input.get_id())
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"edge-object_edge-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_oui_e_across_r19;

/// Macro to traverse [`BinaryUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R7_
///
/// This macro expects a &[`BinaryUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::BinaryUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing_get_one_anch_across_r7;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_zri = Point::new(&mut store, 42, 42);
/// let point_ftm = Point::new(&mut store, 42, 42);
/// let edge_ewq = Edge::test_default(&mut store);
/// let anchor_gqe = Anchor::new(&mut store, &point_zri, &point_ftm, &edge_ewq);
/// let point_pdj = Point::new(&mut store, 42, 42);
/// let point_mrb = Point::new(&mut store, 42, 42);
/// let edge_whd = Edge::test_default(&mut store);
/// let anchor_oit = Anchor::new(&mut store, &point_pdj, &point_mrb, &edge_whd);
/// let binary_tnq = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_gqe, &anchor_oit, &binary_tnq);
///
/// let anchor_cii = drawing_get_one_anch_across_r7!(binary_ui, store);
/// assert_eq!(&anchor_gqe, anchor_cii);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r7 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.from).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r7;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`BinaryUi`][ðŸ¦ž], via _R7(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`BinaryUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::BinaryUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_bui_across_r7;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_qhv = Point::new(&mut store, 42, 42);
/// let point_opg = Point::new(&mut store, 42, 42);
/// let edge_col = Edge::test_default(&mut store);
/// let anchor_vkj = Anchor::new(&mut store, &point_qhv, &point_opg, &edge_col);
/// let point_igv = Point::new(&mut store, 42, 42);
/// let point_ivb = Point::new(&mut store, 42, 42);
/// let edge_nke = Edge::test_default(&mut store);
/// let anchor_rom = Anchor::new(&mut store, &point_igv, &point_ivb, &edge_nke);
/// let binary_axa = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_vkj, &anchor_rom, &binary_axa);
/// let binary_ui_cfy = drawing_maybe_get_one_bui_across_r7!(anchor_vkj, store);
///
/// assert_eq!(Some(&binary_ui), binary_ui_cfy);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_bui_across_r7 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_binary_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_bui_across_r7;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`Point`][ðŸ¦ž], via _R4_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns a &[`Point`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::Point
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_pnt_across_r4;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_fhy = Point::new(&mut store, 42, 42);
/// let point_qld = Point::new(&mut store, 42, 42);
/// let edge_few = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_fhy, &point_qld, &edge_few);
///
/// let point_tns = drawing_get_one_pnt_across_r4!(anchor, store);
/// assert_eq!(&point_fhy, point_tns);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_pnt_across_r4 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.location).unwrap()
    }};
}
pub use drawing_get_one_pnt_across_r4;

/// Macro to traverse [`Point`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R4(c)_
///
/// This macro expects a &[`Point`][ðŸ¦€], and returns an Option<&[`Anchor`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Point
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_maybe_get_one_anch_across_r4;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_emt = Point::new(&mut store, 42, 42);
/// let point_fow = Point::new(&mut store, 42, 42);
/// let edge_pjs = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_emt, &point_fow, &edge_pjs);
/// let anchor_xnw = drawing_maybe_get_one_anch_across_r4!(point_emt, store);
///
/// assert_eq!(Some(&anchor), anchor_xnw);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_anch_across_r4 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.location == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_anch_across_r4;
