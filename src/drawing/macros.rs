//! Macros for navigating the "Drawing" domain
//!
//! # Generated Code -- edit _with care_.
//!
//! Don't mess with anything between `{"magic":"îž¨","kind":"CriticalBlockBegin"}`
//! and `{"magic":"îž¨","kind":"CriticalBlockEnd"}`. Otherwise, you should be free
//! to go wild. Happy hacking!
//!
//! Use the following invocation to reproduce:
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
//! ```shell
//!  sarzak gen
//! ```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
// {"magic":"îž¨","version":"0.5.0"}
// {"magic":"îž¨","version":"1.0.0"}

/// Macro to traverse [`IsaUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R9_
///
/// This macro expects a &[`IsaUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::IsaUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing_get_one_anch_across_r9;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let isa_agl = Isa::default();
///
/// let point_tvm = Point::new(&mut store, 42, 42);
/// let point_tct = Point::new(&mut store, 42, 42);
/// let edge_xcp = Edge::test_default(&mut store);
/// let anchor_gph = Anchor::new(&mut store, &point_tvm, &point_tct, &edge_xcp);
///
/// let isa_ui = IsaUi::new(&mut store, &isa_agl, &anchor_gph);
///
/// let anchor_ixp = drawing_get_one_anch_across_r9!(isa_ui, store);
/// assert_eq!(&anchor_gph, anchor_ixp);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_anch_across_r9-emit_binary_main"}}}
macro_rules! drawing_get_one_anch_across_r9 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.from).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_anch_across_r9;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_anch_across_r9-emit_binary_main"}}}

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`IsaUi`][ðŸ¦ž], via _R9(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`IsaUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::IsaUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_maybe_get_one_iui_across_r9;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let isa_dzx = Isa::default();
///
/// let point_ryo = Point::new(&mut store, 42, 42);
/// let point_ekt = Point::new(&mut store, 42, 42);
/// let edge_ykm = Edge::test_default(&mut store);
/// let anchor_qxd = Anchor::new(&mut store, &point_ryo, &point_ekt, &edge_ykm);
///
/// let isa_ui = IsaUi::new(&mut store, &isa_dzx, &anchor_qxd);
/// let isa_ui_cwk = drawing_maybe_get_one_iui_across_r9!(anchor_qxd, store);
///
/// assert_eq!(Some(&isa_ui), isa_ui_cwk);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_iui_across_r9-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_iui_across_r9 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-isa_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_isa_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-isa_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_iui_across_r9;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_iui_across_r9-emit_binary_main"}}}

/// Macro to traverse [`AssociativeUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R15_
///
/// This macro expects a &[`AssociativeUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::AssociativeUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_get_one_anch_across_r15;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_ann = Associative::default();
///
/// let point_stu = Point::new(&mut store, 42, 42);
/// let point_qel = Point::new(&mut store, 42, 42);
/// let edge_dsz = Edge::test_default(&mut store);
/// let anchor_vzl = Anchor::new(&mut store, &point_stu, &point_qel, &edge_dsz);
/// let point_dlm = Point::new(&mut store, 42, 42);
/// let point_ikx = Point::new(&mut store, 42, 42);
/// let edge_rer = Edge::test_default(&mut store);
/// let anchor_ove = Anchor::new(&mut store, &point_dlm, &point_ikx, &edge_rer);
/// let point_kfx = Point::new(&mut store, 42, 42);
/// let point_lho = Point::new(&mut store, 42, 42);
/// let edge_xkl = Edge::test_default(&mut store);
/// let anchor_fxr = Anchor::new(&mut store, &point_kfx, &point_lho, &edge_xkl);
/// let point_ovr = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_ann, &anchor_vzl, &anchor_ove, &anchor_fxr, &point_ovr);
///
/// let anchor_itv = drawing_get_one_anch_across_r15!(associative_ui, store);
/// assert_eq!(&anchor_vzl, anchor_itv);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_anch_across_r15-emit_binary_main"}}}
macro_rules! drawing_get_one_anch_across_r15 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.other).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_anch_across_r15;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_anch_across_r15-emit_binary_main"}}}

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`AssociativeUi`][ðŸ¦ž], via _R15(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`AssociativeUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::AssociativeUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_aui_across_r15;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_kwo = Associative::default();
///
/// let point_ytn = Point::new(&mut store, 42, 42);
/// let point_vze = Point::new(&mut store, 42, 42);
/// let edge_jka = Edge::test_default(&mut store);
/// let anchor_wbp = Anchor::new(&mut store, &point_ytn, &point_vze, &edge_jka);
/// let point_etf = Point::new(&mut store, 42, 42);
/// let point_gyy = Point::new(&mut store, 42, 42);
/// let edge_zvk = Edge::test_default(&mut store);
/// let anchor_kgd = Anchor::new(&mut store, &point_etf, &point_gyy, &edge_zvk);
/// let point_mer = Point::new(&mut store, 42, 42);
/// let point_mej = Point::new(&mut store, 42, 42);
/// let edge_cky = Edge::test_default(&mut store);
/// let anchor_fnu = Anchor::new(&mut store, &point_mer, &point_mej, &edge_cky);
/// let point_jxe = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_kwo, &anchor_wbp, &anchor_kgd, &anchor_fnu, &point_jxe);
/// let associative_ui_fzk = drawing_maybe_get_one_aui_across_r15!(anchor_wbp, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_fzk);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_aui_across_r15-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_aui_across_r15 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.other == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r15;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_aui_across_r15-emit_binary_main"}}}

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`Point`][ðŸ¦ž], via _R5_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns a &[`Point`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::Point
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_pnt_across_r5;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_kmc = Point::new(&mut store, 42, 42);
/// let point_xxh = Point::new(&mut store, 42, 42);
/// let edge_qhk = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_kmc, &point_xxh, &edge_qhk);
///
/// let point_zrh = drawing_get_one_pnt_across_r5!(anchor, store);
/// assert_eq!(&point_kmc, point_zrh);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_pnt_across_r5-emit_binary_main"}}}
macro_rules! drawing_get_one_pnt_across_r5 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.offset).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_pnt_across_r5;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_pnt_across_r5-emit_binary_main"}}}

/// Macro to traverse [`Point`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R5(c)_
///
/// This macro expects a &[`Point`][ðŸ¦€], and returns an Option<&[`Anchor`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Point
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_maybe_get_one_anch_across_r5;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_wrd = Point::new(&mut store, 42, 42);
/// let point_qnk = Point::new(&mut store, 42, 42);
/// let edge_iax = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_wrd, &point_qnk, &edge_iax);
/// let anchor_ynb = drawing_maybe_get_one_anch_across_r5!(point_wrd, store);
///
/// assert_eq!(Some(&anchor), anchor_ynb);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_anch_across_r5-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_anch_across_r5 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.offset == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_anch_across_r5;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_anch_across_r5-emit_binary_main"}}}

/// Macro to traverse [`AssociativeUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R14_
///
/// This macro expects a &[`AssociativeUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::AssociativeUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing_get_one_anch_across_r14;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_dch = Associative::default();
///
/// let point_wwy = Point::new(&mut store, 42, 42);
/// let point_dhw = Point::new(&mut store, 42, 42);
/// let edge_nzd = Edge::test_default(&mut store);
/// let anchor_jah = Anchor::new(&mut store, &point_wwy, &point_dhw, &edge_nzd);
/// let point_ovm = Point::new(&mut store, 42, 42);
/// let point_nzu = Point::new(&mut store, 42, 42);
/// let edge_xky = Edge::test_default(&mut store);
/// let anchor_kdd = Anchor::new(&mut store, &point_ovm, &point_nzu, &edge_xky);
/// let point_cab = Point::new(&mut store, 42, 42);
/// let point_rwf = Point::new(&mut store, 42, 42);
/// let edge_lpl = Edge::test_default(&mut store);
/// let anchor_fsc = Anchor::new(&mut store, &point_cab, &point_rwf, &edge_lpl);
/// let point_cxn = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_dch, &anchor_jah, &anchor_kdd, &anchor_fsc, &point_cxn);
///
/// let anchor_elf = drawing_get_one_anch_across_r14!(associative_ui, store);
/// assert_eq!(&anchor_jah, anchor_elf);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_anch_across_r14-emit_binary_main"}}}
macro_rules! drawing_get_one_anch_across_r14 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.one).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_anch_across_r14;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_anch_across_r14-emit_binary_main"}}}

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`AssociativeUi`][ðŸ¦ž], via _R14(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`AssociativeUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::AssociativeUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_maybe_get_one_aui_across_r14;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_mgo = Associative::default();
///
/// let point_nyg = Point::new(&mut store, 42, 42);
/// let point_xkk = Point::new(&mut store, 42, 42);
/// let edge_dmu = Edge::test_default(&mut store);
/// let anchor_nql = Anchor::new(&mut store, &point_nyg, &point_xkk, &edge_dmu);
/// let point_lje = Point::new(&mut store, 42, 42);
/// let point_moc = Point::new(&mut store, 42, 42);
/// let edge_rzg = Edge::test_default(&mut store);
/// let anchor_xvj = Anchor::new(&mut store, &point_lje, &point_moc, &edge_rzg);
/// let point_kxd = Point::new(&mut store, 42, 42);
/// let point_eua = Point::new(&mut store, 42, 42);
/// let edge_vpm = Edge::test_default(&mut store);
/// let anchor_idm = Anchor::new(&mut store, &point_kxd, &point_eua, &edge_vpm);
/// let point_kpo = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_mgo, &anchor_nql, &anchor_xvj, &anchor_idm, &point_kpo);
/// let associative_ui_qiy = drawing_maybe_get_one_aui_across_r14!(anchor_nql, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_qiy);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_aui_across_r14-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_aui_across_r14 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.one == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r14;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_aui_across_r14-emit_binary_main"}}}

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`IsaUi`][ðŸ¦ž], across [`SubtypeAnchors`][ðŸ¦‘] via _R10_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns a &[`IsaUi`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::IsaUi
/// [ðŸ¦‘]: crate::drawing::types::SubtypeAnchors
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::SubtypeAnchors;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_iui_across_r10;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_nyq = Point::new(&mut store, 42, 42);
/// let point_jmd = Point::new(&mut store, 42, 42);
/// let edge_itm = Edge::test_default(&mut store);
/// let anchor_rub = Anchor::new(&mut store, &point_nyq, &point_jmd, &edge_itm);
/// let isa_ncg = Isa::default();
///
/// let point_yvo = Point::new(&mut store, 42, 42);
/// let point_sae = Point::new(&mut store, 42, 42);
/// let edge_enj = Edge::test_default(&mut store);
/// let anchor_rpu = Anchor::new(&mut store, &point_yvo, &point_sae, &edge_enj);
/// let isa_ui_umv = IsaUi::new(&mut store, &isa_ncg, &anchor_rpu);
/// let subtype_anchors = SubtypeAnchors::new(&mut store, &anchor_rub, &isa_ui_umv);
///
/// let isa_ui_fga = drawing_maybe_get_one_iui_across_r10!(anchor_rub, store);
/// assert_eq!(Some(&isa_ui_umv), isa_ui_fga);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_iui_across_r10-emit_associative_main"}}}
macro_rules! drawing_maybe_get_one_iui_across_r10 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_maybe_get_one
        $store
            .iter_subtype_anchors()
            .filter(|a| a.1.anchor_id == $input.id)
            .next()
            .and_then(|a| $store.exhume_isa_ui(&a.1.isaui_id))
    }};
}
pub use drawing_maybe_get_one_iui_across_r10;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_iui_across_r10-emit_associative_main"}}}

/// Macro to traverse [`IsaUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], across [`SubtypeAnchors`][ðŸ¦‘] via _R10_
///
/// This macro expects a &[`IsaUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ðŸ¦€]: crate::drawing::types::IsaUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
/// [ðŸ¦‘]: crate::drawing::types::SubtypeAnchors
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::SubtypeAnchors;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_get_many_anch_across_r10;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_yof = Point::new(&mut store, 42, 42);
/// let point_ied = Point::new(&mut store, 42, 42);
/// let edge_gwy = Edge::test_default(&mut store);
/// let anchor_dzo = Anchor::new(&mut store, &point_yof, &point_ied, &edge_gwy);
/// let isa_rpu = Isa::default();
///
/// let point_cvd = Point::new(&mut store, 42, 42);
/// let point_lrj = Point::new(&mut store, 42, 42);
/// let edge_qqu = Edge::test_default(&mut store);
/// let anchor_yht = Anchor::new(&mut store, &point_cvd, &point_lrj, &edge_qqu);
/// let isa_ui_xew = IsaUi::new(&mut store, &isa_rpu, &anchor_yht);
/// let subtype_anchors = SubtypeAnchors::new(&mut store, &anchor_dzo, &isa_ui_xew);
///
/// let anchor_tsc = drawing_get_many_anch_across_r10!(isa_ui_xew, store);
/// assert!(anchor_tsc.iter().find(|&x| **x == anchor_dzo).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_many_anch_across_r10-emit_associative_main"}}}
macro_rules! drawing_get_many_anch_across_r10 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_many
        $store
            .iter_subtype_anchors()
            .filter(|a| a.1.isaui_id == $input.id)
            .map(|a| $store.exhume_anchor(&a.1.anchor_id).unwrap())
            .collect::<Vec<&Anchor>>()
    }};
}
pub use drawing_get_many_anch_across_r10;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_many_anch_across_r10-emit_associative_main"}}}

/// Macro to traverse [`ObjectUi`][ðŸ¦€] âž¡ [`Point`][ðŸ¦ž], via _R13_
///
/// This macro expects a &[`ObjectUi`][ðŸ¦€], and returns a &[`Point`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::ObjectUi
/// [ðŸ¦ž]: crate::drawing::types::Point
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing_get_one_pnt_across_r13;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_uea = Point::new(&mut store, 42, 42);
/// let decisive_activity = "first_condition".to_owned();
/// let object_cia = Object::default();
///
///
/// let object_ui = ObjectUi::new(&mut store, &point_uea, &object_cia, 42, 42);
///
/// let point_dmc = drawing_get_one_pnt_across_r13!(object_ui, store);
/// assert_eq!(&point_uea, point_dmc);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_pnt_across_r13-emit_binary_main"}}}
macro_rules! drawing_get_one_pnt_across_r13 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.origin).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_pnt_across_r13;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_pnt_across_r13-emit_binary_main"}}}

/// Macro to traverse [`Point`][ðŸ¦€] âž¡ [`ObjectUi`][ðŸ¦ž], via _R13(c)_
///
/// This macro expects a &[`Point`][ðŸ¦€], and returns an Option<&[`ObjectUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Point
/// [ðŸ¦ž]: crate::drawing::types::ObjectUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing_maybe_get_one_oui_across_r13;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_aio = Point::new(&mut store, 42, 42);
/// let lonely_quicksand = "far_flung_sister".to_owned();
/// let object_rvy = Object::default();
///
///
/// let object_ui = ObjectUi::new(&mut store, &point_aio, &object_rvy, 42, 42);
/// let object_ui_bxr = drawing_maybe_get_one_oui_across_r13!(point_aio, store);
///
/// assert_eq!(Some(&object_ui), object_ui_bxr);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_oui_across_r13-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_oui_across_r13 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-object_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_object_ui()
            .find(|z| z.1.origin == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-object_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_oui_across_r13;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_oui_across_r13-emit_binary_main"}}}

/// Macro to traverse [`AssociativeUi`][ðŸ¦€] âž¡ [`Point`][ðŸ¦ž], via _R17_
///
/// This macro expects a &[`AssociativeUi`][ðŸ¦€], and returns a &[`Point`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::AssociativeUi
/// [ðŸ¦ž]: crate::drawing::types::Point
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_pnt_across_r17;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_egm = Associative::default();
///
/// let point_ngx = Point::new(&mut store, 42, 42);
/// let point_mpb = Point::new(&mut store, 42, 42);
/// let edge_ngm = Edge::test_default(&mut store);
/// let anchor_ooy = Anchor::new(&mut store, &point_ngx, &point_mpb, &edge_ngm);
/// let point_hnz = Point::new(&mut store, 42, 42);
/// let point_yyg = Point::new(&mut store, 42, 42);
/// let edge_kqy = Edge::test_default(&mut store);
/// let anchor_wib = Anchor::new(&mut store, &point_hnz, &point_yyg, &edge_kqy);
/// let point_azu = Point::new(&mut store, 42, 42);
/// let point_yip = Point::new(&mut store, 42, 42);
/// let edge_gtc = Edge::test_default(&mut store);
/// let anchor_aom = Anchor::new(&mut store, &point_azu, &point_yip, &edge_gtc);
/// let point_slf = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_egm, &anchor_ooy, &anchor_wib, &anchor_aom, &point_slf);
///
/// let point_yjo = drawing_get_one_pnt_across_r17!(associative_ui, store);
/// assert_eq!(&point_slf, point_yjo);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_pnt_across_r17-emit_binary_main"}}}
macro_rules! drawing_get_one_pnt_across_r17 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.from).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_pnt_across_r17;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_pnt_across_r17-emit_binary_main"}}}

/// Macro to traverse [`Point`][ðŸ¦€] âž¡ [`AssociativeUi`][ðŸ¦ž], via _R17(c)_
///
/// This macro expects a &[`Point`][ðŸ¦€], and returns an Option<&[`AssociativeUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Point
/// [ðŸ¦ž]: crate::drawing::types::AssociativeUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing_maybe_get_one_aui_across_r17;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_kod = Associative::default();
///
/// let point_sbv = Point::new(&mut store, 42, 42);
/// let point_lsu = Point::new(&mut store, 42, 42);
/// let edge_ywn = Edge::test_default(&mut store);
/// let anchor_cgf = Anchor::new(&mut store, &point_sbv, &point_lsu, &edge_ywn);
/// let point_osv = Point::new(&mut store, 42, 42);
/// let point_xzz = Point::new(&mut store, 42, 42);
/// let edge_mlu = Edge::test_default(&mut store);
/// let anchor_zwj = Anchor::new(&mut store, &point_osv, &point_xzz, &edge_mlu);
/// let point_xnu = Point::new(&mut store, 42, 42);
/// let point_twy = Point::new(&mut store, 42, 42);
/// let edge_gzq = Edge::test_default(&mut store);
/// let anchor_vnh = Anchor::new(&mut store, &point_xnu, &point_twy, &edge_gzq);
/// let point_cfy = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_kod, &anchor_cgf, &anchor_zwj, &anchor_vnh, &point_cfy);
/// let associative_ui_nmb = drawing_maybe_get_one_aui_across_r17!(point_cfy, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_nmb);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_aui_across_r17-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_aui_across_r17 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r17;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_aui_across_r17-emit_binary_main"}}}

/// Macro to traverse [`ObjectEdge`][ðŸ¦€] âž¡ [`ObjectUi`][ðŸ¦ž], via _R18_
///
/// This macro expects a &[`ObjectEdge`][ðŸ¦€], and returns a &[`ObjectUi`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::ObjectEdge
/// [ðŸ¦ž]: crate::drawing::types::ObjectUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing_get_one_oui_across_r18;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_vse = Edge::test_default(&mut store);
/// let point_nml = Point::new(&mut store, 42, 42);
/// let overjoyed_chair = "guiltless_channel".to_owned();
/// let object_wuv = Object::default();
///
/// let object_ui_ozk = ObjectUi::new(&mut store, &point_nml, &object_wuv, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_vse, &object_ui_ozk);
///
/// let object_ui_xwc = drawing_get_one_oui_across_r18!(object_edge, store);
/// assert_eq!(&object_ui_ozk, object_ui_xwc);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_oui_across_r18-emit_binary_main"}}}
macro_rules! drawing_get_one_oui_across_r18 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object_ui-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object_ui(&$input.oui_id).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object_ui-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_oui_across_r18;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_oui_across_r18-emit_binary_main"}}}

/// Macro to traverse [`ObjectUi`][ðŸ¦€] âž¡ [`ObjectEdge`][ðŸ¦ž], via _R18_
///
/// This macro expects a &[`ObjectUi`][ðŸ¦€], and returns a &[`ObjectEdge`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::ObjectUi
/// [ðŸ¦ž]: crate::drawing::types::ObjectEdge
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing_get_many_oui_es_across_r18;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_cab = Edge::test_default(&mut store);
/// let point_pcv = Point::new(&mut store, 42, 42);
/// let green_action = "fine_idea".to_owned();
/// let object_xwk = Object::default();
///
/// let object_ui_nck = ObjectUi::new(&mut store, &point_pcv, &object_xwk, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_cab, &object_ui_nck);
/// let object_edge_ydz = drawing_get_many_oui_es_across_r18!(object_ui_nck, store);
///
/// assert!(object_edge_ydz.iter().find(|&x| **x == object_edge).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_many_oui_es_across_r18-emit_binary_main"}}}
macro_rules! drawing_get_many_oui_es_across_r18 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object_ui-object_edge-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_object_edge()
            .filter_map(|z| if z.1.oui_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&ObjectEdge>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object_ui-object_edge-emit_many_conditional_lookup"}}}
    }};
}
pub use drawing_get_many_oui_es_across_r18;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_many_oui_es_across_r18-emit_binary_main"}}}

/// Macro to traverse [`BinaryUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R8_
///
/// This macro expects a &[`BinaryUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::BinaryUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing_get_one_anch_across_r8;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_slv = Point::new(&mut store, 42, 42);
/// let point_ahn = Point::new(&mut store, 42, 42);
/// let edge_cxh = Edge::test_default(&mut store);
/// let anchor_url = Anchor::new(&mut store, &point_slv, &point_ahn, &edge_cxh);
/// let point_gmi = Point::new(&mut store, 42, 42);
/// let point_hkb = Point::new(&mut store, 42, 42);
/// let edge_sro = Edge::test_default(&mut store);
/// let anchor_bct = Anchor::new(&mut store, &point_gmi, &point_hkb, &edge_sro);
/// let binary_xun = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_url, &anchor_bct, &binary_xun);
///
/// let anchor_jcp = drawing_get_one_anch_across_r8!(binary_ui, store);
/// assert_eq!(&anchor_url, anchor_jcp);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_anch_across_r8-emit_binary_main"}}}
macro_rules! drawing_get_one_anch_across_r8 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.to).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_anch_across_r8;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_anch_across_r8-emit_binary_main"}}}

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`BinaryUi`][ðŸ¦ž], via _R8(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`BinaryUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::BinaryUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing_maybe_get_one_bui_across_r8;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_dtf = Point::new(&mut store, 42, 42);
/// let point_ypu = Point::new(&mut store, 42, 42);
/// let edge_txx = Edge::test_default(&mut store);
/// let anchor_zio = Anchor::new(&mut store, &point_dtf, &point_ypu, &edge_txx);
/// let point_pra = Point::new(&mut store, 42, 42);
/// let point_ymo = Point::new(&mut store, 42, 42);
/// let edge_lma = Edge::test_default(&mut store);
/// let anchor_sfz = Anchor::new(&mut store, &point_pra, &point_ymo, &edge_lma);
/// let binary_pgt = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_zio, &anchor_sfz, &binary_pgt);
/// let binary_ui_apt = drawing_maybe_get_one_bui_across_r8!(anchor_zio, store);
///
/// assert_eq!(Some(&binary_ui), binary_ui_apt);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_bui_across_r8-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_bui_across_r8 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_binary_ui()
            .find(|z| z.1.to == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_bui_across_r8;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_bui_across_r8-emit_binary_main"}}}

/// Macro to traverse [`AssociativeUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R16_
///
/// This macro expects a &[`AssociativeUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::AssociativeUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_get_one_anch_across_r16;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_paf = Associative::default();
///
/// let point_zxu = Point::new(&mut store, 42, 42);
/// let point_kwa = Point::new(&mut store, 42, 42);
/// let edge_dln = Edge::test_default(&mut store);
/// let anchor_rfg = Anchor::new(&mut store, &point_zxu, &point_kwa, &edge_dln);
/// let point_sqa = Point::new(&mut store, 42, 42);
/// let point_bkb = Point::new(&mut store, 42, 42);
/// let edge_iox = Edge::test_default(&mut store);
/// let anchor_urt = Anchor::new(&mut store, &point_sqa, &point_bkb, &edge_iox);
/// let point_ukx = Point::new(&mut store, 42, 42);
/// let point_egp = Point::new(&mut store, 42, 42);
/// let edge_opp = Edge::test_default(&mut store);
/// let anchor_mgh = Anchor::new(&mut store, &point_ukx, &point_egp, &edge_opp);
/// let point_vsv = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_paf, &anchor_rfg, &anchor_urt, &anchor_mgh, &point_vsv);
///
/// let anchor_ivb = drawing_get_one_anch_across_r16!(associative_ui, store);
/// assert_eq!(&anchor_rfg, anchor_ivb);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_anch_across_r16-emit_binary_main"}}}
macro_rules! drawing_get_one_anch_across_r16 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.middle).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_anch_across_r16;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_anch_across_r16-emit_binary_main"}}}

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`AssociativeUi`][ðŸ¦ž], via _R16(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`AssociativeUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::AssociativeUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_aui_across_r16;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_uua = Associative::default();
///
/// let point_uzt = Point::new(&mut store, 42, 42);
/// let point_vef = Point::new(&mut store, 42, 42);
/// let edge_hky = Edge::test_default(&mut store);
/// let anchor_tni = Anchor::new(&mut store, &point_uzt, &point_vef, &edge_hky);
/// let point_pwu = Point::new(&mut store, 42, 42);
/// let point_snr = Point::new(&mut store, 42, 42);
/// let edge_dae = Edge::test_default(&mut store);
/// let anchor_aks = Anchor::new(&mut store, &point_pwu, &point_snr, &edge_dae);
/// let point_chj = Point::new(&mut store, 42, 42);
/// let point_lgj = Point::new(&mut store, 42, 42);
/// let edge_aio = Edge::test_default(&mut store);
/// let anchor_yzx = Anchor::new(&mut store, &point_chj, &point_lgj, &edge_aio);
/// let point_vya = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_uua, &anchor_tni, &anchor_aks, &anchor_yzx, &point_vya);
/// let associative_ui_ykc = drawing_maybe_get_one_aui_across_r16!(anchor_tni, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_ykc);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_aui_across_r16-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_aui_across_r16 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.middle == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r16;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_aui_across_r16-emit_binary_main"}}}

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`Edge`][ðŸ¦ž], via _R3_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns a &[`Edge`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::Edge
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_edg_across_r3;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_kob = Point::new(&mut store, 42, 42);
/// let point_fya = Point::new(&mut store, 42, 42);
/// let edge_iyx = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_kob, &point_fya, &edge_iyx);
///
/// let edge_qab = drawing_get_one_edg_across_r3!(anchor, store);
/// assert_eq!(&edge_iyx, edge_qab);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_edg_across_r3-emit_binary_main"}}}
macro_rules! drawing_get_one_edg_across_r3 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"edge-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_edge(&$input.edge).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"edge-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_edg_across_r3;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_edg_across_r3-emit_binary_main"}}}

/// Macro to traverse [`Edge`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R3(c)_
///
/// This macro expects a &[`Edge`][ðŸ¦€], and returns an Option<&[`Anchor`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Edge
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_anch_across_r3;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_snt = Point::new(&mut store, 42, 42);
/// let point_vzq = Point::new(&mut store, 42, 42);
/// let edge_uqy = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_snt, &point_vzq, &edge_uqy);
/// let anchor_znb = drawing_maybe_get_one_anch_across_r3!(edge_uqy, store);
///
/// assert_eq!(Some(&anchor), anchor_znb);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_anch_across_r3-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_anch_across_r3 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"edge-anchor-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.edge == $input.get_id())
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"edge-anchor-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_anch_across_r3;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_anch_across_r3-emit_binary_main"}}}

/// Macro to traverse [`ObjectEdge`][ðŸ¦€] âž¡ [`Edge`][ðŸ¦ž], via _R19_
///
/// This macro expects a &[`ObjectEdge`][ðŸ¦€], and returns a &[`Edge`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::ObjectEdge
/// [ðŸ¦ž]: crate::drawing::types::Edge
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing_get_one_edg_across_r19;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_wll = Edge::test_default(&mut store);
/// let point_vyf = Point::new(&mut store, 42, 42);
/// let tidy_suit = "brave_twist".to_owned();
/// let object_ldh = Object::default();
///
/// let object_ui_gsk = ObjectUi::new(&mut store, &point_vyf, &object_ldh, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_wll, &object_ui_gsk);
///
/// let edge_evi = drawing_get_one_edg_across_r19!(object_edge, store);
/// assert_eq!(&edge_wll, edge_evi);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_edg_across_r19-emit_binary_main"}}}
macro_rules! drawing_get_one_edg_across_r19 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"edge-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_edge(&$input.edge).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"edge-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_edg_across_r19;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_edg_across_r19-emit_binary_main"}}}

/// Macro to traverse [`Edge`][ðŸ¦€] âž¡ [`ObjectEdge`][ðŸ¦ž], via _R19(c)_
///
/// This macro expects a &[`Edge`][ðŸ¦€], and returns an Option<&[`ObjectEdge`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Edge
/// [ðŸ¦ž]: crate::drawing::types::ObjectEdge
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_oui_e_across_r19;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_oxt = Edge::test_default(&mut store);
/// let point_lzf = Point::new(&mut store, 42, 42);
/// let hot_comfort = "uttermost_clouds".to_owned();
/// let object_uii = Object::default();
///
/// let object_ui_hkl = ObjectUi::new(&mut store, &point_lzf, &object_uii, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_oxt, &object_ui_hkl);
/// let object_edge_nly = drawing_maybe_get_one_oui_e_across_r19!(edge_oxt, store);
///
/// assert_eq!(Some(&object_edge), object_edge_nly);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_oui_e_across_r19-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_oui_e_across_r19 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"edge-object_edge-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_object_edge()
            .find(|z| z.1.edge == $input.get_id())
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"edge-object_edge-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_oui_e_across_r19;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_oui_e_across_r19-emit_binary_main"}}}

/// Macro to traverse [`BinaryUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R7_
///
/// This macro expects a &[`BinaryUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::BinaryUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing_get_one_anch_across_r7;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_llc = Point::new(&mut store, 42, 42);
/// let point_xjy = Point::new(&mut store, 42, 42);
/// let edge_gcs = Edge::test_default(&mut store);
/// let anchor_yda = Anchor::new(&mut store, &point_llc, &point_xjy, &edge_gcs);
/// let point_uwn = Point::new(&mut store, 42, 42);
/// let point_dff = Point::new(&mut store, 42, 42);
/// let edge_tne = Edge::test_default(&mut store);
/// let anchor_usx = Anchor::new(&mut store, &point_uwn, &point_dff, &edge_tne);
/// let binary_gqg = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_yda, &anchor_usx, &binary_gqg);
///
/// let anchor_qwa = drawing_get_one_anch_across_r7!(binary_ui, store);
/// assert_eq!(&anchor_yda, anchor_qwa);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_anch_across_r7-emit_binary_main"}}}
macro_rules! drawing_get_one_anch_across_r7 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.from).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_anch_across_r7;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_anch_across_r7-emit_binary_main"}}}

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`BinaryUi`][ðŸ¦ž], via _R7(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`BinaryUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::BinaryUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_maybe_get_one_bui_across_r7;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_bjs = Point::new(&mut store, 42, 42);
/// let point_caq = Point::new(&mut store, 42, 42);
/// let edge_vdh = Edge::test_default(&mut store);
/// let anchor_vst = Anchor::new(&mut store, &point_bjs, &point_caq, &edge_vdh);
/// let point_vfy = Point::new(&mut store, 42, 42);
/// let point_hje = Point::new(&mut store, 42, 42);
/// let edge_lli = Edge::test_default(&mut store);
/// let anchor_lvu = Anchor::new(&mut store, &point_vfy, &point_hje, &edge_lli);
/// let binary_erc = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_vst, &anchor_lvu, &binary_erc);
/// let binary_ui_sgd = drawing_maybe_get_one_bui_across_r7!(anchor_vst, store);
///
/// assert_eq!(Some(&binary_ui), binary_ui_sgd);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_bui_across_r7-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_bui_across_r7 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_binary_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_bui_across_r7;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_bui_across_r7-emit_binary_main"}}}

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`Point`][ðŸ¦ž], via _R4_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns a &[`Point`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::Point
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_pnt_across_r4;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_vcf = Point::new(&mut store, 42, 42);
/// let point_xmy = Point::new(&mut store, 42, 42);
/// let edge_fpj = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_vcf, &point_xmy, &edge_fpj);
///
/// let point_gqk = drawing_get_one_pnt_across_r4!(anchor, store);
/// assert_eq!(&point_vcf, point_gqk);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_pnt_across_r4-emit_binary_main"}}}
macro_rules! drawing_get_one_pnt_across_r4 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.location).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_pnt_across_r4;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_pnt_across_r4-emit_binary_main"}}}

/// Macro to traverse [`Point`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R4(c)_
///
/// This macro expects a &[`Point`][ðŸ¦€], and returns an Option<&[`Anchor`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Point
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_maybe_get_one_anch_across_r4;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_hah = Point::new(&mut store, 42, 42);
/// let point_upt = Point::new(&mut store, 42, 42);
/// let edge_vjf = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_hah, &point_upt, &edge_vjf);
/// let anchor_sfg = drawing_maybe_get_one_anch_across_r4!(point_hah, store);
///
/// assert_eq!(Some(&anchor), anchor_sfg);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_anch_across_r4-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_anch_across_r4 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.location == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_anch_across_r4;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_anch_across_r4-emit_binary_main"}}}
