//! {"magic":"","version":"0.0.1"}
//! Macros for navigating the "Drawing" domain
//!
//! Generated Code -- edit _carefully_.
//! Don't mess with anything between {"magic":"","kind":"CriticalBlockBegin"}
//! and {"magic":"","kind":"CriticalBlockEnd"}. Otherwise, you should be free
//! to go wild. Happy hacking!
//! Use the following invocation to reproduce:
//! ```shell
//!  sarzak gen
//! ```

/// Macro to traverse [`IsaUi`][🦀] ➡ [`Anchor`][🦞], via _R9_
///
/// This macro expects a &[`IsaUi`][🦀], and returns a &[`Anchor`][🦞].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [🦀]: crate::drawing::types::IsaUi
/// [🦞]: crate::drawing::types::Anchor
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_anch_across_r9;
/// # let mut store = sarzak::drawing::ObjectStore::new();
/// # let mut sarzak_store = sarzak::sarzak::ObjectStore::new();
///
/// let isa_cik = Isa::test_default(&mut sarzak_store);
///
/// let point_gvh = Point::new(&mut store, 42, 42);
/// let point_ful = Point::new(&mut store, 42, 42);
/// let edge_ycy = Edge::test_default(&mut store);
/// let anchor_wpm = Anchor::new(&mut store, &point_gvh, &point_ful, &edge_ycy);
///
/// let isa_ui = IsaUi::new(&mut store, &isa_cik, &anchor_wpm);
///
/// let anchor_bko = drawing_get_one_anch_across_r9!(isa_ui, store);
/// assert_eq!(&anchor_wpm, anchor_bko);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r9 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.from).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r9;

/// Macro to traverse [`Anchor`][🦀] ➡ [`IsaUi`][🦞], via _R9(c)_
///
/// This macro expects a &[`Anchor`][🦀], and returns an Option<&[`IsaUi`][🦞]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [🦀]: crate::drawing::types::Anchor
/// [🦞]: crate::drawing::types::IsaUi
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing_maybe_get_one_iui_across_r9;
/// # let mut store = sarzak::drawing::ObjectStore::new();
/// # let mut sarzak_store = sarzak::sarzak::ObjectStore::new();
///
/// let isa_qbo = Isa::test_default(&mut sarzak_store);
///
/// let point_pvs = Point::new(&mut store, 42, 42);
/// let point_nnc = Point::new(&mut store, 42, 42);
/// let edge_kjj = Edge::test_default(&mut store);
/// let anchor_sgx = Anchor::new(&mut store, &point_pvs, &point_nnc, &edge_kjj);
///
/// let isa_ui = IsaUi::new(&mut store, &isa_qbo, &anchor_sgx);
/// let isa_ui_lvq = drawing_maybe_get_one_iui_across_r9!(anchor_sgx, store);
///
/// assert_eq!(Some(&isa_ui), isa_ui_lvq);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_iui_across_r9 {
    ($input:expr, $store:expr) => {{
        // {"magic":"","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_isa_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
// ⚡️         // {"magic":"","kind":"CriticalBlockEnd"}
            // {"magic":"","kind":"CriticalBlockEnd"}
    }};
}
pub use drawing_maybe_get_one_iui_across_r9;

/// Macro to traverse [`AssociativeUi`][🦀] ➡ [`Anchor`][🦞], via _R15_
///
/// This macro expects a &[`AssociativeUi`][🦀], and returns a &[`Anchor`][🦞].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [🦀]: crate::drawing::types::AssociativeUi
/// [🦞]: crate::drawing::types::Anchor
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_anch_across_r15;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_ohm = Associative::default();
///
/// let point_hci = Point::new(&mut store, 42, 42);
/// let point_uwz = Point::new(&mut store, 42, 42);
/// let edge_loa = Edge::test_default(&mut store);
/// let anchor_sln = Anchor::new(&mut store, &point_hci, &point_uwz, &edge_loa);
/// let point_jni = Point::new(&mut store, 42, 42);
/// let point_vip = Point::new(&mut store, 42, 42);
/// let edge_viu = Edge::test_default(&mut store);
/// let anchor_ufg = Anchor::new(&mut store, &point_jni, &point_vip, &edge_viu);
/// let point_yvl = Point::new(&mut store, 42, 42);
/// let point_bah = Point::new(&mut store, 42, 42);
/// let edge_ogo = Edge::test_default(&mut store);
/// let anchor_hwz = Anchor::new(&mut store, &point_yvl, &point_bah, &edge_ogo);
/// let point_meh = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_ohm, &anchor_sln, &anchor_ufg, &anchor_hwz, &point_meh);
///
/// let anchor_hxw = drawing_get_one_anch_across_r15!(associative_ui, store);
/// assert_eq!(&anchor_sln, anchor_hxw);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r15 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.other).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r15;

/// Macro to traverse [`Anchor`][🦀] ➡ [`AssociativeUi`][🦞], via _R15(c)_
///
/// This macro expects a &[`Anchor`][🦀], and returns an Option<&[`AssociativeUi`][🦞]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [🦀]: crate::drawing::types::Anchor
/// [🦞]: crate::drawing::types::AssociativeUi
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_maybe_get_one_aui_across_r15;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_oit = Associative::default();
///
/// let point_vdd = Point::new(&mut store, 42, 42);
/// let point_cla = Point::new(&mut store, 42, 42);
/// let edge_nor = Edge::test_default(&mut store);
/// let anchor_emv = Anchor::new(&mut store, &point_vdd, &point_cla, &edge_nor);
/// let point_vtz = Point::new(&mut store, 42, 42);
/// let point_cnp = Point::new(&mut store, 42, 42);
/// let edge_rmr = Edge::test_default(&mut store);
/// let anchor_nxw = Anchor::new(&mut store, &point_vtz, &point_cnp, &edge_rmr);
/// let point_xgu = Point::new(&mut store, 42, 42);
/// let point_otg = Point::new(&mut store, 42, 42);
/// let edge_pws = Edge::test_default(&mut store);
/// let anchor_flt = Anchor::new(&mut store, &point_xgu, &point_otg, &edge_pws);
/// let point_fkl = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_oit, &anchor_emv, &anchor_nxw, &anchor_flt, &point_fkl);
/// let associative_ui_pcu = drawing_maybe_get_one_aui_across_r15!(anchor_emv, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_pcu);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_aui_across_r15 {
    ($input:expr, $store:expr) => {{
        // {"magic":"","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.other == $input.id)
            .map(|(_, z)| z)
// ⚡️         // {"magic":"","kind":"CriticalBlockEnd"}
            // {"magic":"","kind":"CriticalBlockEnd"}
    }};
}
pub use drawing_maybe_get_one_aui_across_r15;

/// Macro to traverse [`Anchor`][🦀] ➡ [`Point`][🦞], via _R5_
///
/// This macro expects a &[`Anchor`][🦀], and returns a &[`Point`][🦞].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [🦀]: crate::drawing::types::Anchor
/// [🦞]: crate::drawing::types::Point
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_get_one_pnt_across_r5;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_plu = Point::new(&mut store, 42, 42);
/// let point_xvm = Point::new(&mut store, 42, 42);
/// let edge_fkk = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_plu, &point_xvm, &edge_fkk);
///
/// let point_prb = drawing_get_one_pnt_across_r5!(anchor, store);
/// assert_eq!(&point_plu, point_prb);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_pnt_across_r5 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.offset).unwrap()
    }};
}
pub use drawing_get_one_pnt_across_r5;

/// Macro to traverse [`Point`][🦀] ➡ [`Anchor`][🦞], via _R5(c)_
///
/// This macro expects a &[`Point`][🦀], and returns an Option<&[`Anchor`][🦞]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [🦀]: crate::drawing::types::Point
/// [🦞]: crate::drawing::types::Anchor
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_maybe_get_one_anch_across_r5;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_xsl = Point::new(&mut store, 42, 42);
/// let point_xzq = Point::new(&mut store, 42, 42);
/// let edge_ckc = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_xsl, &point_xzq, &edge_ckc);
/// let anchor_xgr = drawing_maybe_get_one_anch_across_r5!(point_xsl, store);
///
/// assert_eq!(Some(&anchor), anchor_xgr);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_anch_across_r5 {
    ($input:expr, $store:expr) => {{
        // {"magic":"","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.offset == $input.id)
            .map(|(_, z)| z)
// ⚡️         // {"magic":"","kind":"CriticalBlockEnd"}
            // {"magic":"","kind":"CriticalBlockEnd"}
    }};
}
pub use drawing_maybe_get_one_anch_across_r5;

/// Macro to traverse [`AssociativeUi`][🦀] ➡ [`Anchor`][🦞], via _R14_
///
/// This macro expects a &[`AssociativeUi`][🦀], and returns a &[`Anchor`][🦞].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [🦀]: crate::drawing::types::AssociativeUi
/// [🦞]: crate::drawing::types::Anchor
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_anch_across_r14;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_ugi = Associative::default();
///
/// let point_ecs = Point::new(&mut store, 42, 42);
/// let point_zhq = Point::new(&mut store, 42, 42);
/// let edge_ijr = Edge::test_default(&mut store);
/// let anchor_yfq = Anchor::new(&mut store, &point_ecs, &point_zhq, &edge_ijr);
/// let point_uaa = Point::new(&mut store, 42, 42);
/// let point_cgn = Point::new(&mut store, 42, 42);
/// let edge_tki = Edge::test_default(&mut store);
/// let anchor_tfg = Anchor::new(&mut store, &point_uaa, &point_cgn, &edge_tki);
/// let point_ohc = Point::new(&mut store, 42, 42);
/// let point_jhy = Point::new(&mut store, 42, 42);
/// let edge_dxi = Edge::test_default(&mut store);
/// let anchor_rnn = Anchor::new(&mut store, &point_ohc, &point_jhy, &edge_dxi);
/// let point_gmj = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_ugi, &anchor_yfq, &anchor_tfg, &anchor_rnn, &point_gmj);
///
/// let anchor_qza = drawing_get_one_anch_across_r14!(associative_ui, store);
/// assert_eq!(&anchor_yfq, anchor_qza);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r14 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.one).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r14;

/// Macro to traverse [`Anchor`][🦀] ➡ [`AssociativeUi`][🦞], via _R14(c)_
///
/// This macro expects a &[`Anchor`][🦀], and returns an Option<&[`AssociativeUi`][🦞]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [🦀]: crate::drawing::types::Anchor
/// [🦞]: crate::drawing::types::AssociativeUi
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing_maybe_get_one_aui_across_r14;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_pfu = Associative::default();
///
/// let point_hqt = Point::new(&mut store, 42, 42);
/// let point_btz = Point::new(&mut store, 42, 42);
/// let edge_dxv = Edge::test_default(&mut store);
/// let anchor_yoy = Anchor::new(&mut store, &point_hqt, &point_btz, &edge_dxv);
/// let point_nbd = Point::new(&mut store, 42, 42);
/// let point_rku = Point::new(&mut store, 42, 42);
/// let edge_ljm = Edge::test_default(&mut store);
/// let anchor_hku = Anchor::new(&mut store, &point_nbd, &point_rku, &edge_ljm);
/// let point_bmi = Point::new(&mut store, 42, 42);
/// let point_zgd = Point::new(&mut store, 42, 42);
/// let edge_yvu = Edge::test_default(&mut store);
/// let anchor_kwl = Anchor::new(&mut store, &point_bmi, &point_zgd, &edge_yvu);
/// let point_zud = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_pfu, &anchor_yoy, &anchor_hku, &anchor_kwl, &point_zud);
/// let associative_ui_bqy = drawing_maybe_get_one_aui_across_r14!(anchor_yoy, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_bqy);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_aui_across_r14 {
    ($input:expr, $store:expr) => {{
        // {"magic":"","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.one == $input.id)
            .map(|(_, z)| z)
// ⚡️         // {"magic":"","kind":"CriticalBlockEnd"}
            // {"magic":"","kind":"CriticalBlockEnd"}
    }};
}
pub use drawing_maybe_get_one_aui_across_r14;

/// Macro to traverse [`Anchor`][🦀] ➡ [`IsaUi`][🦞], across [`SubtypeAnchors`][🦑] via _R10_
///
/// This macro expects a &[`Anchor`][🦀], and returns a &[`IsaUi`][🦞].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [🦀]: crate::drawing::types::Anchor
/// [🦞]: crate::drawing::types::IsaUi
/// [🦑]: crate::drawing::types::SubtypeAnchors
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::SubtypeAnchors;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_iui_across_r10;
/// # let mut store = sarzak::drawing::ObjectStore::new();
/// # let mut sarzak_store = sarzak::sarzak::ObjectStore::new();
///
/// let point_ami = Point::new(&mut store, 42, 42);
/// let point_qpp = Point::new(&mut store, 42, 42);
/// let edge_mas = Edge::test_default(&mut store);
/// let anchor_qpk = Anchor::new(&mut store, &point_ami, &point_qpp, &edge_mas);
/// let isa_xge = Isa::test_default(&mut sarzak_store);
///
/// let point_ubj = Point::new(&mut store, 42, 42);
/// let point_aed = Point::new(&mut store, 42, 42);
/// let edge_mxf = Edge::test_default(&mut store);
/// let anchor_wam = Anchor::new(&mut store, &point_ubj, &point_aed, &edge_mxf);
/// let isa_ui_qzf = IsaUi::new(&mut store, &isa_xge, &anchor_wam);
/// let subtype_anchors = SubtypeAnchors::new(&mut store, &anchor_qpk, &isa_ui_qzf);
///
/// let isa_ui_mdu = drawing_maybe_get_one_iui_across_r10!(anchor_qpk, store);
/// assert_eq!(Some(&isa_ui_qzf), isa_ui_mdu);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_iui_across_r10 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_maybe_get_one
        $store
            .iter_subtype_anchors()
            .filter(|a| a.1.anchor_id == $input.id)
            .next()
            .and_then(|a| $store.exhume_isa_ui(&a.1.isaui_id))
    }};
}
pub use drawing_maybe_get_one_iui_across_r10;

/// Macro to traverse [`IsaUi`][🦀] ➡ [`Anchor`][🦞], across [`SubtypeAnchors`][🦑] via _R10_
///
/// This macro expects a &[`IsaUi`][🦀], and returns a &[`Anchor`][🦞].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [🦀]: crate::drawing::types::IsaUi
/// [🦞]: crate::drawing::types::Anchor
/// [🦑]: crate::drawing::types::SubtypeAnchors
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::drawing::SubtypeAnchors;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing_get_many_anch_across_r10;
/// # let mut store = sarzak::drawing::ObjectStore::new();
/// # let mut sarzak_store = sarzak::sarzak::ObjectStore::new();
///
/// let point_pzd = Point::new(&mut store, 42, 42);
/// let point_taa = Point::new(&mut store, 42, 42);
/// let edge_cet = Edge::test_default(&mut store);
/// let anchor_cpw = Anchor::new(&mut store, &point_pzd, &point_taa, &edge_cet);
/// let isa_cfy = Isa::test_default(&mut sarzak_store);
///
/// let point_icu = Point::new(&mut store, 42, 42);
/// let point_xnu = Point::new(&mut store, 42, 42);
/// let edge_szc = Edge::test_default(&mut store);
/// let anchor_azf = Anchor::new(&mut store, &point_icu, &point_xnu, &edge_szc);
/// let isa_ui_ipf = IsaUi::new(&mut store, &isa_cfy, &anchor_azf);
/// let subtype_anchors = SubtypeAnchors::new(&mut store, &anchor_cpw, &isa_ui_ipf);
///
/// let anchor_fji = drawing_get_many_anch_across_r10!(isa_ui_ipf, store);
/// assert!(anchor_fji.iter().find(|&x| **x == anchor_cpw).is_some());
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_many_anch_across_r10 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_many
        $store
            .iter_subtype_anchors()
            .filter(|a| a.1.isaui_id == $input.id)
            .map(|a| $store.exhume_anchor(&a.1.anchor_id).unwrap())
            .collect::<Vec<&Anchor>>()
    }};
}
pub use drawing_get_many_anch_across_r10;

/// Macro to traverse [`ObjectUi`][🦀] ➡ [`Point`][🦞], via _R13_
///
/// This macro expects a &[`ObjectUi`][🦀], and returns a &[`Point`][🦞].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [🦀]: crate::drawing::types::ObjectUi
/// [🦞]: crate::drawing::types::Point
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing_get_one_pnt_across_r13;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_jiu = Point::new(&mut store, 42, 42);
/// let innate_silk = "possessive_letters".to_owned();
/// let object_bgr = Object::default();
///
///
/// let object_ui = ObjectUi::new(&mut store, &point_jiu, &object_bgr, 42, 42);
///
/// let point_nwr = drawing_get_one_pnt_across_r13!(object_ui, store);
/// assert_eq!(&point_jiu, point_nwr);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_pnt_across_r13 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.origin).unwrap()
    }};
}
pub use drawing_get_one_pnt_across_r13;

/// Macro to traverse [`Point`][🦀] ➡ [`ObjectUi`][🦞], via _R13(c)_
///
/// This macro expects a &[`Point`][🦀], and returns an Option<&[`ObjectUi`][🦞]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [🦀]: crate::drawing::types::Point
/// [🦞]: crate::drawing::types::ObjectUi
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_oui_across_r13;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_fck = Point::new(&mut store, 42, 42);
/// let wealthy_apple = "colossal_low".to_owned();
/// let object_qdx = Object::default();
///
///
/// let object_ui = ObjectUi::new(&mut store, &point_fck, &object_qdx, 42, 42);
/// let object_ui_fef = drawing_maybe_get_one_oui_across_r13!(point_fck, store);
///
/// assert_eq!(Some(&object_ui), object_ui_fef);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_oui_across_r13 {
    ($input:expr, $store:expr) => {{
        // {"magic":"","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_object_ui()
            .find(|z| z.1.origin == $input.id)
            .map(|(_, z)| z)
// ⚡️         // {"magic":"","kind":"CriticalBlockEnd"}
            // {"magic":"","kind":"CriticalBlockEnd"}
    }};
}
pub use drawing_maybe_get_one_oui_across_r13;

/// Macro to traverse [`AssociativeUi`][🦀] ➡ [`Point`][🦞], via _R17_
///
/// This macro expects a &[`AssociativeUi`][🦀], and returns a &[`Point`][🦞].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [🦀]: crate::drawing::types::AssociativeUi
/// [🦞]: crate::drawing::types::Point
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_get_one_pnt_across_r17;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_kci = Associative::default();
///
/// let point_itm = Point::new(&mut store, 42, 42);
/// let point_zfg = Point::new(&mut store, 42, 42);
/// let edge_wug = Edge::test_default(&mut store);
/// let anchor_yhl = Anchor::new(&mut store, &point_itm, &point_zfg, &edge_wug);
/// let point_fzc = Point::new(&mut store, 42, 42);
/// let point_zyv = Point::new(&mut store, 42, 42);
/// let edge_svg = Edge::test_default(&mut store);
/// let anchor_kae = Anchor::new(&mut store, &point_fzc, &point_zyv, &edge_svg);
/// let point_for = Point::new(&mut store, 42, 42);
/// let point_puo = Point::new(&mut store, 42, 42);
/// let edge_oor = Edge::test_default(&mut store);
/// let anchor_gct = Anchor::new(&mut store, &point_for, &point_puo, &edge_oor);
/// let point_xxy = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_kci, &anchor_yhl, &anchor_kae, &anchor_gct, &point_xxy);
///
/// let point_pgz = drawing_get_one_pnt_across_r17!(associative_ui, store);
/// assert_eq!(&point_xxy, point_pgz);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_pnt_across_r17 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.middle).unwrap()
    }};
}
pub use drawing_get_one_pnt_across_r17;

/// Macro to traverse [`Point`][🦀] ➡ [`AssociativeUi`][🦞], via _R17(c)_
///
/// This macro expects a &[`Point`][🦀], and returns an Option<&[`AssociativeUi`][🦞]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [🦀]: crate::drawing::types::Point
/// [🦞]: crate::drawing::types::AssociativeUi
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_maybe_get_one_aui_across_r17;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_pjg = Associative::default();
///
/// let point_rxf = Point::new(&mut store, 42, 42);
/// let point_rxn = Point::new(&mut store, 42, 42);
/// let edge_nbd = Edge::test_default(&mut store);
/// let anchor_rlx = Anchor::new(&mut store, &point_rxf, &point_rxn, &edge_nbd);
/// let point_ieo = Point::new(&mut store, 42, 42);
/// let point_tfk = Point::new(&mut store, 42, 42);
/// let edge_ccu = Edge::test_default(&mut store);
/// let anchor_has = Anchor::new(&mut store, &point_ieo, &point_tfk, &edge_ccu);
/// let point_mbk = Point::new(&mut store, 42, 42);
/// let point_jcx = Point::new(&mut store, 42, 42);
/// let edge_jer = Edge::test_default(&mut store);
/// let anchor_hde = Anchor::new(&mut store, &point_mbk, &point_jcx, &edge_jer);
/// let point_ehf = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_pjg, &anchor_rlx, &anchor_has, &anchor_hde, &point_ehf);
/// let associative_ui_nlc = drawing_maybe_get_one_aui_across_r17!(point_ehf, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_nlc);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_aui_across_r17 {
    ($input:expr, $store:expr) => {{
        // {"magic":"","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.middle == $input.id)
            .map(|(_, z)| z)
// ⚡️         // {"magic":"","kind":"CriticalBlockEnd"}
            // {"magic":"","kind":"CriticalBlockEnd"}
    }};
}
pub use drawing_maybe_get_one_aui_across_r17;

/// Macro to traverse [`ObjectEdge`][🦀] ➡ [`ObjectUi`][🦞], via _R18_
///
/// This macro expects a &[`ObjectEdge`][🦀], and returns a &[`ObjectUi`][🦞].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [🦀]: crate::drawing::types::ObjectEdge
/// [🦞]: crate::drawing::types::ObjectUi
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing_get_one_oui_across_r18;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_gfr = Edge::test_default(&mut store);
/// let point_wtw = Point::new(&mut store, 42, 42);
/// let holistic_support = "ordinary_brain".to_owned();
/// let object_dxf = Object::default();
///
/// let object_ui_nlz = ObjectUi::new(&mut store, &point_wtw, &object_dxf, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_gfr, &object_ui_nlz);
///
/// let object_ui_kfs = drawing_get_one_oui_across_r18!(object_edge, store);
/// assert_eq!(&object_ui_nlz, object_ui_kfs);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_oui_across_r18 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object_ui(&$input.oui_id).unwrap()
    }};
}
pub use drawing_get_one_oui_across_r18;

/// Macro to traverse [`ObjectUi`][🦀] ➡ [`ObjectEdge`][🦞], via _R18_
///
/// This macro expects a &[`ObjectUi`][🦀], and returns a &[`ObjectEdge`][🦞].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [🦀]: crate::drawing::types::ObjectUi
/// [🦞]: crate::drawing::types::ObjectEdge
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing_get_many_oui_es_across_r18;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_nhf = Edge::test_default(&mut store);
/// let point_fux = Point::new(&mut store, 42, 42);
/// let bad_reason = "overjoyed_use".to_owned();
/// let object_sgc = Object::default();
///
/// let object_ui_uhc = ObjectUi::new(&mut store, &point_fux, &object_sgc, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_nhf, &object_ui_uhc);
/// let object_edge_okz = drawing_get_many_oui_es_across_r18!(object_ui_uhc, store);
///
/// assert!(object_edge_okz.iter().find(|&x| **x == object_edge).is_some());
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_many_oui_es_across_r18 {
    ($input:expr, $store:expr) => {{
        // {"magic":"","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_object_edge()
// ⚡️             .filter_map(|z| {
// ⚡️                 if z.1.oui_id == $input.id {
// ⚡️                     Some(z.1)
// ⚡️                 } else {
// ⚡️                     None
// ⚡️                 }
// ⚡️             })
            .filter_map(|z| if z.1.oui_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&ObjectEdge>>()
// ⚡️         // {"magic":"","kind":"CriticalBlockEnd"}
            // {"magic":"","kind":"CriticalBlockEnd"}
    }};
}
pub use drawing_get_many_oui_es_across_r18;

/// Macro to traverse [`BinaryUi`][🦀] ➡ [`Anchor`][🦞], via _R8_
///
/// This macro expects a &[`BinaryUi`][🦀], and returns a &[`Anchor`][🦞].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [🦀]: crate::drawing::types::BinaryUi
/// [🦞]: crate::drawing::types::Anchor
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing_get_one_anch_across_r8;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_odv = Point::new(&mut store, 42, 42);
/// let point_pjw = Point::new(&mut store, 42, 42);
/// let edge_zzl = Edge::test_default(&mut store);
/// let anchor_ltq = Anchor::new(&mut store, &point_odv, &point_pjw, &edge_zzl);
/// let point_htq = Point::new(&mut store, 42, 42);
/// let point_aed = Point::new(&mut store, 42, 42);
/// let edge_rwe = Edge::test_default(&mut store);
/// let anchor_awe = Anchor::new(&mut store, &point_htq, &point_aed, &edge_rwe);
/// let binary_fcn = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_ltq, &anchor_awe, &binary_fcn);
///
/// let anchor_zgs = drawing_get_one_anch_across_r8!(binary_ui, store);
/// assert_eq!(&anchor_ltq, anchor_zgs);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r8 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.to).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r8;

/// Macro to traverse [`Anchor`][🦀] ➡ [`BinaryUi`][🦞], via _R8(c)_
///
/// This macro expects a &[`Anchor`][🦀], and returns an Option<&[`BinaryUi`][🦞]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [🦀]: crate::drawing::types::Anchor
/// [🦞]: crate::drawing::types::BinaryUi
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_bui_across_r8;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_buf = Point::new(&mut store, 42, 42);
/// let point_nus = Point::new(&mut store, 42, 42);
/// let edge_tfe = Edge::test_default(&mut store);
/// let anchor_lrg = Anchor::new(&mut store, &point_buf, &point_nus, &edge_tfe);
/// let point_ncm = Point::new(&mut store, 42, 42);
/// let point_bce = Point::new(&mut store, 42, 42);
/// let edge_vex = Edge::test_default(&mut store);
/// let anchor_xro = Anchor::new(&mut store, &point_ncm, &point_bce, &edge_vex);
/// let binary_wlm = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_lrg, &anchor_xro, &binary_wlm);
/// let binary_ui_ioy = drawing_maybe_get_one_bui_across_r8!(anchor_lrg, store);
///
/// assert_eq!(Some(&binary_ui), binary_ui_ioy);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_bui_across_r8 {
    ($input:expr, $store:expr) => {{
        // {"magic":"","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_binary_ui()
            .find(|z| z.1.to == $input.id)
            .map(|(_, z)| z)
// ⚡️         // {"magic":"","kind":"CriticalBlockEnd"}
            // {"magic":"","kind":"CriticalBlockEnd"}
    }};
}
pub use drawing_maybe_get_one_bui_across_r8;

/// Macro to traverse [`AssociativeUi`][🦀] ➡ [`Anchor`][🦞], via _R16_
///
/// This macro expects a &[`AssociativeUi`][🦀], and returns a &[`Anchor`][🦞].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [🦀]: crate::drawing::types::AssociativeUi
/// [🦞]: crate::drawing::types::Anchor
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_anch_across_r16;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_bcf = Associative::default();
///
/// let point_awl = Point::new(&mut store, 42, 42);
/// let point_aom = Point::new(&mut store, 42, 42);
/// let edge_zpq = Edge::test_default(&mut store);
/// let anchor_upz = Anchor::new(&mut store, &point_awl, &point_aom, &edge_zpq);
/// let point_flu = Point::new(&mut store, 42, 42);
/// let point_wcy = Point::new(&mut store, 42, 42);
/// let edge_zcn = Edge::test_default(&mut store);
/// let anchor_skm = Anchor::new(&mut store, &point_flu, &point_wcy, &edge_zcn);
/// let point_gjm = Point::new(&mut store, 42, 42);
/// let point_hnp = Point::new(&mut store, 42, 42);
/// let edge_ctt = Edge::test_default(&mut store);
/// let anchor_rrl = Anchor::new(&mut store, &point_gjm, &point_hnp, &edge_ctt);
/// let point_wey = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_bcf, &anchor_upz, &anchor_skm, &anchor_rrl, &point_wey);
///
/// let anchor_rww = drawing_get_one_anch_across_r16!(associative_ui, store);
/// assert_eq!(&anchor_upz, anchor_rww);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r16 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.from).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r16;

/// Macro to traverse [`Anchor`][🦀] ➡ [`AssociativeUi`][🦞], via _R16(c)_
///
/// This macro expects a &[`Anchor`][🦀], and returns an Option<&[`AssociativeUi`][🦞]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [🦀]: crate::drawing::types::Anchor
/// [🦞]: crate::drawing::types::AssociativeUi
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_maybe_get_one_aui_across_r16;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_til = Associative::default();
///
/// let point_jto = Point::new(&mut store, 42, 42);
/// let point_pli = Point::new(&mut store, 42, 42);
/// let edge_kgf = Edge::test_default(&mut store);
/// let anchor_xmj = Anchor::new(&mut store, &point_jto, &point_pli, &edge_kgf);
/// let point_hda = Point::new(&mut store, 42, 42);
/// let point_qny = Point::new(&mut store, 42, 42);
/// let edge_joe = Edge::test_default(&mut store);
/// let anchor_jzt = Anchor::new(&mut store, &point_hda, &point_qny, &edge_joe);
/// let point_btr = Point::new(&mut store, 42, 42);
/// let point_abu = Point::new(&mut store, 42, 42);
/// let edge_xto = Edge::test_default(&mut store);
/// let anchor_rnb = Anchor::new(&mut store, &point_btr, &point_abu, &edge_xto);
/// let point_nlw = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_til, &anchor_xmj, &anchor_jzt, &anchor_rnb, &point_nlw);
/// let associative_ui_vuv = drawing_maybe_get_one_aui_across_r16!(anchor_xmj, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_vuv);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_aui_across_r16 {
    ($input:expr, $store:expr) => {{
        // {"magic":"","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
// ⚡️         // {"magic":"","kind":"CriticalBlockEnd"}
            // {"magic":"","kind":"CriticalBlockEnd"}
    }};
}
pub use drawing_maybe_get_one_aui_across_r16;

/// Macro to traverse [`Anchor`][🦀] ➡ [`Edge`][🦞], via _R3_
///
/// This macro expects a &[`Anchor`][🦀], and returns a &[`Edge`][🦞].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [🦀]: crate::drawing::types::Anchor
/// [🦞]: crate::drawing::types::Edge
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_edg_across_r3;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_agh = Point::new(&mut store, 42, 42);
/// let point_vmy = Point::new(&mut store, 42, 42);
/// let edge_ckq = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_agh, &point_vmy, &edge_ckq);
///
/// let edge_yqs = drawing_get_one_edg_across_r3!(anchor, store);
/// assert_eq!(&edge_ckq, edge_yqs);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_edg_across_r3 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_edge(&$input.edge).unwrap()
    }};
}
pub use drawing_get_one_edg_across_r3;

/// Macro to traverse [`Edge`][🦀] ➡ [`Anchor`][🦞], via _R3(c)_
///
/// This macro expects a &[`Edge`][🦀], and returns an Option<&[`Anchor`][🦞]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [🦀]: crate::drawing::types::Edge
/// [🦞]: crate::drawing::types::Anchor
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_maybe_get_one_anch_across_r3;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_tks = Point::new(&mut store, 42, 42);
/// let point_yug = Point::new(&mut store, 42, 42);
/// let edge_ovv = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_tks, &point_yug, &edge_ovv);
/// let anchor_fyp = drawing_maybe_get_one_anch_across_r3!(edge_ovv, store);
///
/// assert_eq!(Some(&anchor), anchor_fyp);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_anch_across_r3 {
    ($input:expr, $store:expr) => {{
        // {"magic":"","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.edge == $input.get_id())
            .map(|(_, z)| z)
// ⚡️         // {"magic":"","kind":"CriticalBlockEnd"}
            // {"magic":"","kind":"CriticalBlockEnd"}
    }};
}
pub use drawing_maybe_get_one_anch_across_r3;

/// Macro to traverse [`ObjectEdge`][🦀] ➡ [`Edge`][🦞], via _R19_
///
/// This macro expects a &[`ObjectEdge`][🦀], and returns a &[`Edge`][🦞].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [🦀]: crate::drawing::types::ObjectEdge
/// [🦞]: crate::drawing::types::Edge
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_edg_across_r19;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_rtt = Edge::test_default(&mut store);
/// let point_icy = Point::new(&mut store, 42, 42);
/// let fat_shape = "false_stick".to_owned();
/// let object_cbw = Object::default();
///
/// let object_ui_rxq = ObjectUi::new(&mut store, &point_icy, &object_cbw, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_rtt, &object_ui_rxq);
///
/// let edge_vix = drawing_get_one_edg_across_r19!(object_edge, store);
/// assert_eq!(&edge_rtt, edge_vix);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_edg_across_r19 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_edge(&$input.edge).unwrap()
    }};
}
pub use drawing_get_one_edg_across_r19;

/// Macro to traverse [`Edge`][🦀] ➡ [`ObjectEdge`][🦞], via _R19(c)_
///
/// This macro expects a &[`Edge`][🦀], and returns an Option<&[`ObjectEdge`][🦞]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [🦀]: crate::drawing::types::Edge
/// [🦞]: crate::drawing::types::ObjectEdge
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing_maybe_get_one_oui_e_across_r19;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_dcg = Edge::test_default(&mut store);
/// let point_rox = Point::new(&mut store, 42, 42);
/// let two_daughter = "well_to_do_gun".to_owned();
/// let object_jmi = Object::default();
///
/// let object_ui_kxt = ObjectUi::new(&mut store, &point_rox, &object_jmi, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_dcg, &object_ui_kxt);
/// let object_edge_okf = drawing_maybe_get_one_oui_e_across_r19!(edge_dcg, store);
///
/// assert_eq!(Some(&object_edge), object_edge_okf);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_oui_e_across_r19 {
    ($input:expr, $store:expr) => {{
        // {"magic":"","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_object_edge()
            .find(|z| z.1.edge == $input.get_id())
            .map(|(_, z)| z)
// ⚡️         // {"magic":"","kind":"CriticalBlockEnd"}
            // {"magic":"","kind":"CriticalBlockEnd"}
    }};
}
pub use drawing_maybe_get_one_oui_e_across_r19;

/// Macro to traverse [`BinaryUi`][🦀] ➡ [`Anchor`][🦞], via _R7_
///
/// This macro expects a &[`BinaryUi`][🦀], and returns a &[`Anchor`][🦞].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [🦀]: crate::drawing::types::BinaryUi
/// [🦞]: crate::drawing::types::Anchor
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_anch_across_r7;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_yqp = Point::new(&mut store, 42, 42);
/// let point_cqy = Point::new(&mut store, 42, 42);
/// let edge_sxb = Edge::test_default(&mut store);
/// let anchor_thr = Anchor::new(&mut store, &point_yqp, &point_cqy, &edge_sxb);
/// let point_oxf = Point::new(&mut store, 42, 42);
/// let point_asp = Point::new(&mut store, 42, 42);
/// let edge_pqp = Edge::test_default(&mut store);
/// let anchor_acr = Anchor::new(&mut store, &point_oxf, &point_asp, &edge_pqp);
/// let binary_pnk = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_thr, &anchor_acr, &binary_pnk);
///
/// let anchor_ggw = drawing_get_one_anch_across_r7!(binary_ui, store);
/// assert_eq!(&anchor_thr, anchor_ggw);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r7 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.from).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r7;

/// Macro to traverse [`Anchor`][🦀] ➡ [`BinaryUi`][🦞], via _R7(c)_
///
/// This macro expects a &[`Anchor`][🦀], and returns an Option<&[`BinaryUi`][🦞]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [🦀]: crate::drawing::types::Anchor
/// [🦞]: crate::drawing::types::BinaryUi
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_maybe_get_one_bui_across_r7;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_qyb = Point::new(&mut store, 42, 42);
/// let point_lnz = Point::new(&mut store, 42, 42);
/// let edge_wam = Edge::test_default(&mut store);
/// let anchor_afv = Anchor::new(&mut store, &point_qyb, &point_lnz, &edge_wam);
/// let point_kci = Point::new(&mut store, 42, 42);
/// let point_drr = Point::new(&mut store, 42, 42);
/// let edge_lsz = Edge::test_default(&mut store);
/// let anchor_tbs = Anchor::new(&mut store, &point_kci, &point_drr, &edge_lsz);
/// let binary_xty = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_afv, &anchor_tbs, &binary_xty);
/// let binary_ui_xpm = drawing_maybe_get_one_bui_across_r7!(anchor_afv, store);
///
/// assert_eq!(Some(&binary_ui), binary_ui_xpm);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_bui_across_r7 {
    ($input:expr, $store:expr) => {{
        // {"magic":"","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_binary_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
// ⚡️         // {"magic":"","kind":"CriticalBlockEnd"}
            // {"magic":"","kind":"CriticalBlockEnd"}
    }};
}
pub use drawing_maybe_get_one_bui_across_r7;

/// Macro to traverse [`Anchor`][🦀] ➡ [`Point`][🦞], via _R4_
///
/// This macro expects a &[`Anchor`][🦀], and returns a &[`Point`][🦞].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [🦀]: crate::drawing::types::Anchor
/// [🦞]: crate::drawing::types::Point
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_pnt_across_r4;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_ccn = Point::new(&mut store, 42, 42);
/// let point_cyk = Point::new(&mut store, 42, 42);
/// let edge_yyu = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_ccn, &point_cyk, &edge_yyu);
///
/// let point_trj = drawing_get_one_pnt_across_r4!(anchor, store);
/// assert_eq!(&point_ccn, point_trj);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_pnt_across_r4 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.location).unwrap()
    }};
}
pub use drawing_get_one_pnt_across_r4;

/// Macro to traverse [`Point`][🦀] ➡ [`Anchor`][🦞], via _R4(c)_
///
/// This macro expects a &[`Point`][🦀], and returns an Option<&[`Anchor`][🦞]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [🦀]: crate::drawing::types::Point
/// [🦞]: crate::drawing::types::Anchor
// {"magic":"","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_maybe_get_one_anch_across_r4;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_qsa = Point::new(&mut store, 42, 42);
/// let point_tst = Point::new(&mut store, 42, 42);
/// let edge_bwt = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_qsa, &point_tst, &edge_bwt);
/// let anchor_xse = drawing_maybe_get_one_anch_across_r4!(point_qsa, store);
///
/// assert_eq!(Some(&anchor), anchor_xse);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_anch_across_r4 {
    ($input:expr, $store:expr) => {{
        // {"magic":"","kind":"CriticalBlockBegin"}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.location == $input.id)
            .map(|(_, z)| z)
// ⚡️         // {"magic":"","kind":"CriticalBlockEnd"}
            // {"magic":"","kind":"CriticalBlockEnd"}
    }};
}
pub use drawing_maybe_get_one_anch_across_r4;
