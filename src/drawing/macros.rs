//! Macros for navigating the "Drawing" domain
//!
//! # Generated Code -- edit _with care_.
//!
//! Don't mess with anything between `{"magic":"îž¨","kind":"CriticalBlockBegin"}`
//! and `{"magic":"îž¨","kind":"CriticalBlockEnd"}`. Otherwise, you should be free
//! to go wild. Happy hacking!
//!
//! Use the following invocation to reproduce:
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
//! ```shell
//!  sarzak gen
//! ```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
// {"magic":"îž¨","version":"0.5.0"}

/// Macro to traverse [`IsaUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R9_
///
/// This macro expects a &[`IsaUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::IsaUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::drawing_get_one_anch_across_r9;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let isa_fiu = Isa::default();
///
/// let point_pxe = Point::new(&mut store, 42, 42);
/// let point_kns = Point::new(&mut store, 42, 42);
/// let edge_kks = Edge::test_default(&mut store);
/// let anchor_bnb = Anchor::new(&mut store, &point_pxe, &point_kns, &edge_kks);
///
/// let isa_ui = IsaUi::new(&mut store, &isa_fiu, &anchor_bnb);
///
/// let anchor_whh = drawing_get_one_anch_across_r9!(isa_ui, store);
/// assert_eq!(&anchor_bnb, anchor_whh);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r9 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.from).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_anch_across_r9;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`IsaUi`][ðŸ¦ž], via _R9(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`IsaUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::IsaUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_maybe_get_one_iui_across_r9;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let isa_juv = Isa::default();
///
/// let point_ree = Point::new(&mut store, 42, 42);
/// let point_zsc = Point::new(&mut store, 42, 42);
/// let edge_vhp = Edge::test_default(&mut store);
/// let anchor_hqk = Anchor::new(&mut store, &point_ree, &point_zsc, &edge_vhp);
///
/// let isa_ui = IsaUi::new(&mut store, &isa_juv, &anchor_hqk);
/// let isa_ui_wnp = drawing_maybe_get_one_iui_across_r9!(anchor_hqk, store);
///
/// assert_eq!(Some(&isa_ui), isa_ui_wnp);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_iui_across_r9 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-isa_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_isa_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-isa_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_iui_across_r9;

/// Macro to traverse [`AssociativeUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R15_
///
/// This macro expects a &[`AssociativeUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::AssociativeUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_anch_across_r15;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_eqg = Associative::default();
///
/// let point_yyv = Point::new(&mut store, 42, 42);
/// let point_pit = Point::new(&mut store, 42, 42);
/// let edge_huo = Edge::test_default(&mut store);
/// let anchor_yhb = Anchor::new(&mut store, &point_yyv, &point_pit, &edge_huo);
/// let point_ivt = Point::new(&mut store, 42, 42);
/// let point_the = Point::new(&mut store, 42, 42);
/// let edge_tvy = Edge::test_default(&mut store);
/// let anchor_ltn = Anchor::new(&mut store, &point_ivt, &point_the, &edge_tvy);
/// let point_kns = Point::new(&mut store, 42, 42);
/// let point_fbl = Point::new(&mut store, 42, 42);
/// let edge_wlo = Edge::test_default(&mut store);
/// let anchor_ecl = Anchor::new(&mut store, &point_kns, &point_fbl, &edge_wlo);
/// let point_lrj = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_eqg, &anchor_yhb, &anchor_ltn, &anchor_ecl, &point_lrj);
///
/// let anchor_nfl = drawing_get_one_anch_across_r15!(associative_ui, store);
/// assert_eq!(&anchor_yhb, anchor_nfl);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r15 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.other).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_anch_across_r15;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`AssociativeUi`][ðŸ¦ž], via _R15(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`AssociativeUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::AssociativeUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_aui_across_r15;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_juv = Associative::default();
///
/// let point_upf = Point::new(&mut store, 42, 42);
/// let point_wzd = Point::new(&mut store, 42, 42);
/// let edge_ojg = Edge::test_default(&mut store);
/// let anchor_ihf = Anchor::new(&mut store, &point_upf, &point_wzd, &edge_ojg);
/// let point_dny = Point::new(&mut store, 42, 42);
/// let point_xeh = Point::new(&mut store, 42, 42);
/// let edge_uct = Edge::test_default(&mut store);
/// let anchor_ijp = Anchor::new(&mut store, &point_dny, &point_xeh, &edge_uct);
/// let point_svp = Point::new(&mut store, 42, 42);
/// let point_uok = Point::new(&mut store, 42, 42);
/// let edge_stf = Edge::test_default(&mut store);
/// let anchor_teh = Anchor::new(&mut store, &point_svp, &point_uok, &edge_stf);
/// let point_rwv = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_juv, &anchor_ihf, &anchor_ijp, &anchor_teh, &point_rwv);
/// let associative_ui_snr = drawing_maybe_get_one_aui_across_r15!(anchor_ihf, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_snr);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_aui_across_r15 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.other == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r15;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`Point`][ðŸ¦ž], via _R5_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns a &[`Point`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::Point
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_pnt_across_r5;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_bko = Point::new(&mut store, 42, 42);
/// let point_ycj = Point::new(&mut store, 42, 42);
/// let edge_nsn = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_bko, &point_ycj, &edge_nsn);
///
/// let point_cut = drawing_get_one_pnt_across_r5!(anchor, store);
/// assert_eq!(&point_bko, point_cut);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_pnt_across_r5 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.offset).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_pnt_across_r5;

/// Macro to traverse [`Point`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R5(c)_
///
/// This macro expects a &[`Point`][ðŸ¦€], and returns an Option<&[`Anchor`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Point
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_maybe_get_one_anch_across_r5;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_fqq = Point::new(&mut store, 42, 42);
/// let point_tyz = Point::new(&mut store, 42, 42);
/// let edge_svm = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_fqq, &point_tyz, &edge_svm);
/// let anchor_xgj = drawing_maybe_get_one_anch_across_r5!(point_fqq, store);
///
/// assert_eq!(Some(&anchor), anchor_xgj);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_anch_across_r5 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.offset == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_anch_across_r5;

/// Macro to traverse [`AssociativeUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R14_
///
/// This macro expects a &[`AssociativeUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::AssociativeUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_anch_across_r14;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_kdj = Associative::default();
///
/// let point_pcd = Point::new(&mut store, 42, 42);
/// let point_aca = Point::new(&mut store, 42, 42);
/// let edge_des = Edge::test_default(&mut store);
/// let anchor_xzl = Anchor::new(&mut store, &point_pcd, &point_aca, &edge_des);
/// let point_zsq = Point::new(&mut store, 42, 42);
/// let point_mhe = Point::new(&mut store, 42, 42);
/// let edge_rru = Edge::test_default(&mut store);
/// let anchor_khn = Anchor::new(&mut store, &point_zsq, &point_mhe, &edge_rru);
/// let point_hja = Point::new(&mut store, 42, 42);
/// let point_biw = Point::new(&mut store, 42, 42);
/// let edge_jfn = Edge::test_default(&mut store);
/// let anchor_lip = Anchor::new(&mut store, &point_hja, &point_biw, &edge_jfn);
/// let point_gwn = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_kdj, &anchor_xzl, &anchor_khn, &anchor_lip, &point_gwn);
///
/// let anchor_ogd = drawing_get_one_anch_across_r14!(associative_ui, store);
/// assert_eq!(&anchor_xzl, anchor_ogd);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r14 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.one).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_anch_across_r14;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`AssociativeUi`][ðŸ¦ž], via _R14(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`AssociativeUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::AssociativeUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_aui_across_r14;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_yfg = Associative::default();
///
/// let point_dvb = Point::new(&mut store, 42, 42);
/// let point_wei = Point::new(&mut store, 42, 42);
/// let edge_qey = Edge::test_default(&mut store);
/// let anchor_amc = Anchor::new(&mut store, &point_dvb, &point_wei, &edge_qey);
/// let point_zlg = Point::new(&mut store, 42, 42);
/// let point_bjk = Point::new(&mut store, 42, 42);
/// let edge_lxi = Edge::test_default(&mut store);
/// let anchor_kwt = Anchor::new(&mut store, &point_zlg, &point_bjk, &edge_lxi);
/// let point_env = Point::new(&mut store, 42, 42);
/// let point_qpc = Point::new(&mut store, 42, 42);
/// let edge_poh = Edge::test_default(&mut store);
/// let anchor_dwm = Anchor::new(&mut store, &point_env, &point_qpc, &edge_poh);
/// let point_qvb = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_yfg, &anchor_amc, &anchor_kwt, &anchor_dwm, &point_qvb);
/// let associative_ui_lcz = drawing_maybe_get_one_aui_across_r14!(anchor_amc, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_lcz);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_aui_across_r14 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.one == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r14;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`IsaUi`][ðŸ¦ž], across [`SubtypeAnchors`][ðŸ¦‘] via _R10_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns a &[`IsaUi`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::IsaUi
/// [ðŸ¦‘]: crate::drawing::types::SubtypeAnchors
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::SubtypeAnchors;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_iui_across_r10;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_cmg = Point::new(&mut store, 42, 42);
/// let point_gzw = Point::new(&mut store, 42, 42);
/// let edge_kpb = Edge::test_default(&mut store);
/// let anchor_gzt = Anchor::new(&mut store, &point_cmg, &point_gzw, &edge_kpb);
/// let isa_gnq = Isa::default();
///
/// let point_klh = Point::new(&mut store, 42, 42);
/// let point_itj = Point::new(&mut store, 42, 42);
/// let edge_bnc = Edge::test_default(&mut store);
/// let anchor_vsx = Anchor::new(&mut store, &point_klh, &point_itj, &edge_bnc);
/// let isa_ui_zfi = IsaUi::new(&mut store, &isa_gnq, &anchor_vsx);
/// let subtype_anchors = SubtypeAnchors::new(&mut store, &anchor_gzt, &isa_ui_zfi);
///
/// let isa_ui_hmr = drawing_maybe_get_one_iui_across_r10!(anchor_gzt, store);
/// assert_eq!(Some(&isa_ui_zfi), isa_ui_hmr);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_iui_across_r10 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_maybe_get_one
        $store
            .iter_subtype_anchors()
            .filter(|a| a.1.anchor_id == $input.id)
            .next()
            .and_then(|a| $store.exhume_isa_ui(&a.1.isaui_id))
    }};
}
pub use drawing_maybe_get_one_iui_across_r10;

/// Macro to traverse [`IsaUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], across [`SubtypeAnchors`][ðŸ¦‘] via _R10_
///
/// This macro expects a &[`IsaUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ðŸ¦€]: crate::drawing::types::IsaUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
/// [ðŸ¦‘]: crate::drawing::types::SubtypeAnchors
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::SubtypeAnchors;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_get_many_anch_across_r10;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_vzs = Point::new(&mut store, 42, 42);
/// let point_yjf = Point::new(&mut store, 42, 42);
/// let edge_hkv = Edge::test_default(&mut store);
/// let anchor_bup = Anchor::new(&mut store, &point_vzs, &point_yjf, &edge_hkv);
/// let isa_acf = Isa::default();
///
/// let point_puc = Point::new(&mut store, 42, 42);
/// let point_hbv = Point::new(&mut store, 42, 42);
/// let edge_pud = Edge::test_default(&mut store);
/// let anchor_zhe = Anchor::new(&mut store, &point_puc, &point_hbv, &edge_pud);
/// let isa_ui_fep = IsaUi::new(&mut store, &isa_acf, &anchor_zhe);
/// let subtype_anchors = SubtypeAnchors::new(&mut store, &anchor_bup, &isa_ui_fep);
///
/// let anchor_ott = drawing_get_many_anch_across_r10!(isa_ui_fep, store);
/// assert!(anchor_ott.iter().find(|&x| **x == anchor_bup).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_many_anch_across_r10 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_many
        $store
            .iter_subtype_anchors()
            .filter(|a| a.1.isaui_id == $input.id)
            .map(|a| $store.exhume_anchor(&a.1.anchor_id).unwrap())
            .collect::<Vec<&Anchor>>()
    }};
}
pub use drawing_get_many_anch_across_r10;

/// Macro to traverse [`ObjectUi`][ðŸ¦€] âž¡ [`Point`][ðŸ¦ž], via _R13_
///
/// This macro expects a &[`ObjectUi`][ðŸ¦€], and returns a &[`Point`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::ObjectUi
/// [ðŸ¦ž]: crate::drawing::types::Point
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_pnt_across_r13;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_frl = Point::new(&mut store, 42, 42);
/// let understood_can = "heartbreaking_pleasure".to_owned();
/// let object_lyp = Object::default();
///
///
/// let object_ui = ObjectUi::new(&mut store, &point_frl, &object_lyp, 42, 42);
///
/// let point_tiw = drawing_get_one_pnt_across_r13!(object_ui, store);
/// assert_eq!(&point_frl, point_tiw);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_pnt_across_r13 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.origin).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_pnt_across_r13;

/// Macro to traverse [`Point`][ðŸ¦€] âž¡ [`ObjectUi`][ðŸ¦ž], via _R13(c)_
///
/// This macro expects a &[`Point`][ðŸ¦€], and returns an Option<&[`ObjectUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Point
/// [ðŸ¦ž]: crate::drawing::types::ObjectUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_oui_across_r13;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_yxq = Point::new(&mut store, 42, 42);
/// let draconian_uncle = "outstanding_carpenter".to_owned();
/// let object_zkp = Object::default();
///
///
/// let object_ui = ObjectUi::new(&mut store, &point_yxq, &object_zkp, 42, 42);
/// let object_ui_gjx = drawing_maybe_get_one_oui_across_r13!(point_yxq, store);
///
/// assert_eq!(Some(&object_ui), object_ui_gjx);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_oui_across_r13 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-object_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_object_ui()
            .find(|z| z.1.origin == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-object_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_oui_across_r13;

/// Macro to traverse [`AssociativeUi`][ðŸ¦€] âž¡ [`Point`][ðŸ¦ž], via _R17_
///
/// This macro expects a &[`AssociativeUi`][ðŸ¦€], and returns a &[`Point`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::AssociativeUi
/// [ðŸ¦ž]: crate::drawing::types::Point
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_pnt_across_r17;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_oxy = Associative::default();
///
/// let point_wef = Point::new(&mut store, 42, 42);
/// let point_zlh = Point::new(&mut store, 42, 42);
/// let edge_cwf = Edge::test_default(&mut store);
/// let anchor_fvm = Anchor::new(&mut store, &point_wef, &point_zlh, &edge_cwf);
/// let point_ugb = Point::new(&mut store, 42, 42);
/// let point_wfy = Point::new(&mut store, 42, 42);
/// let edge_gjm = Edge::test_default(&mut store);
/// let anchor_qtr = Anchor::new(&mut store, &point_ugb, &point_wfy, &edge_gjm);
/// let point_jkp = Point::new(&mut store, 42, 42);
/// let point_une = Point::new(&mut store, 42, 42);
/// let edge_wqr = Edge::test_default(&mut store);
/// let anchor_fop = Anchor::new(&mut store, &point_jkp, &point_une, &edge_wqr);
/// let point_yco = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_oxy, &anchor_fvm, &anchor_qtr, &anchor_fop, &point_yco);
///
/// let point_vod = drawing_get_one_pnt_across_r17!(associative_ui, store);
/// assert_eq!(&point_yco, point_vod);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_pnt_across_r17 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.middle).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_pnt_across_r17;

/// Macro to traverse [`Point`][ðŸ¦€] âž¡ [`AssociativeUi`][ðŸ¦ž], via _R17(c)_
///
/// This macro expects a &[`Point`][ðŸ¦€], and returns an Option<&[`AssociativeUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Point
/// [ðŸ¦ž]: crate::drawing::types::AssociativeUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_aui_across_r17;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_srj = Associative::default();
///
/// let point_udl = Point::new(&mut store, 42, 42);
/// let point_icn = Point::new(&mut store, 42, 42);
/// let edge_ieh = Edge::test_default(&mut store);
/// let anchor_cwb = Anchor::new(&mut store, &point_udl, &point_icn, &edge_ieh);
/// let point_gyn = Point::new(&mut store, 42, 42);
/// let point_igy = Point::new(&mut store, 42, 42);
/// let edge_ehh = Edge::test_default(&mut store);
/// let anchor_grp = Anchor::new(&mut store, &point_gyn, &point_igy, &edge_ehh);
/// let point_bbd = Point::new(&mut store, 42, 42);
/// let point_sqm = Point::new(&mut store, 42, 42);
/// let edge_xuk = Edge::test_default(&mut store);
/// let anchor_jrf = Anchor::new(&mut store, &point_bbd, &point_sqm, &edge_xuk);
/// let point_ury = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_srj, &anchor_cwb, &anchor_grp, &anchor_jrf, &point_ury);
/// let associative_ui_ivy = drawing_maybe_get_one_aui_across_r17!(point_ury, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_ivy);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_aui_across_r17 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.middle == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r17;

/// Macro to traverse [`ObjectEdge`][ðŸ¦€] âž¡ [`ObjectUi`][ðŸ¦ž], via _R18_
///
/// This macro expects a &[`ObjectEdge`][ðŸ¦€], and returns a &[`ObjectUi`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::ObjectEdge
/// [ðŸ¦ž]: crate::drawing::types::ObjectUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_oui_across_r18;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_wlr = Edge::test_default(&mut store);
/// let point_aoy = Point::new(&mut store, 42, 42);
/// let peaceful_yoke = "nondescript_box".to_owned();
/// let object_euz = Object::default();
///
/// let object_ui_jit = ObjectUi::new(&mut store, &point_aoy, &object_euz, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_wlr, &object_ui_jit);
///
/// let object_ui_utz = drawing_get_one_oui_across_r18!(object_edge, store);
/// assert_eq!(&object_ui_jit, object_ui_utz);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_oui_across_r18 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object_ui-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object_ui(&$input.oui_id).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object_ui-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_oui_across_r18;

/// Macro to traverse [`ObjectUi`][ðŸ¦€] âž¡ [`ObjectEdge`][ðŸ¦ž], via _R18_
///
/// This macro expects a &[`ObjectUi`][ðŸ¦€], and returns a &[`ObjectEdge`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::ObjectUi
/// [ðŸ¦ž]: crate::drawing::types::ObjectEdge
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_many_oui_es_across_r18;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_qfq = Edge::test_default(&mut store);
/// let point_zvc = Point::new(&mut store, 42, 42);
/// let zany_galley = "attractive_song".to_owned();
/// let object_aok = Object::default();
///
/// let object_ui_mol = ObjectUi::new(&mut store, &point_zvc, &object_aok, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_qfq, &object_ui_mol);
/// let object_edge_alz = drawing_get_many_oui_es_across_r18!(object_ui_mol, store);
///
/// assert!(object_edge_alz.iter().find(|&x| **x == object_edge).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_many_oui_es_across_r18 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object_ui-object_edge-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_object_edge()
            .filter_map(|z| if z.1.oui_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&ObjectEdge>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object_ui-object_edge-emit_many_conditional_lookup"}}}
    }};
}
pub use drawing_get_many_oui_es_across_r18;

/// Macro to traverse [`BinaryUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R8_
///
/// This macro expects a &[`BinaryUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::BinaryUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_anch_across_r8;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_kbs = Point::new(&mut store, 42, 42);
/// let point_fdq = Point::new(&mut store, 42, 42);
/// let edge_gwf = Edge::test_default(&mut store);
/// let anchor_fmn = Anchor::new(&mut store, &point_kbs, &point_fdq, &edge_gwf);
/// let point_rlr = Point::new(&mut store, 42, 42);
/// let point_hyz = Point::new(&mut store, 42, 42);
/// let edge_qvm = Edge::test_default(&mut store);
/// let anchor_fov = Anchor::new(&mut store, &point_rlr, &point_hyz, &edge_qvm);
/// let binary_vgy = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_fmn, &anchor_fov, &binary_vgy);
///
/// let anchor_ins = drawing_get_one_anch_across_r8!(binary_ui, store);
/// assert_eq!(&anchor_fmn, anchor_ins);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r8 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.to).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_anch_across_r8;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`BinaryUi`][ðŸ¦ž], via _R8(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`BinaryUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::BinaryUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_bui_across_r8;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_wkp = Point::new(&mut store, 42, 42);
/// let point_xvj = Point::new(&mut store, 42, 42);
/// let edge_vcd = Edge::test_default(&mut store);
/// let anchor_shz = Anchor::new(&mut store, &point_wkp, &point_xvj, &edge_vcd);
/// let point_gol = Point::new(&mut store, 42, 42);
/// let point_sdg = Point::new(&mut store, 42, 42);
/// let edge_wmj = Edge::test_default(&mut store);
/// let anchor_yvs = Anchor::new(&mut store, &point_gol, &point_sdg, &edge_wmj);
/// let binary_wya = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_shz, &anchor_yvs, &binary_wya);
/// let binary_ui_zto = drawing_maybe_get_one_bui_across_r8!(anchor_shz, store);
///
/// assert_eq!(Some(&binary_ui), binary_ui_zto);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_bui_across_r8 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_binary_ui()
            .find(|z| z.1.to == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_bui_across_r8;

/// Macro to traverse [`AssociativeUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R16_
///
/// This macro expects a &[`AssociativeUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::AssociativeUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_get_one_anch_across_r16;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_gsg = Associative::default();
///
/// let point_yih = Point::new(&mut store, 42, 42);
/// let point_lag = Point::new(&mut store, 42, 42);
/// let edge_acw = Edge::test_default(&mut store);
/// let anchor_stf = Anchor::new(&mut store, &point_yih, &point_lag, &edge_acw);
/// let point_sub = Point::new(&mut store, 42, 42);
/// let point_hkz = Point::new(&mut store, 42, 42);
/// let edge_ugu = Edge::test_default(&mut store);
/// let anchor_tld = Anchor::new(&mut store, &point_sub, &point_hkz, &edge_ugu);
/// let point_ddn = Point::new(&mut store, 42, 42);
/// let point_qac = Point::new(&mut store, 42, 42);
/// let edge_cyd = Edge::test_default(&mut store);
/// let anchor_vds = Anchor::new(&mut store, &point_ddn, &point_qac, &edge_cyd);
/// let point_smz = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_gsg, &anchor_stf, &anchor_tld, &anchor_vds, &point_smz);
///
/// let anchor_kne = drawing_get_one_anch_across_r16!(associative_ui, store);
/// assert_eq!(&anchor_stf, anchor_kne);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r16 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.from).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_anch_across_r16;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`AssociativeUi`][ðŸ¦ž], via _R16(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`AssociativeUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::AssociativeUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_aui_across_r16;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_dro = Associative::default();
///
/// let point_orh = Point::new(&mut store, 42, 42);
/// let point_mln = Point::new(&mut store, 42, 42);
/// let edge_aek = Edge::test_default(&mut store);
/// let anchor_sge = Anchor::new(&mut store, &point_orh, &point_mln, &edge_aek);
/// let point_dzi = Point::new(&mut store, 42, 42);
/// let point_odf = Point::new(&mut store, 42, 42);
/// let edge_yyy = Edge::test_default(&mut store);
/// let anchor_nzk = Anchor::new(&mut store, &point_dzi, &point_odf, &edge_yyy);
/// let point_npf = Point::new(&mut store, 42, 42);
/// let point_nud = Point::new(&mut store, 42, 42);
/// let edge_eon = Edge::test_default(&mut store);
/// let anchor_lwp = Anchor::new(&mut store, &point_npf, &point_nud, &edge_eon);
/// let point_ija = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_dro, &anchor_sge, &anchor_nzk, &anchor_lwp, &point_ija);
/// let associative_ui_ybl = drawing_maybe_get_one_aui_across_r16!(anchor_sge, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_ybl);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_aui_across_r16 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r16;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`Edge`][ðŸ¦ž], via _R3_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns a &[`Edge`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::Edge
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_edg_across_r3;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_sfv = Point::new(&mut store, 42, 42);
/// let point_ypw = Point::new(&mut store, 42, 42);
/// let edge_glk = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_sfv, &point_ypw, &edge_glk);
///
/// let edge_cqc = drawing_get_one_edg_across_r3!(anchor, store);
/// assert_eq!(&edge_glk, edge_cqc);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_edg_across_r3 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"edge-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_edge(&$input.edge).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"edge-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_edg_across_r3;

/// Macro to traverse [`Edge`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R3(c)_
///
/// This macro expects a &[`Edge`][ðŸ¦€], and returns an Option<&[`Anchor`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Edge
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_anch_across_r3;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_lpp = Point::new(&mut store, 42, 42);
/// let point_qrh = Point::new(&mut store, 42, 42);
/// let edge_afl = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_lpp, &point_qrh, &edge_afl);
/// let anchor_kgi = drawing_maybe_get_one_anch_across_r3!(edge_afl, store);
///
/// assert_eq!(Some(&anchor), anchor_kgi);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_anch_across_r3 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"edge-anchor-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.edge == $input.get_id())
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"edge-anchor-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_anch_across_r3;

/// Macro to traverse [`ObjectEdge`][ðŸ¦€] âž¡ [`Edge`][ðŸ¦ž], via _R19_
///
/// This macro expects a &[`ObjectEdge`][ðŸ¦€], and returns a &[`Edge`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::ObjectEdge
/// [ðŸ¦ž]: crate::drawing::types::Edge
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing_get_one_edg_across_r19;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_woi = Edge::test_default(&mut store);
/// let point_jqb = Point::new(&mut store, 42, 42);
/// let heavy_shame = "scrawny_hands".to_owned();
/// let object_cli = Object::default();
///
/// let object_ui_ors = ObjectUi::new(&mut store, &point_jqb, &object_cli, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_woi, &object_ui_ors);
///
/// let edge_yem = drawing_get_one_edg_across_r19!(object_edge, store);
/// assert_eq!(&edge_woi, edge_yem);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_edg_across_r19 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"edge-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_edge(&$input.edge).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"edge-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_edg_across_r19;

/// Macro to traverse [`Edge`][ðŸ¦€] âž¡ [`ObjectEdge`][ðŸ¦ž], via _R19(c)_
///
/// This macro expects a &[`Edge`][ðŸ¦€], and returns an Option<&[`ObjectEdge`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Edge
/// [ðŸ¦ž]: crate::drawing::types::ObjectEdge
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing_maybe_get_one_oui_e_across_r19;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_hnv = Edge::test_default(&mut store);
/// let point_guw = Point::new(&mut store, 42, 42);
/// let valuable_support = "gleaming_tiger".to_owned();
/// let object_wld = Object::default();
///
/// let object_ui_xbu = ObjectUi::new(&mut store, &point_guw, &object_wld, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_hnv, &object_ui_xbu);
/// let object_edge_xdc = drawing_maybe_get_one_oui_e_across_r19!(edge_hnv, store);
///
/// assert_eq!(Some(&object_edge), object_edge_xdc);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_oui_e_across_r19 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"edge-object_edge-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_object_edge()
            .find(|z| z.1.edge == $input.get_id())
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"edge-object_edge-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_oui_e_across_r19;

/// Macro to traverse [`BinaryUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R7_
///
/// This macro expects a &[`BinaryUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::BinaryUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing_get_one_anch_across_r7;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_hfd = Point::new(&mut store, 42, 42);
/// let point_igh = Point::new(&mut store, 42, 42);
/// let edge_ihc = Edge::test_default(&mut store);
/// let anchor_lda = Anchor::new(&mut store, &point_hfd, &point_igh, &edge_ihc);
/// let point_nro = Point::new(&mut store, 42, 42);
/// let point_crt = Point::new(&mut store, 42, 42);
/// let edge_wzh = Edge::test_default(&mut store);
/// let anchor_ifw = Anchor::new(&mut store, &point_nro, &point_crt, &edge_wzh);
/// let binary_fwb = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_lda, &anchor_ifw, &binary_fwb);
///
/// let anchor_wfe = drawing_get_one_anch_across_r7!(binary_ui, store);
/// assert_eq!(&anchor_lda, anchor_wfe);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r7 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.from).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_anch_across_r7;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`BinaryUi`][ðŸ¦ž], via _R7(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`BinaryUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::BinaryUi
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_bui_across_r7;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_pkn = Point::new(&mut store, 42, 42);
/// let point_cuj = Point::new(&mut store, 42, 42);
/// let edge_epp = Edge::test_default(&mut store);
/// let anchor_vdc = Anchor::new(&mut store, &point_pkn, &point_cuj, &edge_epp);
/// let point_dzn = Point::new(&mut store, 42, 42);
/// let point_ibm = Point::new(&mut store, 42, 42);
/// let edge_lfr = Edge::test_default(&mut store);
/// let anchor_ezr = Anchor::new(&mut store, &point_dzn, &point_ibm, &edge_lfr);
/// let binary_rsn = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_vdc, &anchor_ezr, &binary_rsn);
/// let binary_ui_kqj = drawing_maybe_get_one_bui_across_r7!(anchor_vdc, store);
///
/// assert_eq!(Some(&binary_ui), binary_ui_kqj);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_bui_across_r7 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_binary_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_bui_across_r7;

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`Point`][ðŸ¦ž], via _R4_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns a &[`Point`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::Point
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_get_one_pnt_across_r4;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_rfb = Point::new(&mut store, 42, 42);
/// let point_idd = Point::new(&mut store, 42, 42);
/// let edge_sty = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_rfb, &point_idd, &edge_sty);
///
/// let point_lco = drawing_get_one_pnt_across_r4!(anchor, store);
/// assert_eq!(&point_rfb, point_lco);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_pnt_across_r4 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.location).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_pnt_across_r4;

/// Macro to traverse [`Point`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R4(c)_
///
/// This macro expects a &[`Point`][ðŸ¦€], and returns an Option<&[`Anchor`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Point
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_maybe_get_one_anch_across_r4;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_vvn = Point::new(&mut store, 42, 42);
/// let point_aoi = Point::new(&mut store, 42, 42);
/// let edge_agd = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_vvn, &point_aoi, &edge_agd);
/// let anchor_obc = drawing_maybe_get_one_anch_across_r4!(point_vvn, store);
///
/// assert_eq!(Some(&anchor), anchor_obc);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_anch_across_r4 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.location == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_anch_across_r4;
