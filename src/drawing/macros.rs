//! Macros for navigating the "Drawing" domain
//!
//! # Generated Code -- edit _with care_.
//!
//! Don't mess with anything between `{"magic":"î¨","kind":"CriticalBlockBegin"}`
//! and `{"magic":"î¨","kind":"CriticalBlockEnd"}`. Otherwise, you should be free
//! to go wild. Happy hacking!
//!
//! Use the following invocation to reproduce:
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
//! ```shell
//!  sarzak gen
//! ```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
// {"magic":"î¨","version":"0.5.0"}

/// Macro to traverse [`IsaUi`][ğŸ¦€] â¡ [`Anchor`][ğŸ¦], via _R9_
///
/// This macro expects a &[`IsaUi`][ğŸ¦€], and returns a &[`Anchor`][ğŸ¦].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ğŸ¦€]: crate::drawing::types::IsaUi
/// [ğŸ¦]: crate::drawing::types::Anchor
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_anch_across_r9;
/// # let mut store = sarzak::drawing::ObjectStore::new();
/// # let mut sarzak_store = sarzak::sarzak::ObjectStore::new();
///
/// let isa_yaw = Isa::test_default(&mut sarzak_store);
///
/// let point_kcu = Point::new(&mut store, 42, 42);
/// let point_znv = Point::new(&mut store, 42, 42);
/// let edge_nss = Edge::test_default(&mut store);
/// let anchor_ini = Anchor::new(&mut store, &point_kcu, &point_znv, &edge_nss);
///
/// let isa_ui = IsaUi::new(&mut store, &isa_yaw, &anchor_ini);
///
/// let anchor_dxi = drawing_get_one_anch_across_r9!(isa_ui, store);
/// assert_eq!(&anchor_ini, anchor_dxi);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r9 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.from).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r9;

/// Macro to traverse [`Anchor`][ğŸ¦€] â¡ [`IsaUi`][ğŸ¦], via _R9(c)_
///
/// This macro expects a &[`Anchor`][ğŸ¦€], and returns an Option<&[`IsaUi`][ğŸ¦]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ğŸ¦€]: crate::drawing::types::Anchor
/// [ğŸ¦]: crate::drawing::types::IsaUi
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_iui_across_r9;
/// # let mut store = sarzak::drawing::ObjectStore::new();
/// # let mut sarzak_store = sarzak::sarzak::ObjectStore::new();
///
/// let isa_lyu = Isa::test_default(&mut sarzak_store);
///
/// let point_ctq = Point::new(&mut store, 42, 42);
/// let point_tpa = Point::new(&mut store, 42, 42);
/// let edge_akp = Edge::test_default(&mut store);
/// let anchor_xua = Anchor::new(&mut store, &point_ctq, &point_tpa, &edge_akp);
///
/// let isa_ui = IsaUi::new(&mut store, &isa_lyu, &anchor_xua);
/// let isa_ui_qvu = drawing_maybe_get_one_iui_across_r9!(anchor_xua, store);
///
/// assert_eq!(Some(&isa_ui), isa_ui_qvu);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_iui_across_r9 {
    ($input:expr, $store:expr) => {{
        // {"magic":"î¨","kind":"CriticalBlockBegin"}
        // {"magic":"î¨","kind":{"CriticalBlockBegin":{"tag":"anchor-isa_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_isa_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
// âš¡ï¸         // {"magic":"î¨","kind":"CriticalBlockEnd"}
            // {"magic":"î¨","kind":{"CriticalBlockEnd":{"tag":"anchor-isa_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_iui_across_r9;

/// Macro to traverse [`AssociativeUi`][ğŸ¦€] â¡ [`Anchor`][ğŸ¦], via _R15_
///
/// This macro expects a &[`AssociativeUi`][ğŸ¦€], and returns a &[`Anchor`][ğŸ¦].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ğŸ¦€]: crate::drawing::types::AssociativeUi
/// [ğŸ¦]: crate::drawing::types::Anchor
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_anch_across_r15;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_pez = Associative::default();
///
/// let point_wnq = Point::new(&mut store, 42, 42);
/// let point_ojr = Point::new(&mut store, 42, 42);
/// let edge_jly = Edge::test_default(&mut store);
/// let anchor_pas = Anchor::new(&mut store, &point_wnq, &point_ojr, &edge_jly);
/// let point_swy = Point::new(&mut store, 42, 42);
/// let point_sry = Point::new(&mut store, 42, 42);
/// let edge_nfj = Edge::test_default(&mut store);
/// let anchor_hbk = Anchor::new(&mut store, &point_swy, &point_sry, &edge_nfj);
/// let point_ppp = Point::new(&mut store, 42, 42);
/// let point_wan = Point::new(&mut store, 42, 42);
/// let edge_gba = Edge::test_default(&mut store);
/// let anchor_zfd = Anchor::new(&mut store, &point_ppp, &point_wan, &edge_gba);
/// let point_fns = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_pez, &anchor_pas, &anchor_hbk, &anchor_zfd, &point_fns);
///
/// let anchor_vgt = drawing_get_one_anch_across_r15!(associative_ui, store);
/// assert_eq!(&anchor_pas, anchor_vgt);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r15 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.other).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r15;

/// Macro to traverse [`Anchor`][ğŸ¦€] â¡ [`AssociativeUi`][ğŸ¦], via _R15(c)_
///
/// This macro expects a &[`Anchor`][ğŸ¦€], and returns an Option<&[`AssociativeUi`][ğŸ¦]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ğŸ¦€]: crate::drawing::types::Anchor
/// [ğŸ¦]: crate::drawing::types::AssociativeUi
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing_maybe_get_one_aui_across_r15;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_lue = Associative::default();
///
/// let point_otd = Point::new(&mut store, 42, 42);
/// let point_mnq = Point::new(&mut store, 42, 42);
/// let edge_nmu = Edge::test_default(&mut store);
/// let anchor_ezz = Anchor::new(&mut store, &point_otd, &point_mnq, &edge_nmu);
/// let point_aht = Point::new(&mut store, 42, 42);
/// let point_pbr = Point::new(&mut store, 42, 42);
/// let edge_vpr = Edge::test_default(&mut store);
/// let anchor_ren = Anchor::new(&mut store, &point_aht, &point_pbr, &edge_vpr);
/// let point_vds = Point::new(&mut store, 42, 42);
/// let point_doz = Point::new(&mut store, 42, 42);
/// let edge_ccn = Edge::test_default(&mut store);
/// let anchor_oar = Anchor::new(&mut store, &point_vds, &point_doz, &edge_ccn);
/// let point_lgf = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_lue, &anchor_ezz, &anchor_ren, &anchor_oar, &point_lgf);
/// let associative_ui_cru = drawing_maybe_get_one_aui_across_r15!(anchor_ezz, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_cru);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_aui_across_r15 {
    ($input:expr, $store:expr) => {{
        // {"magic":"î¨","kind":"CriticalBlockBegin"}
        // {"magic":"î¨","kind":{"CriticalBlockBegin":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.other == $input.id)
            .map(|(_, z)| z)
// âš¡ï¸         // {"magic":"î¨","kind":"CriticalBlockEnd"}
            // {"magic":"î¨","kind":{"CriticalBlockEnd":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r15;

/// Macro to traverse [`Anchor`][ğŸ¦€] â¡ [`Point`][ğŸ¦], via _R5_
///
/// This macro expects a &[`Anchor`][ğŸ¦€], and returns a &[`Point`][ğŸ¦].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ğŸ¦€]: crate::drawing::types::Anchor
/// [ğŸ¦]: crate::drawing::types::Point
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_pnt_across_r5;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_gzh = Point::new(&mut store, 42, 42);
/// let point_red = Point::new(&mut store, 42, 42);
/// let edge_bad = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_gzh, &point_red, &edge_bad);
///
/// let point_wqn = drawing_get_one_pnt_across_r5!(anchor, store);
/// assert_eq!(&point_gzh, point_wqn);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_pnt_across_r5 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.offset).unwrap()
    }};
}
pub use drawing_get_one_pnt_across_r5;

/// Macro to traverse [`Point`][ğŸ¦€] â¡ [`Anchor`][ğŸ¦], via _R5(c)_
///
/// This macro expects a &[`Point`][ğŸ¦€], and returns an Option<&[`Anchor`][ğŸ¦]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ğŸ¦€]: crate::drawing::types::Point
/// [ğŸ¦]: crate::drawing::types::Anchor
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_maybe_get_one_anch_across_r5;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_zvn = Point::new(&mut store, 42, 42);
/// let point_gcz = Point::new(&mut store, 42, 42);
/// let edge_jhh = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_zvn, &point_gcz, &edge_jhh);
/// let anchor_ppg = drawing_maybe_get_one_anch_across_r5!(point_zvn, store);
///
/// assert_eq!(Some(&anchor), anchor_ppg);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_anch_across_r5 {
    ($input:expr, $store:expr) => {{
        // {"magic":"î¨","kind":"CriticalBlockBegin"}
        // {"magic":"î¨","kind":{"CriticalBlockBegin":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.offset == $input.id)
            .map(|(_, z)| z)
// âš¡ï¸         // {"magic":"î¨","kind":"CriticalBlockEnd"}
            // {"magic":"î¨","kind":{"CriticalBlockEnd":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_anch_across_r5;

/// Macro to traverse [`AssociativeUi`][ğŸ¦€] â¡ [`Anchor`][ğŸ¦], via _R14_
///
/// This macro expects a &[`AssociativeUi`][ğŸ¦€], and returns a &[`Anchor`][ğŸ¦].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ğŸ¦€]: crate::drawing::types::AssociativeUi
/// [ğŸ¦]: crate::drawing::types::Anchor
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing_get_one_anch_across_r14;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_rfp = Associative::default();
///
/// let point_exw = Point::new(&mut store, 42, 42);
/// let point_uht = Point::new(&mut store, 42, 42);
/// let edge_oxm = Edge::test_default(&mut store);
/// let anchor_wiz = Anchor::new(&mut store, &point_exw, &point_uht, &edge_oxm);
/// let point_ccn = Point::new(&mut store, 42, 42);
/// let point_jqu = Point::new(&mut store, 42, 42);
/// let edge_mri = Edge::test_default(&mut store);
/// let anchor_jhu = Anchor::new(&mut store, &point_ccn, &point_jqu, &edge_mri);
/// let point_azr = Point::new(&mut store, 42, 42);
/// let point_nkk = Point::new(&mut store, 42, 42);
/// let edge_sga = Edge::test_default(&mut store);
/// let anchor_nve = Anchor::new(&mut store, &point_azr, &point_nkk, &edge_sga);
/// let point_vqs = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_rfp, &anchor_wiz, &anchor_jhu, &anchor_nve, &point_vqs);
///
/// let anchor_sad = drawing_get_one_anch_across_r14!(associative_ui, store);
/// assert_eq!(&anchor_wiz, anchor_sad);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r14 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.one).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r14;

/// Macro to traverse [`Anchor`][ğŸ¦€] â¡ [`AssociativeUi`][ğŸ¦], via _R14(c)_
///
/// This macro expects a &[`Anchor`][ğŸ¦€], and returns an Option<&[`AssociativeUi`][ğŸ¦]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ğŸ¦€]: crate::drawing::types::Anchor
/// [ğŸ¦]: crate::drawing::types::AssociativeUi
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_aui_across_r14;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_xap = Associative::default();
///
/// let point_zcd = Point::new(&mut store, 42, 42);
/// let point_dfy = Point::new(&mut store, 42, 42);
/// let edge_drt = Edge::test_default(&mut store);
/// let anchor_svm = Anchor::new(&mut store, &point_zcd, &point_dfy, &edge_drt);
/// let point_gre = Point::new(&mut store, 42, 42);
/// let point_uhi = Point::new(&mut store, 42, 42);
/// let edge_ngu = Edge::test_default(&mut store);
/// let anchor_tdv = Anchor::new(&mut store, &point_gre, &point_uhi, &edge_ngu);
/// let point_mbk = Point::new(&mut store, 42, 42);
/// let point_qte = Point::new(&mut store, 42, 42);
/// let edge_jtw = Edge::test_default(&mut store);
/// let anchor_hqu = Anchor::new(&mut store, &point_mbk, &point_qte, &edge_jtw);
/// let point_odo = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_xap, &anchor_svm, &anchor_tdv, &anchor_hqu, &point_odo);
/// let associative_ui_gxi = drawing_maybe_get_one_aui_across_r14!(anchor_svm, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_gxi);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_aui_across_r14 {
    ($input:expr, $store:expr) => {{
        // {"magic":"î¨","kind":"CriticalBlockBegin"}
        // {"magic":"î¨","kind":{"CriticalBlockBegin":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.one == $input.id)
            .map(|(_, z)| z)
// âš¡ï¸         // {"magic":"î¨","kind":"CriticalBlockEnd"}
            // {"magic":"î¨","kind":{"CriticalBlockEnd":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r14;

/// Macro to traverse [`Anchor`][ğŸ¦€] â¡ [`IsaUi`][ğŸ¦], across [`SubtypeAnchors`][ğŸ¦‘] via _R10_
///
/// This macro expects a &[`Anchor`][ğŸ¦€], and returns a &[`IsaUi`][ğŸ¦].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ğŸ¦€]: crate::drawing::types::Anchor
/// [ğŸ¦]: crate::drawing::types::IsaUi
/// [ğŸ¦‘]: crate::drawing::types::SubtypeAnchors
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::SubtypeAnchors;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing_maybe_get_one_iui_across_r10;
/// # let mut store = sarzak::drawing::ObjectStore::new();
/// # let mut sarzak_store = sarzak::sarzak::ObjectStore::new();
///
/// let point_vzn = Point::new(&mut store, 42, 42);
/// let point_xjt = Point::new(&mut store, 42, 42);
/// let edge_shn = Edge::test_default(&mut store);
/// let anchor_fnt = Anchor::new(&mut store, &point_vzn, &point_xjt, &edge_shn);
/// let isa_mxv = Isa::test_default(&mut sarzak_store);
///
/// let point_epi = Point::new(&mut store, 42, 42);
/// let point_jjn = Point::new(&mut store, 42, 42);
/// let edge_cim = Edge::test_default(&mut store);
/// let anchor_biz = Anchor::new(&mut store, &point_epi, &point_jjn, &edge_cim);
/// let isa_ui_ayf = IsaUi::new(&mut store, &isa_mxv, &anchor_biz);
/// let subtype_anchors = SubtypeAnchors::new(&mut store, &anchor_fnt, &isa_ui_ayf);
///
/// let isa_ui_fhc = drawing_maybe_get_one_iui_across_r10!(anchor_fnt, store);
/// assert_eq!(Some(&isa_ui_ayf), isa_ui_fhc);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_iui_across_r10 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_maybe_get_one
        $store
            .iter_subtype_anchors()
            .filter(|a| a.1.anchor_id == $input.id)
            .next()
            .and_then(|a| $store.exhume_isa_ui(&a.1.isaui_id))
    }};
}
pub use drawing_maybe_get_one_iui_across_r10;

/// Macro to traverse [`IsaUi`][ğŸ¦€] â¡ [`Anchor`][ğŸ¦], across [`SubtypeAnchors`][ğŸ¦‘] via _R10_
///
/// This macro expects a &[`IsaUi`][ğŸ¦€], and returns a &[`Anchor`][ğŸ¦].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ğŸ¦€]: crate::drawing::types::IsaUi
/// [ğŸ¦]: crate::drawing::types::Anchor
/// [ğŸ¦‘]: crate::drawing::types::SubtypeAnchors
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::SubtypeAnchors;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_many_anch_across_r10;
/// # let mut store = sarzak::drawing::ObjectStore::new();
/// # let mut sarzak_store = sarzak::sarzak::ObjectStore::new();
///
/// let point_edw = Point::new(&mut store, 42, 42);
/// let point_nse = Point::new(&mut store, 42, 42);
/// let edge_oog = Edge::test_default(&mut store);
/// let anchor_ztc = Anchor::new(&mut store, &point_edw, &point_nse, &edge_oog);
/// let isa_xus = Isa::test_default(&mut sarzak_store);
///
/// let point_igm = Point::new(&mut store, 42, 42);
/// let point_rse = Point::new(&mut store, 42, 42);
/// let edge_xqv = Edge::test_default(&mut store);
/// let anchor_vke = Anchor::new(&mut store, &point_igm, &point_rse, &edge_xqv);
/// let isa_ui_rbm = IsaUi::new(&mut store, &isa_xus, &anchor_vke);
/// let subtype_anchors = SubtypeAnchors::new(&mut store, &anchor_ztc, &isa_ui_rbm);
///
/// let anchor_fst = drawing_get_many_anch_across_r10!(isa_ui_rbm, store);
/// assert!(anchor_fst.iter().find(|&x| **x == anchor_ztc).is_some());
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_many_anch_across_r10 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_many
        $store
            .iter_subtype_anchors()
            .filter(|a| a.1.isaui_id == $input.id)
            .map(|a| $store.exhume_anchor(&a.1.anchor_id).unwrap())
            .collect::<Vec<&Anchor>>()
    }};
}
pub use drawing_get_many_anch_across_r10;

/// Macro to traverse [`ObjectUi`][ğŸ¦€] â¡ [`Point`][ğŸ¦], via _R13_
///
/// This macro expects a &[`ObjectUi`][ğŸ¦€], and returns a &[`Point`][ğŸ¦].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ğŸ¦€]: crate::drawing::types::ObjectUi
/// [ğŸ¦]: crate::drawing::types::Point
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing_get_one_pnt_across_r13;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_vii = Point::new(&mut store, 42, 42);
/// let ugly_account = "excited_process".to_owned();
/// let object_uys = Object::default();
///
///
/// let object_ui = ObjectUi::new(&mut store, &point_vii, &object_uys, 42, 42);
///
/// let point_cva = drawing_get_one_pnt_across_r13!(object_ui, store);
/// assert_eq!(&point_vii, point_cva);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_pnt_across_r13 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.origin).unwrap()
    }};
}
pub use drawing_get_one_pnt_across_r13;

/// Macro to traverse [`Point`][ğŸ¦€] â¡ [`ObjectUi`][ğŸ¦], via _R13(c)_
///
/// This macro expects a &[`Point`][ğŸ¦€], and returns an Option<&[`ObjectUi`][ğŸ¦]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ğŸ¦€]: crate::drawing::types::Point
/// [ğŸ¦]: crate::drawing::types::ObjectUi
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing_maybe_get_one_oui_across_r13;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_fyx = Point::new(&mut store, 42, 42);
/// let blue_eyed_board = "tasteless_moon".to_owned();
/// let object_vhs = Object::default();
///
///
/// let object_ui = ObjectUi::new(&mut store, &point_fyx, &object_vhs, 42, 42);
/// let object_ui_ozy = drawing_maybe_get_one_oui_across_r13!(point_fyx, store);
///
/// assert_eq!(Some(&object_ui), object_ui_ozy);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_oui_across_r13 {
    ($input:expr, $store:expr) => {{
        // {"magic":"î¨","kind":"CriticalBlockBegin"}
        // {"magic":"î¨","kind":{"CriticalBlockBegin":{"tag":"point-object_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_object_ui()
            .find(|z| z.1.origin == $input.id)
            .map(|(_, z)| z)
// âš¡ï¸         // {"magic":"î¨","kind":"CriticalBlockEnd"}
            // {"magic":"î¨","kind":{"CriticalBlockEnd":{"tag":"point-object_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_oui_across_r13;

/// Macro to traverse [`AssociativeUi`][ğŸ¦€] â¡ [`Point`][ğŸ¦], via _R17_
///
/// This macro expects a &[`AssociativeUi`][ğŸ¦€], and returns a &[`Point`][ğŸ¦].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ğŸ¦€]: crate::drawing::types::AssociativeUi
/// [ğŸ¦]: crate::drawing::types::Point
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_pnt_across_r17;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_fzx = Associative::default();
///
/// let point_any = Point::new(&mut store, 42, 42);
/// let point_byz = Point::new(&mut store, 42, 42);
/// let edge_gyi = Edge::test_default(&mut store);
/// let anchor_qxt = Anchor::new(&mut store, &point_any, &point_byz, &edge_gyi);
/// let point_uoy = Point::new(&mut store, 42, 42);
/// let point_hpi = Point::new(&mut store, 42, 42);
/// let edge_vxg = Edge::test_default(&mut store);
/// let anchor_hfp = Anchor::new(&mut store, &point_uoy, &point_hpi, &edge_vxg);
/// let point_tlr = Point::new(&mut store, 42, 42);
/// let point_coz = Point::new(&mut store, 42, 42);
/// let edge_fqn = Edge::test_default(&mut store);
/// let anchor_jxx = Anchor::new(&mut store, &point_tlr, &point_coz, &edge_fqn);
/// let point_oah = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_fzx, &anchor_qxt, &anchor_hfp, &anchor_jxx, &point_oah);
///
/// let point_tub = drawing_get_one_pnt_across_r17!(associative_ui, store);
/// assert_eq!(&point_oah, point_tub);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_pnt_across_r17 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.middle).unwrap()
    }};
}
pub use drawing_get_one_pnt_across_r17;

/// Macro to traverse [`Point`][ğŸ¦€] â¡ [`AssociativeUi`][ğŸ¦], via _R17(c)_
///
/// This macro expects a &[`Point`][ğŸ¦€], and returns an Option<&[`AssociativeUi`][ğŸ¦]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ğŸ¦€]: crate::drawing::types::Point
/// [ğŸ¦]: crate::drawing::types::AssociativeUi
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_maybe_get_one_aui_across_r17;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_lbm = Associative::default();
///
/// let point_yqe = Point::new(&mut store, 42, 42);
/// let point_vtg = Point::new(&mut store, 42, 42);
/// let edge_jmw = Edge::test_default(&mut store);
/// let anchor_gpw = Anchor::new(&mut store, &point_yqe, &point_vtg, &edge_jmw);
/// let point_awy = Point::new(&mut store, 42, 42);
/// let point_ojc = Point::new(&mut store, 42, 42);
/// let edge_bpb = Edge::test_default(&mut store);
/// let anchor_nva = Anchor::new(&mut store, &point_awy, &point_ojc, &edge_bpb);
/// let point_fsl = Point::new(&mut store, 42, 42);
/// let point_cvi = Point::new(&mut store, 42, 42);
/// let edge_gns = Edge::test_default(&mut store);
/// let anchor_pzk = Anchor::new(&mut store, &point_fsl, &point_cvi, &edge_gns);
/// let point_wjg = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_lbm, &anchor_gpw, &anchor_nva, &anchor_pzk, &point_wjg);
/// let associative_ui_gjg = drawing_maybe_get_one_aui_across_r17!(point_wjg, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_gjg);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_aui_across_r17 {
    ($input:expr, $store:expr) => {{
        // {"magic":"î¨","kind":"CriticalBlockBegin"}
        // {"magic":"î¨","kind":{"CriticalBlockBegin":{"tag":"point-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.middle == $input.id)
            .map(|(_, z)| z)
// âš¡ï¸         // {"magic":"î¨","kind":"CriticalBlockEnd"}
            // {"magic":"î¨","kind":{"CriticalBlockEnd":{"tag":"point-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r17;

/// Macro to traverse [`ObjectEdge`][ğŸ¦€] â¡ [`ObjectUi`][ğŸ¦], via _R18_
///
/// This macro expects a &[`ObjectEdge`][ğŸ¦€], and returns a &[`ObjectUi`][ğŸ¦].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ğŸ¦€]: crate::drawing::types::ObjectEdge
/// [ğŸ¦]: crate::drawing::types::ObjectUi
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing_get_one_oui_across_r18;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_gdk = Edge::test_default(&mut store);
/// let point_erz = Point::new(&mut store, 42, 42);
/// let gorgeous_snake = "present_brick".to_owned();
/// let object_jrl = Object::default();
///
/// let object_ui_wrq = ObjectUi::new(&mut store, &point_erz, &object_jrl, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_gdk, &object_ui_wrq);
///
/// let object_ui_rvv = drawing_get_one_oui_across_r18!(object_edge, store);
/// assert_eq!(&object_ui_wrq, object_ui_rvv);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_oui_across_r18 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object_ui(&$input.oui_id).unwrap()
    }};
}
pub use drawing_get_one_oui_across_r18;

/// Macro to traverse [`ObjectUi`][ğŸ¦€] â¡ [`ObjectEdge`][ğŸ¦], via _R18_
///
/// This macro expects a &[`ObjectUi`][ğŸ¦€], and returns a &[`ObjectEdge`][ğŸ¦].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ğŸ¦€]: crate::drawing::types::ObjectUi
/// [ğŸ¦]: crate::drawing::types::ObjectEdge
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_many_oui_es_across_r18;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_mnt = Edge::test_default(&mut store);
/// let point_hzv = Point::new(&mut store, 42, 42);
/// let necessary_back = "well_to_do_industry".to_owned();
/// let object_ndk = Object::default();
///
/// let object_ui_vcs = ObjectUi::new(&mut store, &point_hzv, &object_ndk, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_mnt, &object_ui_vcs);
/// let object_edge_miz = drawing_get_many_oui_es_across_r18!(object_ui_vcs, store);
///
/// assert!(object_edge_miz.iter().find(|&x| **x == object_edge).is_some());
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_many_oui_es_across_r18 {
    ($input:expr, $store:expr) => {{
        // {"magic":"î¨","kind":"CriticalBlockBegin"}
        // {"magic":"î¨","kind":{"CriticalBlockBegin":{"tag":"object_ui-object_edge-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_object_edge()
// âš¡ï¸             .filter_map(|z| {
// âš¡ï¸                 if z.1.oui_id == $input.id {
// âš¡ï¸                     Some(z.1)
// âš¡ï¸                 } else {
// âš¡ï¸                     None
// âš¡ï¸                 }
// âš¡ï¸             })
            .filter_map(|z| if z.1.oui_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&ObjectEdge>>()
// âš¡ï¸         // {"magic":"î¨","kind":"CriticalBlockEnd"}
            // {"magic":"î¨","kind":{"CriticalBlockEnd":{"tag":"object_ui-object_edge-emit_many_conditional_lookup"}}}
    }};
}
pub use drawing_get_many_oui_es_across_r18;

/// Macro to traverse [`BinaryUi`][ğŸ¦€] â¡ [`Anchor`][ğŸ¦], via _R8_
///
/// This macro expects a &[`BinaryUi`][ğŸ¦€], and returns a &[`Anchor`][ğŸ¦].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ğŸ¦€]: crate::drawing::types::BinaryUi
/// [ğŸ¦]: crate::drawing::types::Anchor
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_anch_across_r8;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_fvj = Point::new(&mut store, 42, 42);
/// let point_ion = Point::new(&mut store, 42, 42);
/// let edge_sgj = Edge::test_default(&mut store);
/// let anchor_oew = Anchor::new(&mut store, &point_fvj, &point_ion, &edge_sgj);
/// let point_qlb = Point::new(&mut store, 42, 42);
/// let point_amj = Point::new(&mut store, 42, 42);
/// let edge_pkf = Edge::test_default(&mut store);
/// let anchor_bjd = Anchor::new(&mut store, &point_qlb, &point_amj, &edge_pkf);
/// let binary_zbb = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_oew, &anchor_bjd, &binary_zbb);
///
/// let anchor_lfd = drawing_get_one_anch_across_r8!(binary_ui, store);
/// assert_eq!(&anchor_oew, anchor_lfd);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r8 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.to).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r8;

/// Macro to traverse [`Anchor`][ğŸ¦€] â¡ [`BinaryUi`][ğŸ¦], via _R8(c)_
///
/// This macro expects a &[`Anchor`][ğŸ¦€], and returns an Option<&[`BinaryUi`][ğŸ¦]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ğŸ¦€]: crate::drawing::types::Anchor
/// [ğŸ¦]: crate::drawing::types::BinaryUi
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_maybe_get_one_bui_across_r8;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_gbq = Point::new(&mut store, 42, 42);
/// let point_hie = Point::new(&mut store, 42, 42);
/// let edge_xhn = Edge::test_default(&mut store);
/// let anchor_rzk = Anchor::new(&mut store, &point_gbq, &point_hie, &edge_xhn);
/// let point_bpg = Point::new(&mut store, 42, 42);
/// let point_stu = Point::new(&mut store, 42, 42);
/// let edge_saa = Edge::test_default(&mut store);
/// let anchor_rkc = Anchor::new(&mut store, &point_bpg, &point_stu, &edge_saa);
/// let binary_tly = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_rzk, &anchor_rkc, &binary_tly);
/// let binary_ui_zds = drawing_maybe_get_one_bui_across_r8!(anchor_rzk, store);
///
/// assert_eq!(Some(&binary_ui), binary_ui_zds);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_bui_across_r8 {
    ($input:expr, $store:expr) => {{
        // {"magic":"î¨","kind":"CriticalBlockBegin"}
        // {"magic":"î¨","kind":{"CriticalBlockBegin":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_binary_ui()
            .find(|z| z.1.to == $input.id)
            .map(|(_, z)| z)
// âš¡ï¸         // {"magic":"î¨","kind":"CriticalBlockEnd"}
            // {"magic":"î¨","kind":{"CriticalBlockEnd":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_bui_across_r8;

/// Macro to traverse [`AssociativeUi`][ğŸ¦€] â¡ [`Anchor`][ğŸ¦], via _R16_
///
/// This macro expects a &[`AssociativeUi`][ğŸ¦€], and returns a &[`Anchor`][ğŸ¦].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ğŸ¦€]: crate::drawing::types::AssociativeUi
/// [ğŸ¦]: crate::drawing::types::Anchor
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_get_one_anch_across_r16;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_ekd = Associative::default();
///
/// let point_doy = Point::new(&mut store, 42, 42);
/// let point_hri = Point::new(&mut store, 42, 42);
/// let edge_qkp = Edge::test_default(&mut store);
/// let anchor_zgo = Anchor::new(&mut store, &point_doy, &point_hri, &edge_qkp);
/// let point_lsb = Point::new(&mut store, 42, 42);
/// let point_jkv = Point::new(&mut store, 42, 42);
/// let edge_qll = Edge::test_default(&mut store);
/// let anchor_pxl = Anchor::new(&mut store, &point_lsb, &point_jkv, &edge_qll);
/// let point_bpi = Point::new(&mut store, 42, 42);
/// let point_xml = Point::new(&mut store, 42, 42);
/// let edge_ijv = Edge::test_default(&mut store);
/// let anchor_arl = Anchor::new(&mut store, &point_bpi, &point_xml, &edge_ijv);
/// let point_daj = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_ekd, &anchor_zgo, &anchor_pxl, &anchor_arl, &point_daj);
///
/// let anchor_tzz = drawing_get_one_anch_across_r16!(associative_ui, store);
/// assert_eq!(&anchor_zgo, anchor_tzz);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r16 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.from).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r16;

/// Macro to traverse [`Anchor`][ğŸ¦€] â¡ [`AssociativeUi`][ğŸ¦], via _R16(c)_
///
/// This macro expects a &[`Anchor`][ğŸ¦€], and returns an Option<&[`AssociativeUi`][ğŸ¦]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ğŸ¦€]: crate::drawing::types::Anchor
/// [ğŸ¦]: crate::drawing::types::AssociativeUi
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing_maybe_get_one_aui_across_r16;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_udc = Associative::default();
///
/// let point_lzz = Point::new(&mut store, 42, 42);
/// let point_qzp = Point::new(&mut store, 42, 42);
/// let edge_rvb = Edge::test_default(&mut store);
/// let anchor_oxq = Anchor::new(&mut store, &point_lzz, &point_qzp, &edge_rvb);
/// let point_gkn = Point::new(&mut store, 42, 42);
/// let point_nbg = Point::new(&mut store, 42, 42);
/// let edge_avr = Edge::test_default(&mut store);
/// let anchor_vms = Anchor::new(&mut store, &point_gkn, &point_nbg, &edge_avr);
/// let point_sip = Point::new(&mut store, 42, 42);
/// let point_imy = Point::new(&mut store, 42, 42);
/// let edge_mjv = Edge::test_default(&mut store);
/// let anchor_xsz = Anchor::new(&mut store, &point_sip, &point_imy, &edge_mjv);
/// let point_iow = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_udc, &anchor_oxq, &anchor_vms, &anchor_xsz, &point_iow);
/// let associative_ui_drg = drawing_maybe_get_one_aui_across_r16!(anchor_oxq, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_drg);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_aui_across_r16 {
    ($input:expr, $store:expr) => {{
        // {"magic":"î¨","kind":"CriticalBlockBegin"}
        // {"magic":"î¨","kind":{"CriticalBlockBegin":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
// âš¡ï¸         // {"magic":"î¨","kind":"CriticalBlockEnd"}
            // {"magic":"î¨","kind":{"CriticalBlockEnd":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r16;

/// Macro to traverse [`Anchor`][ğŸ¦€] â¡ [`Edge`][ğŸ¦], via _R3_
///
/// This macro expects a &[`Anchor`][ğŸ¦€], and returns a &[`Edge`][ğŸ¦].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ğŸ¦€]: crate::drawing::types::Anchor
/// [ğŸ¦]: crate::drawing::types::Edge
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_edg_across_r3;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_tej = Point::new(&mut store, 42, 42);
/// let point_vdg = Point::new(&mut store, 42, 42);
/// let edge_moz = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_tej, &point_vdg, &edge_moz);
///
/// let edge_deo = drawing_get_one_edg_across_r3!(anchor, store);
/// assert_eq!(&edge_moz, edge_deo);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_edg_across_r3 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_edge(&$input.edge).unwrap()
    }};
}
pub use drawing_get_one_edg_across_r3;

/// Macro to traverse [`Edge`][ğŸ¦€] â¡ [`Anchor`][ğŸ¦], via _R3(c)_
///
/// This macro expects a &[`Edge`][ğŸ¦€], and returns an Option<&[`Anchor`][ğŸ¦]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ğŸ¦€]: crate::drawing::types::Edge
/// [ğŸ¦]: crate::drawing::types::Anchor
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_maybe_get_one_anch_across_r3;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_fbh = Point::new(&mut store, 42, 42);
/// let point_fej = Point::new(&mut store, 42, 42);
/// let edge_ibd = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_fbh, &point_fej, &edge_ibd);
/// let anchor_tde = drawing_maybe_get_one_anch_across_r3!(edge_ibd, store);
///
/// assert_eq!(Some(&anchor), anchor_tde);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_anch_across_r3 {
    ($input:expr, $store:expr) => {{
        // {"magic":"î¨","kind":"CriticalBlockBegin"}
        // {"magic":"î¨","kind":{"CriticalBlockBegin":{"tag":"edge-anchor-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.edge == $input.get_id())
            .map(|(_, z)| z)
// âš¡ï¸         // {"magic":"î¨","kind":"CriticalBlockEnd"}
            // {"magic":"î¨","kind":{"CriticalBlockEnd":{"tag":"edge-anchor-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_anch_across_r3;

/// Macro to traverse [`ObjectEdge`][ğŸ¦€] â¡ [`Edge`][ğŸ¦], via _R19_
///
/// This macro expects a &[`ObjectEdge`][ğŸ¦€], and returns a &[`Edge`][ğŸ¦].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ğŸ¦€]: crate::drawing::types::ObjectEdge
/// [ğŸ¦]: crate::drawing::types::Edge
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_edg_across_r19;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_olx = Edge::test_default(&mut store);
/// let point_our = Point::new(&mut store, 42, 42);
/// let cruel_cloud = "deafening_machine".to_owned();
/// let object_cju = Object::default();
///
/// let object_ui_mzn = ObjectUi::new(&mut store, &point_our, &object_cju, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_olx, &object_ui_mzn);
///
/// let edge_yly = drawing_get_one_edg_across_r19!(object_edge, store);
/// assert_eq!(&edge_olx, edge_yly);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_edg_across_r19 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_edge(&$input.edge).unwrap()
    }};
}
pub use drawing_get_one_edg_across_r19;

/// Macro to traverse [`Edge`][ğŸ¦€] â¡ [`ObjectEdge`][ğŸ¦], via _R19(c)_
///
/// This macro expects a &[`Edge`][ğŸ¦€], and returns an Option<&[`ObjectEdge`][ğŸ¦]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ğŸ¦€]: crate::drawing::types::Edge
/// [ğŸ¦]: crate::drawing::types::ObjectEdge
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing_maybe_get_one_oui_e_across_r19;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_sey = Edge::test_default(&mut store);
/// let point_jrp = Point::new(&mut store, 42, 42);
/// let furtive_structure = "real_chickens".to_owned();
/// let object_mkk = Object::default();
///
/// let object_ui_riv = ObjectUi::new(&mut store, &point_jrp, &object_mkk, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_sey, &object_ui_riv);
/// let object_edge_wdk = drawing_maybe_get_one_oui_e_across_r19!(edge_sey, store);
///
/// assert_eq!(Some(&object_edge), object_edge_wdk);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_oui_e_across_r19 {
    ($input:expr, $store:expr) => {{
        // {"magic":"î¨","kind":"CriticalBlockBegin"}
        // {"magic":"î¨","kind":{"CriticalBlockBegin":{"tag":"edge-object_edge-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_object_edge()
            .find(|z| z.1.edge == $input.get_id())
            .map(|(_, z)| z)
// âš¡ï¸         // {"magic":"î¨","kind":"CriticalBlockEnd"}
            // {"magic":"î¨","kind":{"CriticalBlockEnd":{"tag":"edge-object_edge-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_oui_e_across_r19;

/// Macro to traverse [`BinaryUi`][ğŸ¦€] â¡ [`Anchor`][ğŸ¦], via _R7_
///
/// This macro expects a &[`BinaryUi`][ğŸ¦€], and returns a &[`Anchor`][ğŸ¦].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ğŸ¦€]: crate::drawing::types::BinaryUi
/// [ğŸ¦]: crate::drawing::types::Anchor
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_get_one_anch_across_r7;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_pqk = Point::new(&mut store, 42, 42);
/// let point_ecb = Point::new(&mut store, 42, 42);
/// let edge_mnd = Edge::test_default(&mut store);
/// let anchor_rdi = Anchor::new(&mut store, &point_pqk, &point_ecb, &edge_mnd);
/// let point_cis = Point::new(&mut store, 42, 42);
/// let point_xjy = Point::new(&mut store, 42, 42);
/// let edge_vmm = Edge::test_default(&mut store);
/// let anchor_qse = Anchor::new(&mut store, &point_cis, &point_xjy, &edge_vmm);
/// let binary_umh = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_rdi, &anchor_qse, &binary_umh);
///
/// let anchor_xox = drawing_get_one_anch_across_r7!(binary_ui, store);
/// assert_eq!(&anchor_rdi, anchor_xox);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_anch_across_r7 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.from).unwrap()
    }};
}
pub use drawing_get_one_anch_across_r7;

/// Macro to traverse [`Anchor`][ğŸ¦€] â¡ [`BinaryUi`][ğŸ¦], via _R7(c)_
///
/// This macro expects a &[`Anchor`][ğŸ¦€], and returns an Option<&[`BinaryUi`][ğŸ¦]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ğŸ¦€]: crate::drawing::types::Anchor
/// [ğŸ¦]: crate::drawing::types::BinaryUi
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_bui_across_r7;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_iji = Point::new(&mut store, 42, 42);
/// let point_ovy = Point::new(&mut store, 42, 42);
/// let edge_wte = Edge::test_default(&mut store);
/// let anchor_qhx = Anchor::new(&mut store, &point_iji, &point_ovy, &edge_wte);
/// let point_afb = Point::new(&mut store, 42, 42);
/// let point_xuf = Point::new(&mut store, 42, 42);
/// let edge_boi = Edge::test_default(&mut store);
/// let anchor_uxf = Anchor::new(&mut store, &point_afb, &point_xuf, &edge_boi);
/// let binary_cqu = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_qhx, &anchor_uxf, &binary_cqu);
/// let binary_ui_bqj = drawing_maybe_get_one_bui_across_r7!(anchor_qhx, store);
///
/// assert_eq!(Some(&binary_ui), binary_ui_bqj);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_bui_across_r7 {
    ($input:expr, $store:expr) => {{
        // {"magic":"î¨","kind":"CriticalBlockBegin"}
        // {"magic":"î¨","kind":{"CriticalBlockBegin":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_binary_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
// âš¡ï¸         // {"magic":"î¨","kind":"CriticalBlockEnd"}
            // {"magic":"î¨","kind":{"CriticalBlockEnd":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_bui_across_r7;

/// Macro to traverse [`Anchor`][ğŸ¦€] â¡ [`Point`][ğŸ¦], via _R4_
///
/// This macro expects a &[`Anchor`][ğŸ¦€], and returns a &[`Point`][ğŸ¦].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ğŸ¦€]: crate::drawing::types::Anchor
/// [ğŸ¦]: crate::drawing::types::Point
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_pnt_across_r4;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_hwu = Point::new(&mut store, 42, 42);
/// let point_vxr = Point::new(&mut store, 42, 42);
/// let edge_ytn = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_hwu, &point_vxr, &edge_ytn);
///
/// let point_lvy = drawing_get_one_pnt_across_r4!(anchor, store);
/// assert_eq!(&point_hwu, point_lvy);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_get_one_pnt_across_r4 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.location).unwrap()
    }};
}
pub use drawing_get_one_pnt_across_r4;

/// Macro to traverse [`Point`][ğŸ¦€] â¡ [`Anchor`][ğŸ¦], via _R4(c)_
///
/// This macro expects a &[`Point`][ğŸ¦€], and returns an Option<&[`Anchor`][ğŸ¦]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ğŸ¦€]: crate::drawing::types::Point
/// [ğŸ¦]: crate::drawing::types::Anchor
// {"magic":"î¨","kind":"IgnoreBlockBegin"}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_maybe_get_one_anch_across_r4;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_hqs = Point::new(&mut store, 42, 42);
/// let point_gst = Point::new(&mut store, 42, 42);
/// let edge_neu = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_hqs, &point_gst, &edge_neu);
/// let anchor_ekf = drawing_maybe_get_one_anch_across_r4!(point_hqs, store);
///
/// assert_eq!(Some(&anchor), anchor_ekf);
///```
// {"magic":"î¨","kind":"IgnoreBlockEnd"}
#[macro_export]
macro_rules! drawing_maybe_get_one_anch_across_r4 {
    ($input:expr, $store:expr) => {{
        // {"magic":"î¨","kind":"CriticalBlockBegin"}
        // {"magic":"î¨","kind":{"CriticalBlockBegin":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.location == $input.id)
            .map(|(_, z)| z)
// âš¡ï¸         // {"magic":"î¨","kind":"CriticalBlockEnd"}
            // {"magic":"î¨","kind":{"CriticalBlockEnd":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_anch_across_r4;
