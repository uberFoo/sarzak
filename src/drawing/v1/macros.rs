//! Macros for navigating the "Drawing" domain
//!
//! # Generated Code -- edit _with care_.
//!
//! Don't mess with anything between `{"magic":"îž¨","kind":"CriticalBlockBegin"}`
//! and `{"magic":"îž¨","kind":"CriticalBlockEnd"}`. Otherwise, you should be free
//! to go wild. Happy hacking!
//!
//! Use the following invocation to reproduce:
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
//! ```shell
//!  sarzak gen
//! ```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
// {"magic":"îž¨","version":"0.5.0"}
// {"magic":"îž¨","version":"1.0.0"}

/// Macro to traverse [`IsaUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R9_
///
/// This macro expects a &[`IsaUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::IsaUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::drawing_get_one_anch_across_r9;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let isa_yag = Isa::default();
///
/// let point_grp = Point::new(&mut store, 42, 42);
/// let point_jnw = Point::new(&mut store, 42, 42);
/// let edge_bhn = Edge::test_default(&mut store);
/// let anchor_lwc = Anchor::new(&mut store, &point_grp, &point_jnw, &edge_bhn);
///
/// let isa_ui = IsaUi::new(&mut store, &isa_yag, &anchor_lwc);
///
/// let anchor_xus = drawing_get_one_anch_across_r9!(isa_ui, store);
/// assert_eq!(&anchor_lwc, anchor_xus);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_anch_across_r9-emit_binary_main"}}}
macro_rules! drawing_get_one_anch_across_r9 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.from).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_anch_across_r9;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_anch_across_r9-emit_binary_main"}}}

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`IsaUi`][ðŸ¦ž], via _R9(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`IsaUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::IsaUi
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing_maybe_get_one_iui_across_r9;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let isa_jvx = Isa::default();
///
/// let point_eaw = Point::new(&mut store, 42, 42);
/// let point_zsz = Point::new(&mut store, 42, 42);
/// let edge_csw = Edge::test_default(&mut store);
/// let anchor_ecp = Anchor::new(&mut store, &point_eaw, &point_zsz, &edge_csw);
///
/// let isa_ui = IsaUi::new(&mut store, &isa_jvx, &anchor_ecp);
/// let isa_ui_ado = drawing_maybe_get_one_iui_across_r9!(anchor_ecp, store);
///
/// assert_eq!(Some(&isa_ui), isa_ui_ado);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_iui_across_r9-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_iui_across_r9 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-isa_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_isa_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-isa_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_iui_across_r9;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_iui_across_r9-emit_binary_main"}}}

/// Macro to traverse [`AssociativeUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R15_
///
/// This macro expects a &[`AssociativeUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::AssociativeUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_anch_across_r15;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_dah = Associative::default();
///
/// let point_fwv = Point::new(&mut store, 42, 42);
/// let point_gps = Point::new(&mut store, 42, 42);
/// let edge_jow = Edge::test_default(&mut store);
/// let anchor_wmi = Anchor::new(&mut store, &point_fwv, &point_gps, &edge_jow);
/// let point_rer = Point::new(&mut store, 42, 42);
/// let point_xly = Point::new(&mut store, 42, 42);
/// let edge_gdz = Edge::test_default(&mut store);
/// let anchor_elm = Anchor::new(&mut store, &point_rer, &point_xly, &edge_gdz);
/// let point_uxw = Point::new(&mut store, 42, 42);
/// let point_uxs = Point::new(&mut store, 42, 42);
/// let edge_luo = Edge::test_default(&mut store);
/// let anchor_ekb = Anchor::new(&mut store, &point_uxw, &point_uxs, &edge_luo);
/// let point_uqe = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_dah, &anchor_wmi, &anchor_elm, &anchor_ekb, &point_uqe);
///
/// let anchor_sxp = drawing_get_one_anch_across_r15!(associative_ui, store);
/// assert_eq!(&anchor_wmi, anchor_sxp);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_anch_across_r15-emit_binary_main"}}}
macro_rules! drawing_get_one_anch_across_r15 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.other).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_anch_across_r15;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_anch_across_r15-emit_binary_main"}}}

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`AssociativeUi`][ðŸ¦ž], via _R15(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`AssociativeUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::AssociativeUi
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_aui_across_r15;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_rdc = Associative::default();
///
/// let point_jwl = Point::new(&mut store, 42, 42);
/// let point_pdu = Point::new(&mut store, 42, 42);
/// let edge_ull = Edge::test_default(&mut store);
/// let anchor_ftb = Anchor::new(&mut store, &point_jwl, &point_pdu, &edge_ull);
/// let point_gcb = Point::new(&mut store, 42, 42);
/// let point_dmj = Point::new(&mut store, 42, 42);
/// let edge_juc = Edge::test_default(&mut store);
/// let anchor_dcc = Anchor::new(&mut store, &point_gcb, &point_dmj, &edge_juc);
/// let point_ote = Point::new(&mut store, 42, 42);
/// let point_pmm = Point::new(&mut store, 42, 42);
/// let edge_dca = Edge::test_default(&mut store);
/// let anchor_nmf = Anchor::new(&mut store, &point_ote, &point_pmm, &edge_dca);
/// let point_rdg = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_rdc, &anchor_ftb, &anchor_dcc, &anchor_nmf, &point_rdg);
/// let associative_ui_irm = drawing_maybe_get_one_aui_across_r15!(anchor_ftb, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_irm);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_aui_across_r15-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_aui_across_r15 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.other == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r15;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_aui_across_r15-emit_binary_main"}}}

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`Point`][ðŸ¦ž], via _R5_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns a &[`Point`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::Point
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_get_one_pnt_across_r5;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_plp = Point::new(&mut store, 42, 42);
/// let point_iou = Point::new(&mut store, 42, 42);
/// let edge_roj = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_plp, &point_iou, &edge_roj);
///
/// let point_mni = drawing_get_one_pnt_across_r5!(anchor, store);
/// assert_eq!(&point_plp, point_mni);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_pnt_across_r5-emit_binary_main"}}}
macro_rules! drawing_get_one_pnt_across_r5 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.offset).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_pnt_across_r5;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_pnt_across_r5-emit_binary_main"}}}

/// Macro to traverse [`Point`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R5(c)_
///
/// This macro expects a &[`Point`][ðŸ¦€], and returns an Option<&[`Anchor`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Point
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_anch_across_r5;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_zlz = Point::new(&mut store, 42, 42);
/// let point_brj = Point::new(&mut store, 42, 42);
/// let edge_ssg = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_zlz, &point_brj, &edge_ssg);
/// let anchor_nkf = drawing_maybe_get_one_anch_across_r5!(point_zlz, store);
///
/// assert_eq!(Some(&anchor), anchor_nkf);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_anch_across_r5-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_anch_across_r5 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.offset == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_anch_across_r5;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_anch_across_r5-emit_binary_main"}}}

/// Macro to traverse [`AssociativeUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R14_
///
/// This macro expects a &[`AssociativeUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::AssociativeUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing_get_one_anch_across_r14;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_tja = Associative::default();
///
/// let point_zur = Point::new(&mut store, 42, 42);
/// let point_uzi = Point::new(&mut store, 42, 42);
/// let edge_kcq = Edge::test_default(&mut store);
/// let anchor_sfk = Anchor::new(&mut store, &point_zur, &point_uzi, &edge_kcq);
/// let point_zkb = Point::new(&mut store, 42, 42);
/// let point_pfe = Point::new(&mut store, 42, 42);
/// let edge_wom = Edge::test_default(&mut store);
/// let anchor_yrs = Anchor::new(&mut store, &point_zkb, &point_pfe, &edge_wom);
/// let point_dol = Point::new(&mut store, 42, 42);
/// let point_mei = Point::new(&mut store, 42, 42);
/// let edge_tmw = Edge::test_default(&mut store);
/// let anchor_gsf = Anchor::new(&mut store, &point_dol, &point_mei, &edge_tmw);
/// let point_rms = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_tja, &anchor_sfk, &anchor_yrs, &anchor_gsf, &point_rms);
///
/// let anchor_esv = drawing_get_one_anch_across_r14!(associative_ui, store);
/// assert_eq!(&anchor_sfk, anchor_esv);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_anch_across_r14-emit_binary_main"}}}
macro_rules! drawing_get_one_anch_across_r14 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.one).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_anch_across_r14;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_anch_across_r14-emit_binary_main"}}}

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`AssociativeUi`][ðŸ¦ž], via _R14(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`AssociativeUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::AssociativeUi
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing_maybe_get_one_aui_across_r14;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_kjp = Associative::default();
///
/// let point_ctq = Point::new(&mut store, 42, 42);
/// let point_uyo = Point::new(&mut store, 42, 42);
/// let edge_lwi = Edge::test_default(&mut store);
/// let anchor_jif = Anchor::new(&mut store, &point_ctq, &point_uyo, &edge_lwi);
/// let point_rlr = Point::new(&mut store, 42, 42);
/// let point_pit = Point::new(&mut store, 42, 42);
/// let edge_bfd = Edge::test_default(&mut store);
/// let anchor_ecs = Anchor::new(&mut store, &point_rlr, &point_pit, &edge_bfd);
/// let point_stz = Point::new(&mut store, 42, 42);
/// let point_mba = Point::new(&mut store, 42, 42);
/// let edge_ofc = Edge::test_default(&mut store);
/// let anchor_qsz = Anchor::new(&mut store, &point_stz, &point_mba, &edge_ofc);
/// let point_deh = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_kjp, &anchor_jif, &anchor_ecs, &anchor_qsz, &point_deh);
/// let associative_ui_cdi = drawing_maybe_get_one_aui_across_r14!(anchor_jif, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_cdi);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_aui_across_r14-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_aui_across_r14 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.one == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r14;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_aui_across_r14-emit_binary_main"}}}

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`IsaUi`][ðŸ¦ž], across [`SubtypeAnchors`][ðŸ¦‘] via _R10_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns a &[`IsaUi`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::IsaUi
/// [ðŸ¦‘]: crate::drawing::types::SubtypeAnchors
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::SubtypeAnchors;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_maybe_get_one_iui_across_r10;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_yae = Point::new(&mut store, 42, 42);
/// let point_nbr = Point::new(&mut store, 42, 42);
/// let edge_ygx = Edge::test_default(&mut store);
/// let anchor_syy = Anchor::new(&mut store, &point_yae, &point_nbr, &edge_ygx);
/// let isa_ggd = Isa::default();
///
/// let point_fkb = Point::new(&mut store, 42, 42);
/// let point_rde = Point::new(&mut store, 42, 42);
/// let edge_ual = Edge::test_default(&mut store);
/// let anchor_ggy = Anchor::new(&mut store, &point_fkb, &point_rde, &edge_ual);
/// let isa_ui_scp = IsaUi::new(&mut store, &isa_ggd, &anchor_ggy);
/// let subtype_anchors = SubtypeAnchors::new(&mut store, &anchor_syy, &isa_ui_scp);
///
/// let isa_ui_sci = drawing_maybe_get_one_iui_across_r10!(anchor_syy, store);
/// assert_eq!(Some(&isa_ui_scp), isa_ui_sci);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_iui_across_r10-emit_associative_main"}}}
macro_rules! drawing_maybe_get_one_iui_across_r10 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_maybe_get_one
        $store
            .iter_subtype_anchors()
            .filter(|a| a.1.anchor_id == $input.id)
            .next()
            .and_then(|a| $store.exhume_isa_ui(&a.1.isaui_id))
    }};
}
pub use drawing_maybe_get_one_iui_across_r10;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_iui_across_r10-emit_associative_main"}}}

/// Macro to traverse [`IsaUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], across [`SubtypeAnchors`][ðŸ¦‘] via _R10_
///
/// This macro expects a &[`IsaUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_associative_macros`
///
/// [ðŸ¦€]: crate::drawing::types::IsaUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
/// [ðŸ¦‘]: crate::drawing::types::SubtypeAnchors
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::IsaUi;
/// # use sarzak::sarzak::Isa;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::SubtypeAnchors;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_many_anch_across_r10;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_ktq = Point::new(&mut store, 42, 42);
/// let point_lza = Point::new(&mut store, 42, 42);
/// let edge_fje = Edge::test_default(&mut store);
/// let anchor_ptu = Anchor::new(&mut store, &point_ktq, &point_lza, &edge_fje);
/// let isa_dhd = Isa::default();
///
/// let point_uno = Point::new(&mut store, 42, 42);
/// let point_jdj = Point::new(&mut store, 42, 42);
/// let edge_vwq = Edge::test_default(&mut store);
/// let anchor_mfy = Anchor::new(&mut store, &point_uno, &point_jdj, &edge_vwq);
/// let isa_ui_hmu = IsaUi::new(&mut store, &isa_dhd, &anchor_mfy);
/// let subtype_anchors = SubtypeAnchors::new(&mut store, &anchor_ptu, &isa_ui_hmu);
///
/// let anchor_chr = drawing_get_many_anch_across_r10!(isa_ui_hmu, store);
/// assert!(anchor_chr.iter().find(|&x| **x == anchor_ptu).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_many_anch_across_r10-emit_associative_main"}}}
macro_rules! drawing_get_many_anch_across_r10 {
    ($input:expr, $store:expr) => {{
        // nut::codegen::template::macros::emit_assoc_many
        $store
            .iter_subtype_anchors()
            .filter(|a| a.1.isaui_id == $input.id)
            .map(|a| $store.exhume_anchor(&a.1.anchor_id).unwrap())
            .collect::<Vec<&Anchor>>()
    }};
}
pub use drawing_get_many_anch_across_r10;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_many_anch_across_r10-emit_associative_main"}}}

/// Macro to traverse [`ObjectUi`][ðŸ¦€] âž¡ [`Point`][ðŸ¦ž], via _R13_
///
/// This macro expects a &[`ObjectUi`][ðŸ¦€], and returns a &[`Point`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::ObjectUi
/// [ðŸ¦ž]: crate::drawing::types::Point
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing_get_one_pnt_across_r13;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_zkj = Point::new(&mut store, 42, 42);
/// let abortive_donkey = "interesting_slave".to_owned();
/// let object_vfs = Object::default();
///
///
/// let object_ui = ObjectUi::new(&mut store, &point_zkj, &object_vfs, 42, 42);
///
/// let point_hnh = drawing_get_one_pnt_across_r13!(object_ui, store);
/// assert_eq!(&point_zkj, point_hnh);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_pnt_across_r13-emit_binary_main"}}}
macro_rules! drawing_get_one_pnt_across_r13 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.origin).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_pnt_across_r13;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_pnt_across_r13-emit_binary_main"}}}

/// Macro to traverse [`Point`][ðŸ¦€] âž¡ [`ObjectUi`][ðŸ¦ž], via _R13(c)_
///
/// This macro expects a &[`Point`][ðŸ¦€], and returns an Option<&[`ObjectUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Point
/// [ðŸ¦ž]: crate::drawing::types::ObjectUi
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing_maybe_get_one_oui_across_r13;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_sfy = Point::new(&mut store, 42, 42);
/// let childlike_bite = "quickest_spoon".to_owned();
/// let object_jqg = Object::default();
///
///
/// let object_ui = ObjectUi::new(&mut store, &point_sfy, &object_jqg, 42, 42);
/// let object_ui_poz = drawing_maybe_get_one_oui_across_r13!(point_sfy, store);
///
/// assert_eq!(Some(&object_ui), object_ui_poz);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_oui_across_r13-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_oui_across_r13 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-object_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_object_ui()
            .find(|z| z.1.origin == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-object_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_oui_across_r13;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_oui_across_r13-emit_binary_main"}}}

/// Macro to traverse [`AssociativeUi`][ðŸ¦€] âž¡ [`Point`][ðŸ¦ž], via _R17_
///
/// This macro expects a &[`AssociativeUi`][ðŸ¦€], and returns a &[`Point`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::AssociativeUi
/// [ðŸ¦ž]: crate::drawing::types::Point
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_get_one_pnt_across_r17;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_eov = Associative::default();
///
/// let point_vgb = Point::new(&mut store, 42, 42);
/// let point_jiu = Point::new(&mut store, 42, 42);
/// let edge_vbv = Edge::test_default(&mut store);
/// let anchor_yzn = Anchor::new(&mut store, &point_vgb, &point_jiu, &edge_vbv);
/// let point_ylp = Point::new(&mut store, 42, 42);
/// let point_kza = Point::new(&mut store, 42, 42);
/// let edge_xmt = Edge::test_default(&mut store);
/// let anchor_tpz = Anchor::new(&mut store, &point_ylp, &point_kza, &edge_xmt);
/// let point_hql = Point::new(&mut store, 42, 42);
/// let point_bjp = Point::new(&mut store, 42, 42);
/// let edge_mhg = Edge::test_default(&mut store);
/// let anchor_fpl = Anchor::new(&mut store, &point_hql, &point_bjp, &edge_mhg);
/// let point_joe = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_eov, &anchor_yzn, &anchor_tpz, &anchor_fpl, &point_joe);
///
/// let point_olf = drawing_get_one_pnt_across_r17!(associative_ui, store);
/// assert_eq!(&point_joe, point_olf);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_pnt_across_r17-emit_binary_main"}}}
macro_rules! drawing_get_one_pnt_across_r17 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.from).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_pnt_across_r17;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_pnt_across_r17-emit_binary_main"}}}

/// Macro to traverse [`Point`][ðŸ¦€] âž¡ [`AssociativeUi`][ðŸ¦ž], via _R17(c)_
///
/// This macro expects a &[`Point`][ðŸ¦€], and returns an Option<&[`AssociativeUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Point
/// [ðŸ¦ž]: crate::drawing::types::AssociativeUi
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_maybe_get_one_aui_across_r17;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_cdd = Associative::default();
///
/// let point_ijy = Point::new(&mut store, 42, 42);
/// let point_lta = Point::new(&mut store, 42, 42);
/// let edge_jef = Edge::test_default(&mut store);
/// let anchor_nmj = Anchor::new(&mut store, &point_ijy, &point_lta, &edge_jef);
/// let point_tjz = Point::new(&mut store, 42, 42);
/// let point_ibh = Point::new(&mut store, 42, 42);
/// let edge_dti = Edge::test_default(&mut store);
/// let anchor_yst = Anchor::new(&mut store, &point_tjz, &point_ibh, &edge_dti);
/// let point_som = Point::new(&mut store, 42, 42);
/// let point_fax = Point::new(&mut store, 42, 42);
/// let edge_gda = Edge::test_default(&mut store);
/// let anchor_mbh = Anchor::new(&mut store, &point_som, &point_fax, &edge_gda);
/// let point_nfv = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_cdd, &anchor_nmj, &anchor_yst, &anchor_mbh, &point_nfv);
/// let associative_ui_puc = drawing_maybe_get_one_aui_across_r17!(point_nfv, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_puc);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_aui_across_r17-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_aui_across_r17 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r17;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_aui_across_r17-emit_binary_main"}}}

/// Macro to traverse [`ObjectEdge`][ðŸ¦€] âž¡ [`ObjectUi`][ðŸ¦ž], via _R18_
///
/// This macro expects a &[`ObjectEdge`][ðŸ¦€], and returns a &[`ObjectUi`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::ObjectEdge
/// [ðŸ¦ž]: crate::drawing::types::ObjectUi
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing_get_one_oui_across_r18;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_era = Edge::test_default(&mut store);
/// let point_nnq = Point::new(&mut store, 42, 42);
/// let disagreeable_apple = "calculating_pigs".to_owned();
/// let object_vip = Object::default();
///
/// let object_ui_oqe = ObjectUi::new(&mut store, &point_nnq, &object_vip, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_era, &object_ui_oqe);
///
/// let object_ui_qle = drawing_get_one_oui_across_r18!(object_edge, store);
/// assert_eq!(&object_ui_oqe, object_ui_qle);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_oui_across_r18-emit_binary_main"}}}
macro_rules! drawing_get_one_oui_across_r18 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object_ui-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_object_ui(&$input.oui_id).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object_ui-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_oui_across_r18;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_oui_across_r18-emit_binary_main"}}}

/// Macro to traverse [`ObjectUi`][ðŸ¦€] âž¡ [`ObjectEdge`][ðŸ¦ž], via _R18_
///
/// This macro expects a &[`ObjectUi`][ðŸ¦€], and returns a &[`ObjectEdge`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::ObjectUi
/// [ðŸ¦ž]: crate::drawing::types::ObjectEdge
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_many_oui_es_across_r18;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_dwh = Edge::test_default(&mut store);
/// let point_vjn = Point::new(&mut store, 42, 42);
/// let successful_grandfather = "astonishing_feast".to_owned();
/// let object_zls = Object::default();
///
/// let object_ui_zif = ObjectUi::new(&mut store, &point_vjn, &object_zls, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_dwh, &object_ui_zif);
/// let object_edge_hlo = drawing_get_many_oui_es_across_r18!(object_ui_zif, store);
///
/// assert!(object_edge_hlo.iter().find(|&x| **x == object_edge).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_many_oui_es_across_r18-emit_binary_main"}}}
macro_rules! drawing_get_many_oui_es_across_r18 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"object_ui-object_edge-emit_many_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_many_conditional_lookup
        $store
            .iter_object_edge()
            .filter_map(|z| if z.1.oui_id == $input.id { Some(z.1) } else { None })
            .collect::<Vec<&ObjectEdge>>()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"object_ui-object_edge-emit_many_conditional_lookup"}}}
    }};
}
pub use drawing_get_many_oui_es_across_r18;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_many_oui_es_across_r18-emit_binary_main"}}}

/// Macro to traverse [`BinaryUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R8_
///
/// This macro expects a &[`BinaryUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::BinaryUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing_get_one_anch_across_r8;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_hvf = Point::new(&mut store, 42, 42);
/// let point_nvo = Point::new(&mut store, 42, 42);
/// let edge_kcb = Edge::test_default(&mut store);
/// let anchor_fbf = Anchor::new(&mut store, &point_hvf, &point_nvo, &edge_kcb);
/// let point_erd = Point::new(&mut store, 42, 42);
/// let point_aap = Point::new(&mut store, 42, 42);
/// let edge_glk = Edge::test_default(&mut store);
/// let anchor_zma = Anchor::new(&mut store, &point_erd, &point_aap, &edge_glk);
/// let binary_dfb = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_fbf, &anchor_zma, &binary_dfb);
///
/// let anchor_nky = drawing_get_one_anch_across_r8!(binary_ui, store);
/// assert_eq!(&anchor_fbf, anchor_nky);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_anch_across_r8-emit_binary_main"}}}
macro_rules! drawing_get_one_anch_across_r8 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.to).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_anch_across_r8;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_anch_across_r8-emit_binary_main"}}}

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`BinaryUi`][ðŸ¦ž], via _R8(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`BinaryUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::BinaryUi
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_bui_across_r8;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_uuk = Point::new(&mut store, 42, 42);
/// let point_tlc = Point::new(&mut store, 42, 42);
/// let edge_edm = Edge::test_default(&mut store);
/// let anchor_gqb = Anchor::new(&mut store, &point_uuk, &point_tlc, &edge_edm);
/// let point_hem = Point::new(&mut store, 42, 42);
/// let point_gnu = Point::new(&mut store, 42, 42);
/// let edge_vyo = Edge::test_default(&mut store);
/// let anchor_xkq = Anchor::new(&mut store, &point_hem, &point_gnu, &edge_vyo);
/// let binary_myl = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_gqb, &anchor_xkq, &binary_myl);
/// let binary_ui_tzb = drawing_maybe_get_one_bui_across_r8!(anchor_gqb, store);
///
/// assert_eq!(Some(&binary_ui), binary_ui_tzb);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_bui_across_r8-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_bui_across_r8 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_binary_ui()
            .find(|z| z.1.to == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_bui_across_r8;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_bui_across_r8-emit_binary_main"}}}

/// Macro to traverse [`AssociativeUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R16_
///
/// This macro expects a &[`AssociativeUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::AssociativeUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_anch_across_r16;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_ovg = Associative::default();
///
/// let point_fdj = Point::new(&mut store, 42, 42);
/// let point_bnk = Point::new(&mut store, 42, 42);
/// let edge_qga = Edge::test_default(&mut store);
/// let anchor_jhd = Anchor::new(&mut store, &point_fdj, &point_bnk, &edge_qga);
/// let point_ivc = Point::new(&mut store, 42, 42);
/// let point_nnj = Point::new(&mut store, 42, 42);
/// let edge_rsi = Edge::test_default(&mut store);
/// let anchor_qgp = Anchor::new(&mut store, &point_ivc, &point_nnj, &edge_rsi);
/// let point_lge = Point::new(&mut store, 42, 42);
/// let point_zhb = Point::new(&mut store, 42, 42);
/// let edge_myt = Edge::test_default(&mut store);
/// let anchor_yqf = Anchor::new(&mut store, &point_lge, &point_zhb, &edge_myt);
/// let point_prk = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_ovg, &anchor_jhd, &anchor_qgp, &anchor_yqf, &point_prk);
///
/// let anchor_ngf = drawing_get_one_anch_across_r16!(associative_ui, store);
/// assert_eq!(&anchor_jhd, anchor_ngf);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_anch_across_r16-emit_binary_main"}}}
macro_rules! drawing_get_one_anch_across_r16 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.middle).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_anch_across_r16;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_anch_across_r16-emit_binary_main"}}}

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`AssociativeUi`][ðŸ¦ž], via _R16(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`AssociativeUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::AssociativeUi
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::AssociativeUi;
/// # use sarzak::sarzak::Associative;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_maybe_get_one_aui_across_r16;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let associative_sbr = Associative::default();
///
/// let point_lgg = Point::new(&mut store, 42, 42);
/// let point_axp = Point::new(&mut store, 42, 42);
/// let edge_dnu = Edge::test_default(&mut store);
/// let anchor_hjh = Anchor::new(&mut store, &point_lgg, &point_axp, &edge_dnu);
/// let point_qce = Point::new(&mut store, 42, 42);
/// let point_aao = Point::new(&mut store, 42, 42);
/// let edge_xyo = Edge::test_default(&mut store);
/// let anchor_joc = Anchor::new(&mut store, &point_qce, &point_aao, &edge_xyo);
/// let point_wnq = Point::new(&mut store, 42, 42);
/// let point_lai = Point::new(&mut store, 42, 42);
/// let edge_qrs = Edge::test_default(&mut store);
/// let anchor_gku = Anchor::new(&mut store, &point_wnq, &point_lai, &edge_qrs);
/// let point_euw = Point::new(&mut store, 42, 42);
///
/// let associative_ui = AssociativeUi::new(&mut store, &associative_sbr, &anchor_hjh, &anchor_joc, &anchor_gku, &point_euw);
/// let associative_ui_qxa = drawing_maybe_get_one_aui_across_r16!(anchor_hjh, store);
///
/// assert_eq!(Some(&associative_ui), associative_ui_qxa);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_aui_across_r16-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_aui_across_r16 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_associative_ui()
            .find(|z| z.1.middle == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-associative_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_aui_across_r16;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_aui_across_r16-emit_binary_main"}}}

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`Edge`][ðŸ¦ž], via _R3_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns a &[`Edge`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::Edge
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_get_one_edg_across_r3;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_gnh = Point::new(&mut store, 42, 42);
/// let point_ldh = Point::new(&mut store, 42, 42);
/// let edge_xnq = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_gnh, &point_ldh, &edge_xnq);
///
/// let edge_wir = drawing_get_one_edg_across_r3!(anchor, store);
/// assert_eq!(&edge_xnq, edge_wir);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_edg_across_r3-emit_binary_main"}}}
macro_rules! drawing_get_one_edg_across_r3 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"edge-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_edge(&$input.edge).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"edge-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_edg_across_r3;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_edg_across_r3-emit_binary_main"}}}

/// Macro to traverse [`Edge`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R3(c)_
///
/// This macro expects a &[`Edge`][ðŸ¦€], and returns an Option<&[`Anchor`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Edge
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing_maybe_get_one_anch_across_r3;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_khg = Point::new(&mut store, 42, 42);
/// let point_aci = Point::new(&mut store, 42, 42);
/// let edge_zlm = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_khg, &point_aci, &edge_zlm);
/// let anchor_aox = drawing_maybe_get_one_anch_across_r3!(edge_zlm, store);
///
/// assert_eq!(Some(&anchor), anchor_aox);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_anch_across_r3-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_anch_across_r3 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"edge-anchor-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.edge == $input.get_id())
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"edge-anchor-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_anch_across_r3;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_anch_across_r3-emit_binary_main"}}}

/// Macro to traverse [`ObjectEdge`][ðŸ¦€] âž¡ [`Edge`][ðŸ¦ž], via _R19_
///
/// This macro expects a &[`ObjectEdge`][ðŸ¦€], and returns a &[`Edge`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::ObjectEdge
/// [ðŸ¦ž]: crate::drawing::types::Edge
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing_get_one_edg_across_r19;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_jfb = Edge::test_default(&mut store);
/// let point_zsb = Point::new(&mut store, 42, 42);
/// let testy_arch = "young_dog".to_owned();
/// let object_xqv = Object::default();
///
/// let object_ui_ryx = ObjectUi::new(&mut store, &point_zsb, &object_xqv, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_jfb, &object_ui_ryx);
///
/// let edge_sje = drawing_get_one_edg_across_r19!(object_edge, store);
/// assert_eq!(&edge_jfb, edge_sje);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_edg_across_r19-emit_binary_main"}}}
macro_rules! drawing_get_one_edg_across_r19 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"edge-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_edge(&$input.edge).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"edge-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_edg_across_r19;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_edg_across_r19-emit_binary_main"}}}

/// Macro to traverse [`Edge`][ðŸ¦€] âž¡ [`ObjectEdge`][ðŸ¦ž], via _R19(c)_
///
/// This macro expects a &[`Edge`][ðŸ¦€], and returns an Option<&[`ObjectEdge`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Edge
/// [ðŸ¦ž]: crate::drawing::types::ObjectEdge
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::sarzak::Object;
/// # use sarzak::drawing::ObjectUi;
/// # use sarzak::drawing::ObjectEdge;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_maybe_get_one_oui_e_across_r19;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let edge_ixo = Edge::test_default(&mut store);
/// let point_mrb = Point::new(&mut store, 42, 42);
/// let nifty_drink = "outgoing_tub".to_owned();
/// let object_nmq = Object::default();
///
/// let object_ui_dto = ObjectUi::new(&mut store, &point_mrb, &object_nmq, 42, 42);
///
/// let object_edge = ObjectEdge::new(&mut store, &edge_ixo, &object_ui_dto);
/// let object_edge_fzn = drawing_maybe_get_one_oui_e_across_r19!(edge_ixo, store);
///
/// assert_eq!(Some(&object_edge), object_edge_fzn);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_oui_e_across_r19-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_oui_e_across_r19 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"edge-object_edge-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_object_edge()
            .find(|z| z.1.edge == $input.get_id())
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"edge-object_edge-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_oui_e_across_r19;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_oui_e_across_r19-emit_binary_main"}}}

/// Macro to traverse [`BinaryUi`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R7_
///
/// This macro expects a &[`BinaryUi`][ðŸ¦€], and returns a &[`Anchor`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::BinaryUi
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Edge;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing_get_one_anch_across_r7;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_cuf = Point::new(&mut store, 42, 42);
/// let point_eno = Point::new(&mut store, 42, 42);
/// let edge_fty = Edge::test_default(&mut store);
/// let anchor_nft = Anchor::new(&mut store, &point_cuf, &point_eno, &edge_fty);
/// let point_arm = Point::new(&mut store, 42, 42);
/// let point_gye = Point::new(&mut store, 42, 42);
/// let edge_egg = Edge::test_default(&mut store);
/// let anchor_pfa = Anchor::new(&mut store, &point_arm, &point_gye, &edge_egg);
/// let binary_oja = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_nft, &anchor_pfa, &binary_oja);
///
/// let anchor_aqa = drawing_get_one_anch_across_r7!(binary_ui, store);
/// assert_eq!(&anchor_nft, anchor_aqa);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_anch_across_r7-emit_binary_main"}}}
macro_rules! drawing_get_one_anch_across_r7 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_anchor(&$input.from).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_anch_across_r7;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_anch_across_r7-emit_binary_main"}}}

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`BinaryUi`][ðŸ¦ž], via _R7(c)_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns an Option<&[`BinaryUi`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::BinaryUi
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::BinaryUi;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Point;
/// # use sarzak::sarzak::Binary;
/// # use sarzak::drawing_maybe_get_one_bui_across_r7;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_rhb = Point::new(&mut store, 42, 42);
/// let point_pjw = Point::new(&mut store, 42, 42);
/// let edge_hdu = Edge::test_default(&mut store);
/// let anchor_vun = Anchor::new(&mut store, &point_rhb, &point_pjw, &edge_hdu);
/// let point_mkw = Point::new(&mut store, 42, 42);
/// let point_ajb = Point::new(&mut store, 42, 42);
/// let edge_sdz = Edge::test_default(&mut store);
/// let anchor_xyn = Anchor::new(&mut store, &point_mkw, &point_ajb, &edge_sdz);
/// let binary_elm = Binary::default();
///
///
/// let binary_ui = BinaryUi::new(&mut store, &anchor_vun, &anchor_xyn, &binary_elm);
/// let binary_ui_hje = drawing_maybe_get_one_bui_across_r7!(anchor_vun, store);
///
/// assert_eq!(Some(&binary_ui), binary_ui_hje);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_bui_across_r7-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_bui_across_r7 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_binary_ui()
            .find(|z| z.1.from == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"anchor-binary_ui-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_bui_across_r7;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_bui_across_r7-emit_binary_main"}}}

/// Macro to traverse [`Anchor`][ðŸ¦€] âž¡ [`Point`][ðŸ¦ž], via _R4_
///
/// This macro expects a &[`Anchor`][ðŸ¦€], and returns a &[`Point`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Anchor
/// [ðŸ¦ž]: crate::drawing::types::Point
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing_get_one_pnt_across_r4;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_ozd = Point::new(&mut store, 42, 42);
/// let point_hgg = Point::new(&mut store, 42, 42);
/// let edge_oct = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_ozd, &point_hgg, &edge_oct);
///
/// let point_kmt = drawing_get_one_pnt_across_r4!(anchor, store);
/// assert_eq!(&point_ozd, point_kmt);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_get_one_pnt_across_r4-emit_binary_main"}}}
macro_rules! drawing_get_one_pnt_across_r4 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_point(&$input.location).unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-emit_one_unconditional"}}}
    }};
}
pub use drawing_get_one_pnt_across_r4;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_get_one_pnt_across_r4-emit_binary_main"}}}

/// Macro to traverse [`Point`][ðŸ¦€] âž¡ [`Anchor`][ðŸ¦ž], via _R4(c)_
///
/// This macro expects a &[`Point`][ðŸ¦€], and returns an Option<&[`Anchor`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::drawing::types::Point
/// [ðŸ¦ž]: crate::drawing::types::Anchor
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use sarzak::drawing::Anchor;
/// # use sarzak::drawing::Point;
/// # use sarzak::drawing::Edge;
/// # use sarzak::drawing_maybe_get_one_anch_across_r4;
/// # let mut store = sarzak::drawing::ObjectStore::new();
///
/// let point_cck = Point::new(&mut store, 42, 42);
/// let point_gbw = Point::new(&mut store, 42, 42);
/// let edge_mgx = Edge::test_default(&mut store);
///
/// let anchor = Anchor::new(&mut store, &point_cck, &point_gbw, &edge_mgx);
/// let anchor_udw = drawing_maybe_get_one_anch_across_r4!(point_cck, store);
///
/// assert_eq!(Some(&anchor), anchor_udw);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"drawing_maybe_get_one_anch_across_r4-emit_binary_main"}}}
macro_rules! drawing_maybe_get_one_anch_across_r4 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_anchor()
            .find(|z| z.1.location == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"point-anchor-emit_one_conditional_lookup"}}}
    }};
}
pub use drawing_maybe_get_one_anch_across_r4;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"drawing_maybe_get_one_anch_across_r4-emit_binary_main"}}}
